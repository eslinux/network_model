<html>
<head>
<title>embedded IPsec - IPsec library</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="doxygen.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<table width="98%" border="0" align="center">
  <tr>
    <td>
      <h2 align="left"><img src="logo_small.gif" alt="embedded IPsec"> source 
        code documentation </h2>
<hr>

<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>esp.c</h1><a href="esp_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * embedded IPsec</span>
00003 <span class="comment"> * Copyright (c) 2003 Niklaus Schild and Christian Scheurer, HTI Biel/Bienne</span>
00004 <span class="comment"> * All rights reserved.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> * Redistribution and use in source and binary forms, with or without modification,</span>
00007 <span class="comment"> * are permitted provided that the following conditions are met:</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span>
00010 <span class="comment"> *    this list of conditions and the following disclaimer.</span>
00011 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
00012 <span class="comment"> *    this list of conditions and the following disclaimer in the documentation</span>
00013 <span class="comment"> *    and/or other materials provided with the distribution.</span>
00014 <span class="comment"> * 3. The name of the author may not be used to endorse or promote products</span>
00015 <span class="comment"> *    derived from this software without specific prior written permission.</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED</span>
00018 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
00019 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT</span>
00020 <span class="comment"> * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
00021 <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT</span>
00022 <span class="comment"> * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
00023 <span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
00024 <span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
00025 <span class="comment"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY</span>
00026 <span class="comment"> * OF SUCH DAMAGE.</span>
00027 <span class="comment"> *</span>
00028 <span class="comment"> */</span>
00029 
00061 <span class="preprocessor">#include &lt;string.h&gt;</span>
00062 
00063 <span class="preprocessor">#include "<a class="code" href="ipsec_8h.html">ipsec/ipsec.h</a>"</span>
00064 <span class="preprocessor">#include "<a class="code" href="util_8h.html">ipsec/util.h</a>"</span>
00065 <span class="preprocessor">#include "<a class="code" href="debug_8h.html">ipsec/debug.h</a>"</span>
00066 
00067 <span class="preprocessor">#include "<a class="code" href="sa_8h.html">ipsec/sa.h</a>"</span>
00068 <span class="preprocessor">#include "<a class="code" href="des_8h.html">ipsec/des.h</a>"</span>
00069 <span class="preprocessor">#include "<a class="code" href="md5_8h.html">ipsec/md5.h</a>"</span>
00070 <span class="preprocessor">#include "<a class="code" href="sha1_8h.html">ipsec/sha1.h</a>"</span>
00071 
00072 <span class="preprocessor">#include "<a class="code" href="esp_8h.html">ipsec/esp.h</a>"</span>
00073 
00074 
<a name="l00075"></a><a class="code" href="esp_8c.html#a0">00075</a> <a class="code" href="types_8h.html#a4">__u32</a> <a class="code" href="esp_8c.html#a0">ipsec_esp_bitmap</a>  = 0;                    
<a name="l00078"></a><a class="code" href="esp_8c.html#a1">00078</a> <a class="code" href="types_8h.html#a4">__u32</a> <a class="code" href="esp_8c.html#a1">ipsec_esp_lastSeq</a> = 0;                    
<a name="l00090"></a><a class="code" href="esp_8c.html#a2">00090</a> <a class="code" href="types_8h.html#a0">__u8</a> <a class="code" href="esp_8c.html#a2">ipsec_esp_get_padding</a>(<span class="keywordtype">int</span> len)
00091 {
00092         <span class="keywordtype">int</span> padding ;
00093 
00094         <span class="keywordflow">for</span>(padding = 0; padding &lt; 8; padding++)
00095                 <span class="keywordflow">if</span>(((len+padding) % 8) == 0)
00096                         <span class="keywordflow">break</span> ;
00097         <span class="keywordflow">return</span> padding ;
00098 }
00099 
<a name="l00111"></a><a class="code" href="esp_8c.html#a3">00111</a> <a class="code" href="types_8h.html#a6">ipsec_status</a> <a class="code" href="esp_8c.html#a3">ipsec_esp_decapsulate</a>(<a class="code" href="structipsec__ip__hdr__struct.html">ipsec_ip_header</a> *packet, <span class="keywordtype">int</span> *offset, <span class="keywordtype">int</span> *len, <a class="code" href="structsa__entry__struct.html">sad_entry</a> *sa)
00112  {
00113         <span class="keywordtype">int</span> ret_val = <a class="code" href="types_8h.html#a38a23">IPSEC_STATUS_NOT_INITIALIZED</a>;                     <span class="comment">/* by default, the return value is undefined */</span>
00114         <a class="code" href="types_8h.html#a0">__u8</a>                            ip_header_len ;
00115         <span class="keywordtype">int</span>                                     local_len ;
00116         <span class="keywordtype">int</span>                                     payload_offset ;
00117         <span class="keywordtype">int</span>                                     payload_len ;
00118         <a class="code" href="structipsec__ip__hdr__struct.html">ipsec_ip_header</a>         *new_ip_packet ;
00119         <a class="code" href="structesp__packet__struct.html">esp_packet</a>                      *esp_header ;                   
00120         <span class="keywordtype">char</span>                            cbc_iv[<a class="code" href="esp_8h.html#a0">IPSEC_ESP_IV_SIZE</a>] ;
00121         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>           digest[<a class="code" href="ipsec_8h.html#a6">IPSEC_MAX_AUTHKEY_LEN</a>];
00122 
00123         <a class="code" href="debug_8h.html#a12">IPSEC_LOG_TRC</a>(IPSEC_TRACE_ENTER, 
00124                       <span class="stringliteral">"ipsec_esp_decapsulate"</span>, 
00125                                   (<span class="stringliteral">"packet=%p, *offset=%d, *len=%d sa=%p"</span>,
00126                               (<span class="keywordtype">void</span> *)packet, *offset, *len, (<span class="keywordtype">void</span> *)sa)
00127                                  );
00128         
00129         ip_header_len = (packet-&gt;v_hl &amp; 0x0f) * 4 ;
00130         esp_header = (<a class="code" href="structesp__packet__struct.html">esp_packet</a>*)(((<span class="keywordtype">char</span>*)packet)+ip_header_len) ; 
00131         payload_offset = ip_header_len + <a class="code" href="esp_8h.html#a1">IPSEC_ESP_SPI_SIZE</a> + <a class="code" href="esp_8h.html#a2">IPSEC_ESP_SEQ_SIZE</a> ;
00132         payload_len = <a class="code" href="util_8c.html#a5">ipsec_ntohs</a>(packet-&gt;len) - ip_header_len - <a class="code" href="esp_8h.html#a3">IPSEC_ESP_HDR_SIZE</a> ;
00133 
00134 
00135         <span class="keywordflow">if</span>(sa-&gt;<a class="code" href="structsa__entry__struct.html#o11">auth_alg</a> != 0)
00136         {
00137 
00138                 <span class="comment">/* preliminary anti-replay check (without updating the global sequence number window)     */</span>
00139                 <span class="comment">/* This check prevents useless ICV calculation if the Sequence Number is obviously wrong  */</span>
00140                 ret_val = <a class="code" href="util_8c.html#a11">ipsec_check_replay_window</a>(<a class="code" href="util_8c.html#a7">ipsec_ntohl</a>(esp_header-&gt;<a class="code" href="structesp__packet__struct.html#o1">sequence</a>), <a class="code" href="esp_8c.html#a1">ipsec_esp_lastSeq</a>, <a class="code" href="esp_8c.html#a0">ipsec_esp_bitmap</a>);
00141                 <span class="keywordflow">if</span>(ret_val != <a class="code" href="types_8h.html#a39a24">IPSEC_AUDIT_SUCCESS</a>)
00142                 {
00143                         <a class="code" href="debug_8h.html#a9">IPSEC_LOG_AUD</a>(<span class="stringliteral">"ipsec_esp_decapsulate"</span>, <a class="code" href="types_8h.html#a39a31">IPSEC_AUDIT_SEQ_MISMATCH</a>, (<span class="stringliteral">"packet rejected by anti-replay check (lastSeq=%08lx, seq=%08lx, window size=%d)"</span>, <a class="code" href="esp_8c.html#a1">ipsec_esp_lastSeq</a>, <a class="code" href="util_8c.html#a7">ipsec_ntohl</a>(esp_header-&gt;<a class="code" href="structesp__packet__struct.html#o1">sequence</a>), <a class="code" href="ipsec_8h.html#a8">IPSEC_SEQ_MAX_WINDOW</a>) );
00144                         <span class="keywordflow">return</span> ret_val;
00145                 }
00146 
00147                 <span class="comment">/* recalcualte ICV */</span>
00148                 <span class="keywordflow">switch</span>(sa-&gt;<a class="code" href="structsa__entry__struct.html#o11">auth_alg</a>) {
00149 
00150                 <span class="keywordflow">case</span> <a class="code" href="sa_8h.html#a12">IPSEC_HMAC_MD5</a>: 
00151                         <a class="code" href="md5_8c.html#a25">hmac_md5</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)esp_header, payload_len-<a class="code" href="ipsec_8h.html#a3">IPSEC_AUTH_ICV</a>+<a class="code" href="esp_8h.html#a3">IPSEC_ESP_HDR_SIZE</a>,
00152                                  (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)sa-&gt;<a class="code" href="structsa__entry__struct.html#o12">authkey</a>, <a class="code" href="ipsec_8h.html#a4">IPSEC_AUTH_MD5_KEY_LEN</a>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)&amp;digest);
00153                         ret_val = <a class="code" href="types_8h.html#a38a12">IPSEC_STATUS_SUCCESS</a>; 
00154                         <span class="keywordflow">break</span>;
00155                 <span class="keywordflow">case</span> <a class="code" href="sa_8h.html#a13">IPSEC_HMAC_SHA1</a>: 
00156                         <a class="code" href="sha1_8c.html#a36">hmac_sha1</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)esp_header, payload_len-<a class="code" href="ipsec_8h.html#a3">IPSEC_AUTH_ICV</a>+<a class="code" href="esp_8h.html#a3">IPSEC_ESP_HDR_SIZE</a>,
00157                                   (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)sa-&gt;<a class="code" href="structsa__entry__struct.html#o12">authkey</a>, <a class="code" href="ipsec_8h.html#a5">IPSEC_AUTH_SHA1_KEY_LEN</a>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)&amp;digest);
00158                         ret_val = <a class="code" href="types_8h.html#a38a12">IPSEC_STATUS_SUCCESS</a>; 
00159                         <span class="keywordflow">break</span>;
00160                 <span class="keywordflow">default</span>:
00161                         <a class="code" href="debug_8h.html#a6">IPSEC_LOG_ERR</a>(<span class="stringliteral">"ipsec_esp_decapsulate"</span>, <a class="code" href="types_8h.html#a38a14">IPSEC_STATUS_FAILURE</a>, (<span class="stringliteral">"unknown HASH algorithm for this ESP"</span>)) ;
00162                         <a class="code" href="debug_8h.html#a12">IPSEC_LOG_TRC</a>(IPSEC_TRACE_RETURN, <span class="stringliteral">"ipsec_esp_decapsulate"</span>, (<span class="stringliteral">"return = %d"</span>, <a class="code" href="types_8h.html#a38a14">IPSEC_STATUS_FAILURE</a>) );
00163                         <span class="keywordflow">return</span> <a class="code" href="types_8h.html#a38a14">IPSEC_STATUS_FAILURE</a>;
00164                 }
00165                 
00166                 <span class="comment">/* compare ICV */</span>
00167                 <span class="keywordflow">if</span>(memcmp(((<span class="keywordtype">char</span>*)esp_header)+<a class="code" href="esp_8h.html#a3">IPSEC_ESP_HDR_SIZE</a>+payload_len-<a class="code" href="ipsec_8h.html#a3">IPSEC_AUTH_ICV</a>, digest, <a class="code" href="ipsec_8h.html#a3">IPSEC_AUTH_ICV</a>) != 0) {
00168                         <a class="code" href="debug_8h.html#a6">IPSEC_LOG_ERR</a>(<span class="stringliteral">"ipsec_esp_decapsulate"</span>, <a class="code" href="types_8h.html#a38a14">IPSEC_STATUS_FAILURE</a>, (<span class="stringliteral">"ESP ICV does not match"</span>)) ;
00169                         <a class="code" href="debug_8h.html#a12">IPSEC_LOG_TRC</a>(IPSEC_TRACE_RETURN, <span class="stringliteral">"ipsec_esp_decapsulate"</span>, (<span class="stringliteral">"return = %d"</span>, <a class="code" href="types_8h.html#a38a14">IPSEC_STATUS_FAILURE</a>) );
00170                         <span class="keywordflow">return</span> <a class="code" href="types_8h.html#a38a14">IPSEC_STATUS_FAILURE</a>;
00171                 }
00172 
00173                 <span class="comment">/* reduce payload by ICV */</span>
00174                 payload_len -= <a class="code" href="ipsec_8h.html#a3">IPSEC_AUTH_ICV</a> ;
00175 
00176                 <span class="comment">/* post-ICV calculationn anti-replay check (this call will update the global sequence number window) */</span>
00177                 ret_val = <a class="code" href="util_8c.html#a12">ipsec_update_replay_window</a>(<a class="code" href="util_8c.html#a7">ipsec_ntohl</a>(esp_header-&gt;<a class="code" href="structesp__packet__struct.html#o1">sequence</a>), (<a class="code" href="types_8h.html#a4">__u32</a> *)&amp;<a class="code" href="esp_8c.html#a1">ipsec_esp_lastSeq</a>, (<a class="code" href="types_8h.html#a4">__u32</a> *)&amp;<a class="code" href="esp_8c.html#a0">ipsec_esp_bitmap</a>);
00178                 <span class="keywordflow">if</span>(ret_val != <a class="code" href="types_8h.html#a39a24">IPSEC_AUDIT_SUCCESS</a>)
00179                 {
00180                         <a class="code" href="debug_8h.html#a9">IPSEC_LOG_AUD</a>(<span class="stringliteral">"ipsec_esp_decapsulate"</span>, <a class="code" href="types_8h.html#a39a31">IPSEC_AUDIT_SEQ_MISMATCH</a>, (<span class="stringliteral">"packet rejected by anti-replay update (lastSeq=%08lx, seq=%08lx, window size=%d)"</span>, <a class="code" href="esp_8c.html#a1">ipsec_esp_lastSeq</a>, <a class="code" href="util_8c.html#a7">ipsec_ntohl</a>(esp_header-&gt;<a class="code" href="structesp__packet__struct.html#o1">sequence</a>), <a class="code" href="ipsec_8h.html#a8">IPSEC_SEQ_MAX_WINDOW</a>) );
00181                         <span class="keywordflow">return</span> ret_val;
00182                 }
00183 
00184         }
00185 
00186 
00187         <span class="comment">/* decapsulate the packet according the SA */</span>
00188         <span class="keywordflow">if</span>(sa-&gt;<a class="code" href="structsa__entry__struct.html#o9">enc_alg</a> == <a class="code" href="sa_8h.html#a10">IPSEC_3DES</a>)
00189         {
00190                 <span class="comment">/* copy IV from ESP payload */</span>
00191                 memcpy(cbc_iv, ((<span class="keywordtype">char</span>*)packet)+payload_offset, <a class="code" href="esp_8h.html#a0">IPSEC_ESP_IV_SIZE</a>);
00192 
00193                 <span class="comment">/* decrypt ESP packet */</span>
00194                 <a class="code" href="des_8c.html#a39">cipher_3des_cbc</a>(((<span class="keywordtype">char</span>*)packet)+payload_offset + <a class="code" href="esp_8h.html#a0">IPSEC_ESP_IV_SIZE</a>, payload_len-<a class="code" href="esp_8h.html#a0">IPSEC_ESP_IV_SIZE</a>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)sa-&gt;<a class="code" href="structsa__entry__struct.html#o10">enckey</a>, (<span class="keywordtype">char</span>*)&amp;cbc_iv,
00195                                                  <a class="code" href="des_8h.html#a2">DES_DECRYPT</a>, ((<span class="keywordtype">char</span>*)packet)+payload_offset + <a class="code" href="esp_8h.html#a0">IPSEC_ESP_IV_SIZE</a>);
00196         }
00197 
00198         *offset = payload_offset+<a class="code" href="esp_8h.html#a0">IPSEC_ESP_IV_SIZE</a> ;
00199 
00200         new_ip_packet = (<a class="code" href="structipsec__ip__hdr__struct.html">ipsec_ip_header</a>*)(((<span class="keywordtype">char</span>*)packet) + payload_offset + <a class="code" href="esp_8h.html#a0">IPSEC_ESP_IV_SIZE</a>) ;
00201         local_len = <a class="code" href="util_8c.html#a5">ipsec_ntohs</a>(new_ip_packet-&gt;<a class="code" href="structipsec__ip__hdr__struct.html#o2">len</a>) ;
00202 
00203         <span class="keywordflow">if</span>( (local_len &lt; IPSEC_MIN_IPHDR_SIZE) || (local_len &gt; <a class="code" href="ipsecdev_8h.html#a1">IPSEC_MTU</a>))
00204         {
00205                 <a class="code" href="debug_8h.html#a6">IPSEC_LOG_ERR</a>(<span class="stringliteral">"ipsec_esp_decapsulate"</span>, <a class="code" href="types_8h.html#a38a14">IPSEC_STATUS_FAILURE</a>, (<span class="stringliteral">"decapsulated strange packet"</span>)) ;
00206                 <a class="code" href="debug_8h.html#a12">IPSEC_LOG_TRC</a>(IPSEC_TRACE_RETURN, <span class="stringliteral">"ipsec_esp_decapsulate"</span>, (<span class="stringliteral">"return = %d"</span>, <a class="code" href="types_8h.html#a38a19">IPSEC_STATUS_BAD_PACKET</a>) );
00207                 <span class="keywordflow">return</span> <a class="code" href="types_8h.html#a38a19">IPSEC_STATUS_BAD_PACKET</a>;
00208         }
00209         *len = local_len ;
00210 
00211         sa-&gt;<a class="code" href="structsa__entry__struct.html#o5">sequence_number</a>++ ;
00212 
00213         <a class="code" href="debug_8h.html#a12">IPSEC_LOG_TRC</a>(IPSEC_TRACE_RETURN, <span class="stringliteral">"ipsec_esp_decapsulate"</span>, (<span class="stringliteral">"return = %d"</span>, <a class="code" href="types_8h.html#a38a12">IPSEC_STATUS_SUCCESS</a>) );
00214         <span class="keywordflow">return</span> <a class="code" href="types_8h.html#a38a12">IPSEC_STATUS_SUCCESS</a>;
00215  }
00216 
<a name="l00230"></a><a class="code" href="esp_8c.html#a4">00230</a>  <a class="code" href="types_8h.html#a6">ipsec_status</a> <a class="code" href="esp_8c.html#a4">ipsec_esp_encapsulate</a>(<a class="code" href="structipsec__ip__hdr__struct.html">ipsec_ip_header</a> *packet, <span class="keywordtype">int</span> *offset, <span class="keywordtype">int</span> *len, <a class="code" href="structsa__entry__struct.html">sad_entry</a> *sa, <a class="code" href="types_8h.html#a4">__u32</a> src_addr, <a class="code" href="types_8h.html#a4">__u32</a> dest_addr)
00231  {
00232         <span class="keywordtype">int</span> ret_val = <a class="code" href="types_8h.html#a38a23">IPSEC_STATUS_NOT_INITIALIZED</a>;                     <span class="comment">/* by default, the return value is undefined */</span>
00233         <a class="code" href="types_8h.html#a0">__u8</a>                            tos ;
00234         <span class="keywordtype">int</span>                                     inner_len ;
00235         <span class="keywordtype">int</span>                                     payload_offset ;
00236         <span class="keywordtype">int</span>                                     payload_len ;
00237         <a class="code" href="types_8h.html#a0">__u8</a>                            padd_len ;
00238         <a class="code" href="types_8h.html#a0">__u8</a>                            *pos ;
00239         <a class="code" href="types_8h.html#a0">__u8</a>                            padd ;
00240         <a class="code" href="structipsec__ip__hdr__struct.html">ipsec_ip_header</a>         *new_ip_header ;
00241         <a class="code" href="structipsec__esp__header__struct.html">ipsec_esp_header</a>        *new_esp_header ;
00242         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>           iv[<a class="code" href="esp_8h.html#a0">IPSEC_ESP_IV_SIZE</a>] = {0xD4, 0xDB, 0xAB, 0x9A, 0x9A, 0xDB, 0xD1, 0x94} ;
00243         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>           cbc_iv[<a class="code" href="esp_8h.html#a0">IPSEC_ESP_IV_SIZE</a>] ;
00244         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>           digest[<a class="code" href="ipsec_8h.html#a6">IPSEC_MAX_AUTHKEY_LEN</a>];
00245 
00246         <a class="code" href="debug_8h.html#a12">IPSEC_LOG_TRC</a>(IPSEC_TRACE_ENTER, 
00247                       <span class="stringliteral">"ipsec_esp_encapsulate"</span>, 
00248                                   (<span class="stringliteral">"packet=%p, *offset=%d, *len=%d, sa=%p, src_addr=%lu, dest_addr=%lu"</span>,
00249                               (<span class="keywordtype">void</span> *)packet, *offset, *len, (<span class="keywordtype">void</span> *)sa, src_addr, dest_addr)
00250                                  );
00251 
00252         <span class="comment">/* set new packet header pointers */</span>
00253         new_ip_header = (<a class="code" href="structipsec__ip__hdr__struct.html">ipsec_ip_header</a>*)(((<span class="keywordtype">char</span>*)packet) - <a class="code" href="esp_8h.html#a0">IPSEC_ESP_IV_SIZE</a> - <a class="code" href="esp_8h.html#a3">IPSEC_ESP_HDR_SIZE</a> - <a class="code" href="ipsec_8h.html#a7">IPSEC_MIN_IPHDR_SIZE</a>) ;
00254         new_esp_header = (<a class="code" href="structipsec__esp__header__struct.html">ipsec_esp_header</a>*)(((<span class="keywordtype">char</span>*)packet) - <a class="code" href="esp_8h.html#a0">IPSEC_ESP_IV_SIZE</a> - <a class="code" href="esp_8h.html#a3">IPSEC_ESP_HDR_SIZE</a>) ;
00255         payload_offset = (((<span class="keywordtype">char</span>*)packet) - ((<span class="keywordtype">char</span>*)new_ip_header)) ;
00256 
00257         inner_len = <a class="code" href="util_8c.html#a5">ipsec_ntohs</a>(packet-&gt;len) ;
00258 
00259         <span class="comment">/* save TOS from inner header */</span>
00260         tos = packet-&gt;tos ;
00261 
00263         <span class="comment">// packet-&gt;ttl--;</span>
00264         <span class="comment">// packet-&gt;chksum = ip_chksum(packet, sizeof(ip_header));</span>
00265         <span class="keywordflow">if</span> (packet-&gt;ttl == 0)
00266         {
00267                 <a class="code" href="debug_8h.html#a12">IPSEC_LOG_TRC</a>(IPSEC_TRACE_RETURN, <span class="stringliteral">"ipsec_esp_encapsulate"</span>, (<span class="stringliteral">"return = %d"</span>, <a class="code" href="types_8h.html#a38a22">IPSEC_STATUS_TTL_EXPIRED</a>) );
00268                 <span class="keywordflow">return</span> <a class="code" href="types_8h.html#a38a22">IPSEC_STATUS_TTL_EXPIRED</a>;
00269         }
00270         
00271         <span class="comment">/* add padding if needed */</span>
00272         padd_len = <a class="code" href="esp_8c.html#a2">ipsec_esp_get_padding</a>(inner_len+2) ; 
00273         pos = ((<span class="keywordtype">char</span>*)packet)+inner_len ;
00274         <span class="keywordflow">if</span>(padd_len != 0)
00275         {
00276                 padd = 1 ;
00277                 <span class="keywordflow">while</span>(padd &lt;= padd_len)
00278                         *pos++ = padd++ ;
00279         }
00280         
00281         <span class="comment">/* append padding length and next protocol field to the payload */</span>
00282         *pos++ = padd_len ;
00283         <span class="comment">/* in tunnel mode the next protocol field is always IP */</span>
00284         *pos = 0x04 ; 
00285 
00286         payload_len = inner_len+<a class="code" href="esp_8h.html#a3">IPSEC_ESP_HDR_SIZE</a>+<a class="code" href="esp_8h.html#a0">IPSEC_ESP_IV_SIZE</a> + padd_len + 2 ;
00287 
00288         <span class="comment">/* decapsulate the packet according the SA */</span>
00289         <span class="keywordflow">if</span>(sa-&gt;enc_alg == <a class="code" href="sa_8h.html#a10">IPSEC_3DES</a>)
00290         {
00291                 <span class="comment">/* get IV from SA */</span>
00292                 memcpy(cbc_iv, iv, <a class="code" href="esp_8h.html#a0">IPSEC_ESP_IV_SIZE</a>);
00293 
00294                 <span class="comment">/* encrypt ESP packet */</span>
00295                 <a class="code" href="des_8c.html#a39">cipher_3des_cbc</a>((<a class="code" href="types_8h.html#a0">__u8</a> *)packet, inner_len+padd_len+2, (<a class="code" href="types_8h.html#a0">__u8</a> *)sa-&gt;enckey, (<a class="code" href="types_8h.html#a0">__u8</a> *)&amp;cbc_iv,
00296                                                  <a class="code" href="des_8h.html#a1">DES_ENCRYPT</a>, (<a class="code" href="types_8h.html#a0">__u8</a> *)packet);
00297         }
00298 
00299         <span class="comment">/* insert IV in fron of packet */</span>
00300         memcpy( ((<span class="keywordtype">char</span>*)packet)-<a class="code" href="esp_8h.html#a0">IPSEC_ESP_IV_SIZE</a>, iv, <a class="code" href="esp_8h.html#a0">IPSEC_ESP_IV_SIZE</a>) ;
00301 
00302         <span class="comment">/* setup ESP header */</span>
00303         new_esp_header-&gt;<a class="code" href="structipsec__esp__header__struct.html#o0">spi</a> = sa-&gt;spi;
00305         sa-&gt;sequence_number++ ;
00306         new_esp_header-&gt;<a class="code" href="structipsec__esp__header__struct.html#o1">sequence_number</a> = <a class="code" href="util_8c.html#a6">ipsec_htonl</a>(sa-&gt;sequence_number) ;
00307 
00308         <span class="comment">/* calculate the ICV if needed */</span>
00309         <span class="keywordflow">if</span>(sa-&gt;auth_alg != 0)
00310         {
00311                 <span class="comment">/* recalcualte ICV */</span>
00312                 <span class="keywordflow">switch</span>(sa-&gt;auth_alg) {
00313 
00314                 <span class="keywordflow">case</span> <a class="code" href="sa_8h.html#a12">IPSEC_HMAC_MD5</a>: 
00315                         <a class="code" href="md5_8c.html#a25">hmac_md5</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)new_esp_header, payload_len,
00316                                  (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)sa-&gt;authkey, <a class="code" href="ipsec_8h.html#a4">IPSEC_AUTH_MD5_KEY_LEN</a>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)&amp;digest);
00317                         ret_val = <a class="code" href="types_8h.html#a38a12">IPSEC_STATUS_SUCCESS</a>; 
00318                         <span class="keywordflow">break</span>;
00319                 <span class="keywordflow">case</span> <a class="code" href="sa_8h.html#a13">IPSEC_HMAC_SHA1</a>: 
00320                         <a class="code" href="sha1_8c.html#a36">hmac_sha1</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)new_esp_header, payload_len,
00321                                   (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)sa-&gt;authkey, <a class="code" href="ipsec_8h.html#a5">IPSEC_AUTH_SHA1_KEY_LEN</a>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)&amp;digest);
00322                         ret_val = <a class="code" href="types_8h.html#a38a12">IPSEC_STATUS_SUCCESS</a>; 
00323                         <span class="keywordflow">break</span>;
00324                 <span class="keywordflow">default</span>:
00325                         <a class="code" href="debug_8h.html#a6">IPSEC_LOG_ERR</a>(<span class="stringliteral">"ipsec_esp_encapsulate"</span>, <a class="code" href="types_8h.html#a38a14">IPSEC_STATUS_FAILURE</a>, (<span class="stringliteral">"unknown HASH algorithm for this ESP"</span>)) ;
00326                         <a class="code" href="debug_8h.html#a12">IPSEC_LOG_TRC</a>(IPSEC_TRACE_RETURN, <span class="stringliteral">"ipsec_esp_encapsulate"</span>, (<span class="stringliteral">"return = %d"</span>, <a class="code" href="types_8h.html#a38a14">IPSEC_STATUS_FAILURE</a>) );
00327                         <span class="keywordflow">return</span> <a class="code" href="types_8h.html#a38a14">IPSEC_STATUS_FAILURE</a>;
00328                 }
00329                 
00330                 <span class="comment">/* set ICV */</span>
00331                 memcpy(((<span class="keywordtype">char</span>*)new_esp_header)+payload_len, digest, <a class="code" href="ipsec_8h.html#a3">IPSEC_AUTH_ICV</a>);
00332                 
00333                 <span class="comment">/* increase payload by ICV */</span>
00334                 payload_len += <a class="code" href="ipsec_8h.html#a3">IPSEC_AUTH_ICV</a> ;
00335         }
00336 
00337         <span class="comment">/* setup IP header */</span>
00338         new_ip_header-&gt;<a class="code" href="structipsec__ip__hdr__struct.html#o0">v_hl</a> = 0x45 ;
00339         new_ip_header-&gt;<a class="code" href="structipsec__ip__hdr__struct.html#o1">tos</a> = tos ;
00340         <span class="comment">//new_ip_header-&gt;len = ipsec_htons(inner_len+padd_len+2+IPSEC_ESP_IV_SIZE+IPSEC_ESP_HDR_SIZE+IPSEC_MIN_IPHDR_SIZE) ; /**@todo when auth enables the size changes */</span>
00341         new_ip_header-&gt;<a class="code" href="structipsec__ip__hdr__struct.html#o2">len</a> = <a class="code" href="util_8c.html#a4">ipsec_htons</a>(payload_len+ <a class="code" href="ipsec_8h.html#a7">IPSEC_MIN_IPHDR_SIZE</a>); 
00342         new_ip_header-&gt;<a class="code" href="structipsec__ip__hdr__struct.html#o3">id</a> = 1000 ;      
00343         new_ip_header-&gt;<a class="code" href="structipsec__ip__hdr__struct.html#o4">offset</a> = 0 ;
00344         new_ip_header-&gt;<a class="code" href="structipsec__ip__hdr__struct.html#o5">ttl</a> = 64 ;
00345         new_ip_header-&gt;<a class="code" href="structipsec__ip__hdr__struct.html#o6">protocol</a> = <a class="code" href="types_8h.html#a40a36">IPSEC_PROTO_ESP</a> ;
00346         new_ip_header-&gt;<a class="code" href="structipsec__ip__hdr__struct.html#o7">chksum</a> = 0 ;
00347         new_ip_header-&gt;<a class="code" href="structipsec__ip__hdr__struct.html#o8">src</a> = src_addr ;
00348         new_ip_header-&gt;<a class="code" href="structipsec__ip__hdr__struct.html#o9">dest</a> = dest_addr ;
00349 
00350         <span class="comment">/* set checksum */</span>
00351         new_ip_header-&gt;<a class="code" href="structipsec__ip__hdr__struct.html#o7">chksum</a> = <a class="code" href="util_8c.html#a9">ipsec_ip_chksum</a>(new_ip_header, <span class="keyword">sizeof</span>(<a class="code" href="structipsec__ip__hdr__struct.html">ipsec_ip_header</a>)) ;
00352 
00353         <span class="comment">/* setup return values */</span>
00354         *offset = payload_offset*(-1) ;
00355         *len = payload_len + <a class="code" href="ipsec_8h.html#a7">IPSEC_MIN_IPHDR_SIZE</a> ;
00356 
00357         <a class="code" href="debug_8h.html#a12">IPSEC_LOG_TRC</a>(IPSEC_TRACE_RETURN, <span class="stringliteral">"ipsec_esp_encapsulate"</span>, (<span class="stringliteral">"return = %d"</span>, <a class="code" href="types_8h.html#a38a12">IPSEC_STATUS_SUCCESS</a>) );
00358         <span class="keywordflow">return</span> <a class="code" href="types_8h.html#a38a12">IPSEC_STATUS_SUCCESS</a>;
00359  }
00360 
</pre></div>	</td>
  </tr>
</table>
<hr>
<div align="center">Copyright 2003 by Christian Scheurer and Niklaus Schild</div>
</html>
