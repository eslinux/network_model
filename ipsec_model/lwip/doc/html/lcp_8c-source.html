
<html>
<head>
<title>lwIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="doxygen.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<table width="98%" border="0" align="center">
  <tr>
    <td>
      <h2>lwIP code documentation</h2>
<hr>

<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>lcp.c</h1><a href="lcp_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*****************************************************************************</span>
00002 <span class="comment">* lcp.c - Network Link Control Protocol program file.</span>
00003 <span class="comment">*</span>
00004 <span class="comment">* Copyright (c) 2003 by Marc Boucher, Services Informatiques (MBSI) inc.</span>
00005 <span class="comment">* portions Copyright (c) 1997 by Global Election Systems Inc.</span>
00006 <span class="comment">*</span>
00007 <span class="comment">* The authors hereby grant permission to use, copy, modify, distribute,</span>
00008 <span class="comment">* and license this software and its documentation for any purpose, provided</span>
00009 <span class="comment">* that existing copyright notices are retained in all copies and that this</span>
00010 <span class="comment">* notice and the following disclaimer are included verbatim in any </span>
00011 <span class="comment">* distributions. No written agreement, license, or royalty fee is required</span>
00012 <span class="comment">* for any of the authorized uses.</span>
00013 <span class="comment">*</span>
00014 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS *AS IS* AND ANY EXPRESS OR</span>
00015 <span class="comment">* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
00016 <span class="comment">* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. </span>
00017 <span class="comment">* IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
00018 <span class="comment">* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
00019 <span class="comment">* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
00020 <span class="comment">* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
00021 <span class="comment">* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
00022 <span class="comment">* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
00023 <span class="comment">* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00024 <span class="comment">*</span>
00025 <span class="comment">******************************************************************************</span>
00026 <span class="comment">* REVISION HISTORY</span>
00027 <span class="comment">*</span>
00028 <span class="comment">* 03-01-01 Marc Boucher &lt;marc@mbsi.ca&gt;</span>
00029 <span class="comment">*   Ported to lwIP.</span>
00030 <span class="comment">* 97-12-01 Guy Lancaster &lt;lancasterg@acm.org&gt;, Global Election Systems Inc.</span>
00031 <span class="comment">*       Original.</span>
00032 <span class="comment">*****************************************************************************/</span>
00033 
00034 <span class="comment">/*</span>
00035 <span class="comment"> * lcp.c - PPP Link Control Protocol.</span>
00036 <span class="comment"> *</span>
00037 <span class="comment"> * Copyright (c) 1989 Carnegie Mellon University.</span>
00038 <span class="comment"> * All rights reserved.</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Redistribution and use in source and binary forms are permitted</span>
00041 <span class="comment"> * provided that the above copyright notice and this paragraph are</span>
00042 <span class="comment"> * duplicated in all such forms and that any documentation,</span>
00043 <span class="comment"> * advertising materials, and other materials related to such</span>
00044 <span class="comment"> * distribution and use acknowledge that the software was developed</span>
00045 <span class="comment"> * by Carnegie Mellon University.  The name of the</span>
00046 <span class="comment"> * University may not be used to endorse or promote products derived</span>
00047 <span class="comment"> * from this software without specific prior written permission.</span>
00048 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR</span>
00049 <span class="comment"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
00050 <span class="comment"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
00051 <span class="comment"> */</span>
00052 <span class="preprocessor">#include "<a class="code" href="ppp_8h.html">ppp.h</a>"</span>
00053 <span class="preprocessor">#if PPP_SUPPORT &gt; 0</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="fsm_8h.html">fsm.h</a>"</span>
00055 <span class="preprocessor">#include "<a class="code" href="chap_8h.html">chap.h</a>"</span>
00056 <span class="preprocessor">#include "<a class="code" href="magic_8h.html">magic.h</a>"</span>
00057 <span class="preprocessor">#include "<a class="code" href="auth_8h.html">auth.h</a>"</span>
00058 <span class="preprocessor">#include "<a class="code" href="lcp_8h.html">lcp.h</a>"</span>
00059 <span class="preprocessor">#include "<a class="code" href="pppdebug_8h.html">pppdebug.h</a>"</span>
00060 
00061 
00062 <span class="comment">/*************************/</span>
00063 <span class="comment">/*** LOCAL DEFINITIONS ***/</span>
00064 <span class="comment">/*************************/</span>
00065 <span class="comment">/*</span>
00066 <span class="comment"> * Length of each type of configuration option (in octets)</span>
00067 <span class="comment"> */</span>
00068 <span class="preprocessor">#define CILEN_VOID      2</span>
00069 <span class="preprocessor"></span><span class="preprocessor">#define CILEN_CHAR      3</span>
00070 <span class="preprocessor"></span><span class="preprocessor">#define CILEN_SHORT     4       </span><span class="comment">/* CILEN_VOID + sizeof(short) */</span>
00071 <span class="preprocessor">#define CILEN_CHAP      5       </span><span class="comment">/* CILEN_VOID + sizeof(short) + 1 */</span>
00072 <span class="preprocessor">#define CILEN_LONG      6       </span><span class="comment">/* CILEN_VOID + sizeof(long) */</span>
00073 <span class="preprocessor">#define CILEN_LQR       8       </span><span class="comment">/* CILEN_VOID + sizeof(short) + sizeof(long) */</span>
00074 <span class="preprocessor">#define CILEN_CBCP      3</span>
00075 <span class="preprocessor"></span>
00076 
00077 <span class="comment">/***********************************/</span>
00078 <span class="comment">/*** LOCAL FUNCTION DECLARATIONS ***/</span>
00079 <span class="comment">/***********************************/</span>
00080 <span class="comment">/*</span>
00081 <span class="comment"> * Callbacks for fsm code.  (CI = Configuration Information)</span>
00082 <span class="comment"> */</span>
00083 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_resetci (<a class="code" href="structfsm.html">fsm</a>*);         <span class="comment">/* Reset our CI */</span>
00084 <span class="keyword">static</span> <span class="keywordtype">int</span>  lcp_cilen (<a class="code" href="structfsm.html">fsm</a>*);                   <span class="comment">/* Return length of our CI */</span>
00085 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_addci (<a class="code" href="structfsm.html">fsm</a>*, u_char*, <span class="keywordtype">int</span>*);       <span class="comment">/* Add our CI to pkt */</span>
00086 <span class="keyword">static</span> <span class="keywordtype">int</span>  lcp_ackci (<a class="code" href="structfsm.html">fsm</a>*, u_char*, <span class="keywordtype">int</span>);<span class="comment">/* Peer ack'd our CI */</span>
00087 <span class="keyword">static</span> <span class="keywordtype">int</span>  lcp_nakci (<a class="code" href="structfsm.html">fsm</a>*, u_char*, <span class="keywordtype">int</span>);<span class="comment">/* Peer nak'd our CI */</span>
00088 <span class="keyword">static</span> <span class="keywordtype">int</span>  lcp_rejci (<a class="code" href="structfsm.html">fsm</a>*, u_char*, <span class="keywordtype">int</span>);<span class="comment">/* Peer rej'd our CI */</span>
00089 <span class="keyword">static</span> <span class="keywordtype">int</span>  lcp_reqci (<a class="code" href="structfsm.html">fsm</a>*, u_char*, <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>);  <span class="comment">/* Rcv peer CI */</span>
00090 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_up (<a class="code" href="structfsm.html">fsm</a>*);                          <span class="comment">/* We're UP */</span>
00091 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_down (<a class="code" href="structfsm.html">fsm</a>*);                <span class="comment">/* We're DOWN */</span>
00092 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_starting (<a class="code" href="structfsm.html">fsm</a>*);            <span class="comment">/* We need lower layer up */</span>
00093 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_finished (<a class="code" href="structfsm.html">fsm</a>*);                <span class="comment">/* We need lower layer down */</span>
00094 <span class="keyword">static</span> <span class="keywordtype">int</span>  lcp_extcode (<a class="code" href="structfsm.html">fsm</a>*, <span class="keywordtype">int</span>, u_char, u_char*, <span class="keywordtype">int</span>);
00095 
00096 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_rprotrej (<a class="code" href="structfsm.html">fsm</a>*, u_char*, <span class="keywordtype">int</span>);
00097 
00098 <span class="comment">/*</span>
00099 <span class="comment"> * routines to send LCP echos to peer</span>
00100 <span class="comment"> */</span>
00101 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_echo_lowerup (<span class="keywordtype">int</span>);
00102 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_echo_lowerdown (<span class="keywordtype">int</span>);
00103 <span class="keyword">static</span> <span class="keywordtype">void</span> LcpEchoTimeout (<span class="keywordtype">void</span>*);
00104 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_received_echo_reply (<a class="code" href="structfsm.html">fsm</a>*, <span class="keywordtype">int</span>, u_char*, <span class="keywordtype">int</span>);
00105 <span class="keyword">static</span> <span class="keywordtype">void</span> LcpSendEchoRequest (<a class="code" href="structfsm.html">fsm</a>*);
00106 <span class="keyword">static</span> <span class="keywordtype">void</span> LcpLinkFailure (<a class="code" href="structfsm.html">fsm</a>*);
00107 <span class="keyword">static</span> <span class="keywordtype">void</span> LcpEchoCheck (<a class="code" href="structfsm.html">fsm</a>*);
00108 
00109 <span class="comment">/*</span>
00110 <span class="comment"> * Protocol entry points.</span>
00111 <span class="comment"> * Some of these are called directly.</span>
00112 <span class="comment"> */</span>
00113 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_input (<span class="keywordtype">int</span>, u_char *, <span class="keywordtype">int</span>);
00114 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_protrej (<span class="keywordtype">int</span>);
00115 
00116 <span class="preprocessor">#define CODENAME(x)     ((x) == CONFACK ? "ACK" : \</span>
00117 <span class="preprocessor">                         (x) == CONFNAK ? "NAK" : "REJ")</span>
00118 <span class="preprocessor"></span>
00119 
00120 <span class="comment">/******************************/</span>
00121 <span class="comment">/*** PUBLIC DATA STRUCTURES ***/</span>
00122 <span class="comment">/******************************/</span>
00123 <span class="comment">/* global vars */</span>
00124 <a class="code" href="lcp_8h.html#a38">LinkPhase</a> <a class="code" href="lcp_8h.html#a18">lcp_phase</a>[NUM_PPP];                   <span class="comment">/* Phase of link session (RFC 1661) */</span>
00125 <a class="code" href="structlcp__options.html">lcp_options</a> <a class="code" href="lcp_8h.html#a19">lcp_wantoptions</a>[NUM_PPP];   <span class="comment">/* Options that we want to request */</span>
00126 <a class="code" href="structlcp__options.html">lcp_options</a> <a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[NUM_PPP];    <span class="comment">/* Options that peer ack'd */</span>
00127 <a class="code" href="structlcp__options.html">lcp_options</a> <a class="code" href="lcp_8h.html#a21">lcp_allowoptions</a>[NUM_PPP];  <span class="comment">/* Options we allow peer to request */</span>
00128 <a class="code" href="structlcp__options.html">lcp_options</a> <a class="code" href="lcp_8h.html#a22">lcp_hisoptions</a>[NUM_PPP];    <span class="comment">/* Options that we ack'd */</span>
00129 ext_accm <a class="code" href="lcp_8h.html#a23">xmit_accm</a>[NUM_PPP];                    <span class="comment">/* extended transmit ACCM */</span>
00130 
00131 
00132 
00133 <span class="comment">/*****************************/</span>
00134 <span class="comment">/*** LOCAL DATA STRUCTURES ***/</span>
00135 <span class="comment">/*****************************/</span>
00136 <span class="keyword">static</span> <a class="code" href="structfsm.html">fsm</a> lcp_fsm[NUM_PPP];                    <span class="comment">/* LCP fsm structure (global)*/</span>
00137 <span class="keyword">static</span> u_int     lcp_echo_interval = LCP_ECHOINTERVAL; <span class="comment">/* Interval between LCP echo-requests */</span>
00138 <span class="keyword">static</span> u_int     lcp_echo_fails = LCP_MAXECHOFAILS; <span class="comment">/* Tolerance to unanswered echo-requests */</span>
00139 <span class="keyword">static</span> u32_t lcp_echos_pending = 0;     <span class="comment">/* Number of outstanding echo msgs */</span>
00140 <span class="keyword">static</span> u32_t lcp_echo_number   = 0;     <span class="comment">/* ID number of next echo frame */</span>
00141 <span class="keyword">static</span> u32_t lcp_echo_timer_running = 0;  <span class="comment">/* TRUE if a timer is running */</span>
00142 
00143 <span class="keyword">static</span> u_char nak_buffer[PPP_MRU];      <span class="comment">/* where we construct a nak packet */</span>
00144 
00145 <span class="keyword">static</span> <a class="code" href="structfsm__callbacks.html">fsm_callbacks</a> lcp_callbacks = {  <span class="comment">/* LCP callback routines */</span>
00146     lcp_resetci,                <span class="comment">/* Reset our Configuration Information */</span>
00147     lcp_cilen,                  <span class="comment">/* Length of our Configuration Information */</span>
00148     lcp_addci,                  <span class="comment">/* Add our Configuration Information */</span>
00149     lcp_ackci,                  <span class="comment">/* ACK our Configuration Information */</span>
00150     lcp_nakci,                  <span class="comment">/* NAK our Configuration Information */</span>
00151     lcp_rejci,                  <span class="comment">/* Reject our Configuration Information */</span>
00152     lcp_reqci,                  <span class="comment">/* Request peer's Configuration Information */</span>
00153     lcp_up,                             <span class="comment">/* Called when fsm reaches OPENED state */</span>
00154     lcp_down,                   <span class="comment">/* Called when fsm leaves OPENED state */</span>
00155     lcp_starting,               <span class="comment">/* Called when we want the lower layer up */</span>
00156     lcp_finished,               <span class="comment">/* Called when we want the lower layer down */</span>
00157     <a class="code" href="def_8h.html#a2">NULL</a>,                               <span class="comment">/* Called when Protocol-Reject received */</span>
00158     <a class="code" href="def_8h.html#a2">NULL</a>,                               <span class="comment">/* Retransmission is necessary */</span>
00159     lcp_extcode,                <span class="comment">/* Called to handle LCP-specific codes */</span>
00160     <span class="stringliteral">"LCP"</span>                               <span class="comment">/* String name of protocol */</span>
00161 };
00162 
00163 <span class="keyword">struct </span>protent <a class="code" href="lcp_8h.html#a24">lcp_protent</a> = {
00164     PPP_LCP,
00165     <a class="code" href="lcp_8h.html#a32">lcp_init</a>,
00166     lcp_input,
00167     lcp_protrej,
00168     <a class="code" href="lcp_8h.html#a35">lcp_lowerup</a>,
00169     <a class="code" href="lcp_8h.html#a36">lcp_lowerdown</a>,
00170     <a class="code" href="lcp_8h.html#a33">lcp_open</a>,
00171     <a class="code" href="lcp_8h.html#a34">lcp_close</a>,
00172 <span class="preprocessor">#if 0</span>
00173 <span class="preprocessor"></span>    lcp_printpkt,
00174     <a class="code" href="def_8h.html#a2">NULL</a>,
00175 <span class="preprocessor">#endif</span>
00176 <span class="preprocessor"></span>    1,
00177     <span class="stringliteral">"LCP"</span>,
00178 <span class="preprocessor">#if 0</span>
00179 <span class="preprocessor"></span>    <a class="code" href="def_8h.html#a2">NULL</a>,
00180     <a class="code" href="def_8h.html#a2">NULL</a>,
00181     <a class="code" href="def_8h.html#a2">NULL</a>
00182 <span class="preprocessor">#endif</span>
00183 <span class="preprocessor"></span>};
00184 
00185 <span class="keywordtype">int</span> lcp_loopbackfail = <a class="code" href="lcp_8h.html#a16">DEFLOOPBACKFAIL</a>;
00186 
00187 
00188 
00189 <span class="comment">/***********************************/</span>
00190 <span class="comment">/*** PUBLIC FUNCTION DEFINITIONS ***/</span>
00191 <span class="comment">/***********************************/</span>
00192 <span class="comment">/*</span>
00193 <span class="comment"> * lcp_init - Initialize LCP.</span>
00194 <span class="comment"> */</span>
00195 <span class="keywordtype">void</span> <a class="code" href="lcp_8h.html#a32">lcp_init</a>(<span class="keywordtype">int</span> unit)
00196 {
00197         <a class="code" href="structfsm.html">fsm</a> *f = &amp;lcp_fsm[unit];
00198         <a class="code" href="structlcp__options.html">lcp_options</a> *wo = &amp;<a class="code" href="lcp_8h.html#a19">lcp_wantoptions</a>[unit];
00199         <a class="code" href="structlcp__options.html">lcp_options</a> *ao = &amp;<a class="code" href="lcp_8h.html#a21">lcp_allowoptions</a>[unit];
00200         
00201         f-&gt;<a class="code" href="structfsm.html#o0">unit</a> = unit;
00202         f-&gt;<a class="code" href="structfsm.html#o1">protocol</a> = PPP_LCP;
00203         f-&gt;<a class="code" href="structfsm.html#o13">callbacks</a> = &amp;lcp_callbacks;
00204         
00205         <a class="code" href="fsm_8h.html#a24">fsm_init</a>(f);
00206         
00207         wo-&gt;<a class="code" href="structlcp__options.html#o0">passive</a> = 0;
00208         wo-&gt;<a class="code" href="structlcp__options.html#o1">silent</a> = 0;
00209         wo-&gt;<a class="code" href="structlcp__options.html#o2">restart</a> = 0;                        <span class="comment">/* Set to 1 in kernels or multi-line</span>
00210 <span class="comment">                                                                 * implementations */</span>
00211         wo-&gt;<a class="code" href="structlcp__options.html#o3">neg_mru</a> = 1;
00212         wo-&gt;<a class="code" href="structlcp__options.html#o12">mru</a> = PPP_DEFMRU;
00213         wo-&gt;<a class="code" href="structlcp__options.html#o4">neg_asyncmap</a> = 1;
00214         wo-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a> = 0x00000000l;     <span class="comment">/* Assume don't need to escape any ctl chars. */</span>
00215         wo-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a> = 0;                       <span class="comment">/* Set to 1 on server */</span>
00216         wo-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a> = 0;                       <span class="comment">/* Set to 1 on server */</span>
00217         wo-&gt;<a class="code" href="structlcp__options.html#o13">chap_mdtype</a> = <a class="code" href="chap_8h.html#a1">CHAP_DIGEST_MD5</a>;
00218         wo-&gt;<a class="code" href="structlcp__options.html#o7">neg_magicnumber</a> = 1;
00219         wo-&gt;<a class="code" href="structlcp__options.html#o8">neg_pcompression</a> = 1;
00220         wo-&gt;<a class="code" href="structlcp__options.html#o9">neg_accompression</a> = 1;
00221         wo-&gt;<a class="code" href="structlcp__options.html#o10">neg_lqr</a> = 0;                        <span class="comment">/* no LQR implementation yet */</span>
00222         wo-&gt;<a class="code" href="structlcp__options.html#o11">neg_cbcp</a> = 0;
00223         
00224         ao-&gt;<a class="code" href="structlcp__options.html#o3">neg_mru</a> = 1;
00225         ao-&gt;<a class="code" href="structlcp__options.html#o12">mru</a> = PPP_MAXMRU;
00226         ao-&gt;<a class="code" href="structlcp__options.html#o4">neg_asyncmap</a> = 1;
00227         ao-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a> = 0x00000000l;     <span class="comment">/* Assume don't need to escape any ctl chars. */</span>
00228         ao-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a> = (CHAP_SUPPORT != 0);
00229         ao-&gt;<a class="code" href="structlcp__options.html#o13">chap_mdtype</a> = <a class="code" href="chap_8h.html#a1">CHAP_DIGEST_MD5</a>;
00230         ao-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a> = (PAP_SUPPORT != 0);
00231         ao-&gt;<a class="code" href="structlcp__options.html#o7">neg_magicnumber</a> = 1;
00232         ao-&gt;<a class="code" href="structlcp__options.html#o8">neg_pcompression</a> = 1;
00233         ao-&gt;<a class="code" href="structlcp__options.html#o9">neg_accompression</a> = 1;
00234         ao-&gt;<a class="code" href="structlcp__options.html#o10">neg_lqr</a> = 0;                        <span class="comment">/* no LQR implementation yet */</span>
00235         ao-&gt;<a class="code" href="structlcp__options.html#o11">neg_cbcp</a> = (CBCP_SUPPORT != 0);
00236 
00237         <span class="comment">/* </span>
00238 <span class="comment">         * Set transmit escape for the flag and escape characters plus anything</span>
00239 <span class="comment">         * set for the allowable options.</span>
00240 <span class="comment">         */</span>
00241         memset(xmit_accm[unit], 0, <span class="keyword">sizeof</span>(xmit_accm[0]));
00242         <a class="code" href="lcp_8h.html#a23">xmit_accm</a>[unit][15] = 0x60;
00243         <a class="code" href="lcp_8h.html#a23">xmit_accm</a>[unit][0] = (u_char)(ao-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a> &amp; 0xFF);
00244         <a class="code" href="lcp_8h.html#a23">xmit_accm</a>[unit][1] = (u_char)((ao-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a> &gt;&gt; 8) &amp; 0xFF);
00245         <a class="code" href="lcp_8h.html#a23">xmit_accm</a>[unit][2] = (u_char)((ao-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a> &gt;&gt; 16) &amp; 0xFF);
00246         <a class="code" href="lcp_8h.html#a23">xmit_accm</a>[unit][3] = (u_char)((ao-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a> &gt;&gt; 24) &amp; 0xFF);
00247         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"lcp_init: xmit_accm=%X %X %X %X\n"</span>,
00248                                 xmit_accm[unit][0],
00249                                 xmit_accm[unit][1],
00250                                 xmit_accm[unit][2],
00251                                 xmit_accm[unit][3]));
00252         
00253         <a class="code" href="lcp_8h.html#a18">lcp_phase</a>[unit] = <a class="code" href="lcp_8h.html#a38a26">PHASE_INITIALIZE</a>;
00254 }
00255 
00256 
00257 <span class="comment">/*</span>
00258 <span class="comment"> * lcp_open - LCP is allowed to come up.</span>
00259 <span class="comment"> */</span>
00260 <span class="keywordtype">void</span> <a class="code" href="lcp_8h.html#a33">lcp_open</a>(<span class="keywordtype">int</span> unit)
00261 {
00262         <a class="code" href="structfsm.html">fsm</a> *f = &amp;lcp_fsm[unit];
00263         <a class="code" href="structlcp__options.html">lcp_options</a> *wo = &amp;<a class="code" href="lcp_8h.html#a19">lcp_wantoptions</a>[unit];
00264         
00265         f-&gt;<a class="code" href="structfsm.html#o3">flags</a> = 0;
00266         <span class="keywordflow">if</span> (wo-&gt;<a class="code" href="structlcp__options.html#o0">passive</a>)
00267                 f-&gt;<a class="code" href="structfsm.html#o3">flags</a> |= <a class="code" href="fsm_8h.html#a18">OPT_PASSIVE</a>;
00268         <span class="keywordflow">if</span> (wo-&gt;<a class="code" href="structlcp__options.html#o1">silent</a>)
00269                 f-&gt;<a class="code" href="structfsm.html#o3">flags</a> |= <a class="code" href="fsm_8h.html#a20">OPT_SILENT</a>;
00270         <a class="code" href="fsm_8h.html#a27">fsm_open</a>(f);
00271         
00272         <a class="code" href="lcp_8h.html#a18">lcp_phase</a>[unit] = <a class="code" href="lcp_8h.html#a38a27">PHASE_ESTABLISH</a>; 
00273 }
00274 
00275 
00276 <span class="comment">/*</span>
00277 <span class="comment"> * lcp_close - Take LCP down.</span>
00278 <span class="comment"> */</span>
00279 <span class="keywordtype">void</span> <a class="code" href="lcp_8h.html#a34">lcp_close</a>(<span class="keywordtype">int</span> unit, <span class="keywordtype">char</span> *reason)
00280 {
00281         <a class="code" href="structfsm.html">fsm</a> *f = &amp;lcp_fsm[unit];
00282         
00283         <span class="keywordflow">if</span> (<a class="code" href="lcp_8h.html#a18">lcp_phase</a>[unit] != <a class="code" href="lcp_8h.html#a38a25">PHASE_DEAD</a>)
00284                 <a class="code" href="lcp_8h.html#a18">lcp_phase</a>[unit] = <a class="code" href="lcp_8h.html#a38a31">PHASE_TERMINATE</a>;
00285         <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structfsm.html#o2">state</a> == <a class="code" href="fsm_8h.html#a11">STOPPED</a> &amp;&amp; f-&gt;<a class="code" href="structfsm.html#o3">flags</a> &amp; (<a class="code" href="fsm_8h.html#a18">OPT_PASSIVE</a>|<a class="code" href="fsm_8h.html#a20">OPT_SILENT</a>)) {
00286                 <span class="comment">/*</span>
00287 <span class="comment">                 * This action is not strictly according to the FSM in RFC1548,</span>
00288 <span class="comment">                 * but it does mean that the program terminates if you do an</span>
00289 <span class="comment">                 * lcp_close() in passive/silent mode when a connection hasn't</span>
00290 <span class="comment">                 * been established.</span>
00291 <span class="comment">                 */</span>
00292                 f-&gt;<a class="code" href="structfsm.html#o2">state</a> = <a class="code" href="fsm_8h.html#a10">CLOSED</a>;
00293                 lcp_finished(f);
00294         }
00295         <span class="keywordflow">else</span>
00296                 <a class="code" href="fsm_8h.html#a28">fsm_close</a>(&amp;lcp_fsm[unit], reason);
00297 }
00298 
00299 
00300 <span class="comment">/*</span>
00301 <span class="comment"> * lcp_lowerup - The lower layer is up.</span>
00302 <span class="comment"> */</span>
00303 <span class="keywordtype">void</span> <a class="code" href="lcp_8h.html#a35">lcp_lowerup</a>(<span class="keywordtype">int</span> unit)
00304 {
00305         <a class="code" href="structlcp__options.html">lcp_options</a> *wo = &amp;<a class="code" href="lcp_8h.html#a19">lcp_wantoptions</a>[unit];
00306         
00307         <span class="comment">/*</span>
00308 <span class="comment">        * Don't use A/C or protocol compression on transmission,</span>
00309 <span class="comment">        * but accept A/C and protocol compressed packets</span>
00310 <span class="comment">        * if we are going to ask for A/C and protocol compression.</span>
00311 <span class="comment">        */</span>
00312         ppp_set_xaccm(unit, &amp;xmit_accm[unit]);
00313         ppp_send_config(unit, PPP_MRU, 0xffffffffl, 0, 0);
00314         ppp_recv_config(unit, PPP_MRU, 0x00000000l,
00315                                         wo-&gt;<a class="code" href="structlcp__options.html#o8">neg_pcompression</a>, wo-&gt;<a class="code" href="structlcp__options.html#o9">neg_accompression</a>);
00316         <a class="code" href="fsm_8h.html#a23">peer_mru</a>[unit] = PPP_MRU;
00317         <a class="code" href="lcp_8h.html#a21">lcp_allowoptions</a>[unit].<a class="code" href="structlcp__options.html#o14">asyncmap</a> 
00318                 = (u_long)<a class="code" href="lcp_8h.html#a23">xmit_accm</a>[unit][0]
00319                         | ((u_long)<a class="code" href="lcp_8h.html#a23">xmit_accm</a>[unit][1] &lt;&lt; 8)
00320                         | ((u_long)<a class="code" href="lcp_8h.html#a23">xmit_accm</a>[unit][2] &lt;&lt; 16)
00321                         | ((u_long)<a class="code" href="lcp_8h.html#a23">xmit_accm</a>[unit][3] &lt;&lt; 24);
00322         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"lcp_lowerup: asyncmap=%X %X %X %X\n"</span>,
00323                                 xmit_accm[unit][3],
00324                                 xmit_accm[unit][2],
00325                                 xmit_accm[unit][1],
00326                                 xmit_accm[unit][0]));
00327         
00328         <a class="code" href="fsm_8h.html#a25">fsm_lowerup</a>(&amp;lcp_fsm[unit]);
00329 }
00330 
00331 
00332 <span class="comment">/*</span>
00333 <span class="comment"> * lcp_lowerdown - The lower layer is down.</span>
00334 <span class="comment"> */</span>
00335 <span class="keywordtype">void</span> <a class="code" href="lcp_8h.html#a36">lcp_lowerdown</a>(<span class="keywordtype">int</span> unit)
00336 {
00337         <a class="code" href="fsm_8h.html#a26">fsm_lowerdown</a>(&amp;lcp_fsm[unit]);
00338 }
00339 
00340 <span class="comment">/*</span>
00341 <span class="comment"> * lcp_sprotrej - Send a Protocol-Reject for some protocol.</span>
00342 <span class="comment"> */</span>
00343 <span class="keywordtype">void</span> <a class="code" href="lcp_8h.html#a37">lcp_sprotrej</a>(<span class="keywordtype">int</span> unit, u_char *p, <span class="keywordtype">int</span> len)
00344 {
00345         <span class="comment">/*</span>
00346 <span class="comment">        * Send back the protocol and the information field of the</span>
00347 <span class="comment">        * rejected packet.  We only get here if LCP is in the OPENED state.</span>
00348 <span class="comment">        */</span>
00349 
00350         <a class="code" href="fsm_8h.html#a31">fsm_sdata</a>(&amp;lcp_fsm[unit], PROTREJ, ++lcp_fsm[unit].id,
00351                                 p, len);
00352 }
00353 
00354 
00355 
00356 <span class="comment">/**********************************/</span>
00357 <span class="comment">/*** LOCAL FUNCTION DEFINITIONS ***/</span>
00358 <span class="comment">/**********************************/</span>
00359 <span class="comment">/*</span>
00360 <span class="comment"> * lcp_input - Input LCP packet.</span>
00361 <span class="comment"> */</span>
00362 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_input(<span class="keywordtype">int</span> unit, u_char *p, <span class="keywordtype">int</span> len)
00363 {
00364         <a class="code" href="structfsm.html">fsm</a> *f = &amp;lcp_fsm[unit];
00365         
00366         <a class="code" href="fsm_8h.html#a29">fsm_input</a>(f, p, len);
00367 }
00368 
00369 
00370 <span class="comment">/*</span>
00371 <span class="comment"> * lcp_extcode - Handle a LCP-specific code.</span>
00372 <span class="comment"> */</span>
00373 <span class="keyword">static</span> <span class="keywordtype">int</span> lcp_extcode(<a class="code" href="structfsm.html">fsm</a> *f, <span class="keywordtype">int</span> code, u_char id, u_char *inp, <span class="keywordtype">int</span> len)
00374 {
00375         u_char *magp;
00376         
00377         <span class="keywordflow">switch</span>( code ){
00378         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a11">PROTREJ</a>:
00379                 lcp_rprotrej(f, inp, len);
00380                 <span class="keywordflow">break</span>;
00381         
00382         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a12">ECHOREQ</a>:
00383                 <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structfsm.html#o2">state</a> != <a class="code" href="fsm_8h.html#a17">OPENED</a>)
00384                         <span class="keywordflow">break</span>;
00385                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"lcp: Echo-Request, Rcvd id %d\n"</span>, id));
00386                 magp = inp;
00387                 PUTLONG(lcp_gotoptions[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>].magicnumber, magp);
00388                 <a class="code" href="fsm_8h.html#a31">fsm_sdata</a>(f, ECHOREP, id, inp, len);
00389                 <span class="keywordflow">break</span>;
00390         
00391         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a13">ECHOREP</a>:
00392                 lcp_received_echo_reply(f, id, inp, len);
00393                 <span class="keywordflow">break</span>;
00394         
00395         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a14">DISCREQ</a>:
00396                 <span class="keywordflow">break</span>;
00397         
00398         <span class="keywordflow">default</span>:
00399                 <span class="keywordflow">return</span> 0;
00400         }
00401         <span class="keywordflow">return</span> 1;
00402 }
00403 
00404     
00405 <span class="comment">/*</span>
00406 <span class="comment"> * lcp_rprotrej - Receive an Protocol-Reject.</span>
00407 <span class="comment"> *</span>
00408 <span class="comment"> * Figure out which protocol is rejected and inform it.</span>
00409 <span class="comment"> */</span>
00410 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_rprotrej(<a class="code" href="structfsm.html">fsm</a> *f, u_char *inp, <span class="keywordtype">int</span> len)
00411 {
00412         <span class="keywordtype">int</span> i;
00413         <span class="keyword">struct </span>protent *protp;
00414         u_short prot;
00415         
00416         <span class="keywordflow">if</span> (len &lt; <span class="keyword">sizeof</span> (u_short)) {
00417                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO,
00418                                 <span class="stringliteral">"lcp_rprotrej: Rcvd short Protocol-Reject packet!\n"</span>));
00419                 <span class="keywordflow">return</span>;
00420         }
00421         
00422         GETSHORT(prot, inp);
00423         
00424         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO,
00425                         <span class="stringliteral">"lcp_rprotrej: Rcvd Protocol-Reject packet for %x!\n"</span>,
00426                         prot));
00427         
00428         <span class="comment">/*</span>
00429 <span class="comment">        * Protocol-Reject packets received in any state other than the LCP</span>
00430 <span class="comment">        * OPENED state SHOULD be silently discarded.</span>
00431 <span class="comment">        */</span>
00432         <span class="keywordflow">if</span>( f-&gt;<a class="code" href="structfsm.html#o2">state</a> != <a class="code" href="fsm_8h.html#a17">OPENED</a> ){
00433                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"Protocol-Reject discarded: LCP in state %d\n"</span>,
00434                                 f-&gt;<a class="code" href="structfsm.html#o2">state</a>));
00435                 <span class="keywordflow">return</span>;
00436         }
00437         
00438         <span class="comment">/*</span>
00439 <span class="comment">        * Upcall the proper Protocol-Reject routine.</span>
00440 <span class="comment">        */</span>
00441         <span class="keywordflow">for</span> (i = 0; (protp = ppp_protocols[i]) != <a class="code" href="def_8h.html#a2">NULL</a>; ++i)
00442                 <span class="keywordflow">if</span> (protp-&gt;protocol == prot &amp;&amp; protp-&gt;enabled_flag) {
00443                         (*protp-&gt;protrej)(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>);
00444                         <span class="keywordflow">return</span>;
00445                 }
00446         
00447         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"Protocol-Reject for unsupported protocol 0x%x\n"</span>,
00448                         prot));
00449 }
00450 
00451 
00452 <span class="comment">/*</span>
00453 <span class="comment"> * lcp_protrej - A Protocol-Reject was received.</span>
00454 <span class="comment"> */</span>
00455 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_protrej(<span class="keywordtype">int</span> unit)
00456 {
00457         (<span class="keywordtype">void</span>)unit;
00458         <span class="comment">/*</span>
00459 <span class="comment">        * Can't reject LCP!</span>
00460 <span class="comment">        */</span>
00461         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING,
00462                         <span class="stringliteral">"lcp_protrej: Received Protocol-Reject for LCP!\n"</span>));
00463         <a class="code" href="fsm_8h.html#a30">fsm_protreject</a>(&amp;lcp_fsm[unit]);
00464 }
00465 
00466 
00467 <span class="comment">/*</span>
00468 <span class="comment"> * lcp_resetci - Reset our CI.</span>
00469 <span class="comment"> */</span>
00470 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_resetci(<a class="code" href="structfsm.html">fsm</a> *f)
00471 {
00472         <a class="code" href="lcp_8h.html#a19">lcp_wantoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>].magicnumber = <a class="code" href="magic_8c.html#a1">magic</a>();
00473         <a class="code" href="lcp_8h.html#a19">lcp_wantoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>].numloops = 0;
00474         <a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>] = <a class="code" href="lcp_8h.html#a19">lcp_wantoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00475         <a class="code" href="fsm_8h.html#a23">peer_mru</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>] = PPP_MRU;
00476         <a class="code" href="auth_8h.html#a12">auth_reset</a>(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>);
00477 }
00478 
00479 
00480 <span class="comment">/*</span>
00481 <span class="comment"> * lcp_cilen - Return length of our CI.</span>
00482 <span class="comment"> */</span>
00483 <span class="keyword">static</span> <span class="keywordtype">int</span> lcp_cilen(<a class="code" href="structfsm.html">fsm</a> *f)
00484 {
00485         <a class="code" href="structlcp__options.html">lcp_options</a> *go = &amp;<a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00486 
00487 <span class="preprocessor">#define LENCIVOID(neg)  ((neg) ? CILEN_VOID : 0)</span>
00488 <span class="preprocessor"></span><span class="preprocessor">#define LENCICHAP(neg)  ((neg) ? CILEN_CHAP : 0)</span>
00489 <span class="preprocessor"></span><span class="preprocessor">#define LENCISHORT(neg) ((neg) ? CILEN_SHORT : 0)</span>
00490 <span class="preprocessor"></span><span class="preprocessor">#define LENCILONG(neg)  ((neg) ? CILEN_LONG : 0)</span>
00491 <span class="preprocessor"></span><span class="preprocessor">#define LENCILQR(neg)   ((neg) ? CILEN_LQR: 0)</span>
00492 <span class="preprocessor"></span><span class="preprocessor">#define LENCICBCP(neg)  ((neg) ? CILEN_CBCP: 0)</span>
00493 <span class="preprocessor"></span>        <span class="comment">/*</span>
00494 <span class="comment">        * NB: we only ask for one of CHAP and UPAP, even if we will</span>
00495 <span class="comment">        * accept either.</span>
00496 <span class="comment">        */</span>
00497         <span class="keywordflow">return</span> (LENCISHORT(go-&gt;<a class="code" href="structlcp__options.html#o3">neg_mru</a> &amp;&amp; go-&gt;<a class="code" href="structlcp__options.html#o12">mru</a> != PPP_DEFMRU) +
00498                 LENCILONG(go-&gt;<a class="code" href="structlcp__options.html#o4">neg_asyncmap</a> &amp;&amp; go-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a> != 0xFFFFFFFFl) +
00499                 LENCICHAP(go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>) +
00500                 LENCISHORT(!go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a> &amp;&amp; go-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a>) +
00501                 LENCILQR(go-&gt;<a class="code" href="structlcp__options.html#o10">neg_lqr</a>) +
00502                 LENCICBCP(go-&gt;<a class="code" href="structlcp__options.html#o11">neg_cbcp</a>) +
00503                 LENCILONG(go-&gt;<a class="code" href="structlcp__options.html#o7">neg_magicnumber</a>) +
00504                 LENCIVOID(go-&gt;<a class="code" href="structlcp__options.html#o8">neg_pcompression</a>) +
00505                 LENCIVOID(go-&gt;<a class="code" href="structlcp__options.html#o9">neg_accompression</a>));
00506 }
00507 
00508 
00509 <span class="comment">/*</span>
00510 <span class="comment"> * lcp_addci - Add our desired CIs to a packet.</span>
00511 <span class="comment"> */</span>
00512 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_addci(<a class="code" href="structfsm.html">fsm</a> *f, u_char *ucp, <span class="keywordtype">int</span> *lenp)
00513 {
00514         <a class="code" href="structlcp__options.html">lcp_options</a> *go = &amp;<a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00515         u_char *start_ucp = ucp;
00516         
00517 <span class="preprocessor">#define ADDCIVOID(opt, neg) \</span>
00518 <span class="preprocessor">        if (neg) { \</span>
00519 <span class="preprocessor">            LCPDEBUG((LOG_INFO, "lcp_addci: opt=%d\n", opt)); \</span>
00520 <span class="preprocessor">                PUTCHAR(opt, ucp); \</span>
00521 <span class="preprocessor">                PUTCHAR(CILEN_VOID, ucp); \</span>
00522 <span class="preprocessor">        }</span>
00523 <span class="preprocessor"></span><span class="preprocessor">#define ADDCISHORT(opt, neg, val) \</span>
00524 <span class="preprocessor">        if (neg) { \</span>
00525 <span class="preprocessor">            LCPDEBUG((LOG_INFO, "lcp_addci: INT opt=%d %X\n", opt, val)); \</span>
00526 <span class="preprocessor">                PUTCHAR(opt, ucp); \</span>
00527 <span class="preprocessor">                PUTCHAR(CILEN_SHORT, ucp); \</span>
00528 <span class="preprocessor">                PUTSHORT(val, ucp); \</span>
00529 <span class="preprocessor">        }</span>
00530 <span class="preprocessor"></span><span class="preprocessor">#define ADDCICHAP(opt, neg, val, digest) \</span>
00531 <span class="preprocessor">        if (neg) { \</span>
00532 <span class="preprocessor">            LCPDEBUG((LOG_INFO, "lcp_addci: CHAP opt=%d %X\n", opt, val)); \</span>
00533 <span class="preprocessor">                PUTCHAR(opt, ucp); \</span>
00534 <span class="preprocessor">                PUTCHAR(CILEN_CHAP, ucp); \</span>
00535 <span class="preprocessor">                PUTSHORT(val, ucp); \</span>
00536 <span class="preprocessor">                PUTCHAR(digest, ucp); \</span>
00537 <span class="preprocessor">        }</span>
00538 <span class="preprocessor"></span><span class="preprocessor">#define ADDCILONG(opt, neg, val) \</span>
00539 <span class="preprocessor">        if (neg) { \</span>
00540 <span class="preprocessor">            LCPDEBUG((LOG_INFO, "lcp_addci: L opt=%d %lX\n", opt, val)); \</span>
00541 <span class="preprocessor">                PUTCHAR(opt, ucp); \</span>
00542 <span class="preprocessor">                PUTCHAR(CILEN_LONG, ucp); \</span>
00543 <span class="preprocessor">                PUTLONG(val, ucp); \</span>
00544 <span class="preprocessor">        }</span>
00545 <span class="preprocessor"></span><span class="preprocessor">#define ADDCILQR(opt, neg, val) \</span>
00546 <span class="preprocessor">        if (neg) { \</span>
00547 <span class="preprocessor">            LCPDEBUG((LOG_INFO, "lcp_addci: LQR opt=%d %lX\n", opt, val)); \</span>
00548 <span class="preprocessor">                PUTCHAR(opt, ucp); \</span>
00549 <span class="preprocessor">                PUTCHAR(CILEN_LQR, ucp); \</span>
00550 <span class="preprocessor">                PUTSHORT(PPP_LQR, ucp); \</span>
00551 <span class="preprocessor">                PUTLONG(val, ucp); \</span>
00552 <span class="preprocessor">        }</span>
00553 <span class="preprocessor"></span><span class="preprocessor">#define ADDCICHAR(opt, neg, val) \</span>
00554 <span class="preprocessor">        if (neg) { \</span>
00555 <span class="preprocessor">            LCPDEBUG((LOG_INFO, "lcp_addci: CHAR opt=%d %X '%z'\n", opt, val, val)); \</span>
00556 <span class="preprocessor">                PUTCHAR(opt, ucp); \</span>
00557 <span class="preprocessor">                PUTCHAR(CILEN_CHAR, ucp); \</span>
00558 <span class="preprocessor">                PUTCHAR(val, ucp); \</span>
00559 <span class="preprocessor">        }</span>
00560 <span class="preprocessor"></span>        
00561         ADDCISHORT(CI_MRU, go-&gt;<a class="code" href="structlcp__options.html#o3">neg_mru</a> &amp;&amp; go-&gt;<a class="code" href="structlcp__options.html#o12">mru</a> != PPP_DEFMRU, go-&gt;<a class="code" href="structlcp__options.html#o12">mru</a>);
00562         ADDCILONG(CI_ASYNCMAP, go-&gt;<a class="code" href="structlcp__options.html#o4">neg_asyncmap</a> &amp;&amp; go-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a> != 0xFFFFFFFFl,
00563                         go-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a>);
00564         ADDCICHAP(CI_AUTHTYPE, go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>, PPP_CHAP, go-&gt;<a class="code" href="structlcp__options.html#o13">chap_mdtype</a>);
00565         ADDCISHORT(CI_AUTHTYPE, !go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a> &amp;&amp; go-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a>, PPP_PAP);
00566         ADDCILQR(CI_QUALITY, go-&gt;<a class="code" href="structlcp__options.html#o10">neg_lqr</a>, go-&gt;<a class="code" href="structlcp__options.html#o17">lqr_period</a>);
00567         ADDCICHAR(CI_CALLBACK, go-&gt;<a class="code" href="structlcp__options.html#o11">neg_cbcp</a>, CBCP_OPT);
00568         ADDCILONG(CI_MAGICNUMBER, go-&gt;<a class="code" href="structlcp__options.html#o7">neg_magicnumber</a>, go-&gt;<a class="code" href="structlcp__options.html#o15">magicnumber</a>);
00569         ADDCIVOID(CI_PCOMPRESSION, go-&gt;<a class="code" href="structlcp__options.html#o8">neg_pcompression</a>);
00570         ADDCIVOID(CI_ACCOMPRESSION, go-&gt;<a class="code" href="structlcp__options.html#o9">neg_accompression</a>);
00571         
00572         <span class="keywordflow">if</span> (ucp - start_ucp != *lenp) {
00573                 <span class="comment">/* this should never happen, because peer_mtu should be 1500 */</span>
00574                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_ERR, <span class="stringliteral">"Bug in lcp_addci: wrong length\n"</span>));
00575         }
00576 }
00577 
00578 
00579 <span class="comment">/*</span>
00580 <span class="comment"> * lcp_ackci - Ack our CIs.</span>
00581 <span class="comment"> * This should not modify any state if the Ack is bad.</span>
00582 <span class="comment"> *</span>
00583 <span class="comment"> * Returns:</span>
00584 <span class="comment"> *      0 - Ack was bad.</span>
00585 <span class="comment"> *      1 - Ack was good.</span>
00586 <span class="comment"> */</span>
00587 <span class="keyword">static</span> <span class="keywordtype">int</span> lcp_ackci(<a class="code" href="structfsm.html">fsm</a> *f, u_char *p, <span class="keywordtype">int</span> len)
00588 {
00589         <a class="code" href="structlcp__options.html">lcp_options</a> *go = &amp;<a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00590         u_char cilen, citype, cichar;
00591         u_short cishort;
00592         u32_t cilong;
00593         
00594         <span class="comment">/*</span>
00595 <span class="comment">        * CIs must be in exactly the same order that we sent.</span>
00596 <span class="comment">        * Check packet length and CI length at each step.</span>
00597 <span class="comment">        * If we find any deviations, then this packet is bad.</span>
00598 <span class="comment">        */</span>
00599 <span class="preprocessor">#define ACKCIVOID(opt, neg) \</span>
00600 <span class="preprocessor">        if (neg) { \</span>
00601 <span class="preprocessor">                if ((len -= CILEN_VOID) &lt; 0) \</span>
00602 <span class="preprocessor">                        goto bad; \</span>
00603 <span class="preprocessor">                GETCHAR(citype, p); \</span>
00604 <span class="preprocessor">                GETCHAR(cilen, p); \</span>
00605 <span class="preprocessor">                if (cilen != CILEN_VOID || \</span>
00606 <span class="preprocessor">                                citype != opt) \</span>
00607 <span class="preprocessor">                        goto bad; \</span>
00608 <span class="preprocessor">        }</span>
00609 <span class="preprocessor"></span><span class="preprocessor">#define ACKCISHORT(opt, neg, val) \</span>
00610 <span class="preprocessor">        if (neg) { \</span>
00611 <span class="preprocessor">                if ((len -= CILEN_SHORT) &lt; 0) \</span>
00612 <span class="preprocessor">                        goto bad; \</span>
00613 <span class="preprocessor">                GETCHAR(citype, p); \</span>
00614 <span class="preprocessor">                GETCHAR(cilen, p); \</span>
00615 <span class="preprocessor">                if (cilen != CILEN_SHORT || \</span>
00616 <span class="preprocessor">                                citype != opt) \</span>
00617 <span class="preprocessor">                        goto bad; \</span>
00618 <span class="preprocessor">                GETSHORT(cishort, p); \</span>
00619 <span class="preprocessor">                if (cishort != val) \</span>
00620 <span class="preprocessor">                        goto bad; \</span>
00621 <span class="preprocessor">        }</span>
00622 <span class="preprocessor"></span><span class="preprocessor">#define ACKCICHAR(opt, neg, val) \</span>
00623 <span class="preprocessor">        if (neg) { \</span>
00624 <span class="preprocessor">                if ((len -= CILEN_CHAR) &lt; 0) \</span>
00625 <span class="preprocessor">                        goto bad; \</span>
00626 <span class="preprocessor">                GETCHAR(citype, p); \</span>
00627 <span class="preprocessor">                GETCHAR(cilen, p); \</span>
00628 <span class="preprocessor">                if (cilen != CILEN_CHAR || \</span>
00629 <span class="preprocessor">                                citype != opt) \</span>
00630 <span class="preprocessor">                        goto bad; \</span>
00631 <span class="preprocessor">                GETCHAR(cichar, p); \</span>
00632 <span class="preprocessor">                if (cichar != val) \</span>
00633 <span class="preprocessor">                        goto bad; \</span>
00634 <span class="preprocessor">        }</span>
00635 <span class="preprocessor"></span><span class="preprocessor">#define ACKCICHAP(opt, neg, val, digest) \</span>
00636 <span class="preprocessor">        if (neg) { \</span>
00637 <span class="preprocessor">                if ((len -= CILEN_CHAP) &lt; 0) \</span>
00638 <span class="preprocessor">                        goto bad; \</span>
00639 <span class="preprocessor">                GETCHAR(citype, p); \</span>
00640 <span class="preprocessor">                GETCHAR(cilen, p); \</span>
00641 <span class="preprocessor">                if (cilen != CILEN_CHAP || \</span>
00642 <span class="preprocessor">                                citype != opt) \</span>
00643 <span class="preprocessor">                        goto bad; \</span>
00644 <span class="preprocessor">                GETSHORT(cishort, p); \</span>
00645 <span class="preprocessor">                if (cishort != val) \</span>
00646 <span class="preprocessor">                        goto bad; \</span>
00647 <span class="preprocessor">                GETCHAR(cichar, p); \</span>
00648 <span class="preprocessor">                if (cichar != digest) \</span>
00649 <span class="preprocessor">                        goto bad; \</span>
00650 <span class="preprocessor">        }</span>
00651 <span class="preprocessor"></span><span class="preprocessor">#define ACKCILONG(opt, neg, val) \</span>
00652 <span class="preprocessor">        if (neg) { \</span>
00653 <span class="preprocessor">                if ((len -= CILEN_LONG) &lt; 0) \</span>
00654 <span class="preprocessor">                        goto bad; \</span>
00655 <span class="preprocessor">                GETCHAR(citype, p); \</span>
00656 <span class="preprocessor">                GETCHAR(cilen, p); \</span>
00657 <span class="preprocessor">                if (cilen != CILEN_LONG || \</span>
00658 <span class="preprocessor">                                citype != opt) \</span>
00659 <span class="preprocessor">                        goto bad; \</span>
00660 <span class="preprocessor">                GETLONG(cilong, p); \</span>
00661 <span class="preprocessor">                if (cilong != val) \</span>
00662 <span class="preprocessor">                        goto bad; \</span>
00663 <span class="preprocessor">        }</span>
00664 <span class="preprocessor"></span><span class="preprocessor">#define ACKCILQR(opt, neg, val) \</span>
00665 <span class="preprocessor">        if (neg) { \</span>
00666 <span class="preprocessor">                if ((len -= CILEN_LQR) &lt; 0) \</span>
00667 <span class="preprocessor">                        goto bad; \</span>
00668 <span class="preprocessor">                GETCHAR(citype, p); \</span>
00669 <span class="preprocessor">                GETCHAR(cilen, p); \</span>
00670 <span class="preprocessor">                if (cilen != CILEN_LQR || \</span>
00671 <span class="preprocessor">                                citype != opt) \</span>
00672 <span class="preprocessor">                        goto bad; \</span>
00673 <span class="preprocessor">                GETSHORT(cishort, p); \</span>
00674 <span class="preprocessor">                if (cishort != PPP_LQR) \</span>
00675 <span class="preprocessor">                        goto bad; \</span>
00676 <span class="preprocessor">                GETLONG(cilong, p); \</span>
00677 <span class="preprocessor">                if (cilong != val) \</span>
00678 <span class="preprocessor">                        goto bad; \</span>
00679 <span class="preprocessor">        }</span>
00680 <span class="preprocessor"></span>        
00681         ACKCISHORT(CI_MRU, go-&gt;<a class="code" href="structlcp__options.html#o3">neg_mru</a> &amp;&amp; go-&gt;<a class="code" href="structlcp__options.html#o12">mru</a> != PPP_DEFMRU, go-&gt;<a class="code" href="structlcp__options.html#o12">mru</a>);
00682         ACKCILONG(CI_ASYNCMAP, go-&gt;<a class="code" href="structlcp__options.html#o4">neg_asyncmap</a> &amp;&amp; go-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a> != 0xFFFFFFFFl,
00683                         go-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a>);
00684         ACKCICHAP(CI_AUTHTYPE, go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>, PPP_CHAP, go-&gt;<a class="code" href="structlcp__options.html#o13">chap_mdtype</a>);
00685         ACKCISHORT(CI_AUTHTYPE, !go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a> &amp;&amp; go-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a>, PPP_PAP);
00686         ACKCILQR(CI_QUALITY, go-&gt;<a class="code" href="structlcp__options.html#o10">neg_lqr</a>, go-&gt;<a class="code" href="structlcp__options.html#o17">lqr_period</a>);
00687         ACKCICHAR(CI_CALLBACK, go-&gt;<a class="code" href="structlcp__options.html#o11">neg_cbcp</a>, CBCP_OPT);
00688         ACKCILONG(CI_MAGICNUMBER, go-&gt;<a class="code" href="structlcp__options.html#o7">neg_magicnumber</a>, go-&gt;<a class="code" href="structlcp__options.html#o15">magicnumber</a>);
00689         ACKCIVOID(CI_PCOMPRESSION, go-&gt;<a class="code" href="structlcp__options.html#o8">neg_pcompression</a>);
00690         ACKCIVOID(CI_ACCOMPRESSION, go-&gt;<a class="code" href="structlcp__options.html#o9">neg_accompression</a>);
00691         
00692         <span class="comment">/*</span>
00693 <span class="comment">         * If there are any remaining CIs, then this packet is bad.</span>
00694 <span class="comment">         */</span>
00695         <span class="keywordflow">if</span> (len != 0)
00696                 <span class="keywordflow">goto</span> bad;
00697         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"lcp_acki: Ack\n"</span>));
00698         <span class="keywordflow">return</span> (1);
00699 bad:
00700         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"lcp_acki: received bad Ack!\n"</span>));
00701         <span class="keywordflow">return</span> (0);
00702 }
00703 
00704 
00705 <span class="comment">/*</span>
00706 <span class="comment"> * lcp_nakci - Peer has sent a NAK for some of our CIs.</span>
00707 <span class="comment"> * This should not modify any state if the Nak is bad</span>
00708 <span class="comment"> * or if LCP is in the OPENED state.</span>
00709 <span class="comment"> *</span>
00710 <span class="comment"> * Returns:</span>
00711 <span class="comment"> *      0 - Nak was bad.</span>
00712 <span class="comment"> *      1 - Nak was good.</span>
00713 <span class="comment"> */</span>
00714 <span class="keyword">static</span> <span class="keywordtype">int</span> lcp_nakci(<a class="code" href="structfsm.html">fsm</a> *f, u_char *p, <span class="keywordtype">int</span> len)
00715 {
00716         <a class="code" href="structlcp__options.html">lcp_options</a> *go = &amp;<a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00717         <a class="code" href="structlcp__options.html">lcp_options</a> *wo = &amp;<a class="code" href="lcp_8h.html#a19">lcp_wantoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00718         u_char citype, cichar, *next;
00719         u_short cishort;
00720         u32_t cilong;
00721         <a class="code" href="structlcp__options.html">lcp_options</a> no;         <span class="comment">/* options we've seen Naks for */</span>
00722         <a class="code" href="structlcp__options.html">lcp_options</a> <span class="keywordflow">try</span>;                <span class="comment">/* options to request next time */</span>
00723         <span class="keywordtype">int</span> looped_back = 0;
00724         <span class="keywordtype">int</span> cilen;
00725         
00726         BZERO(&amp;no, <span class="keyword">sizeof</span>(no));
00727         <span class="keywordflow">try</span> = *go;
00728         
00729         <span class="comment">/*</span>
00730 <span class="comment">        * Any Nak'd CIs must be in exactly the same order that we sent.</span>
00731 <span class="comment">        * Check packet length and CI length at each step.</span>
00732 <span class="comment">        * If we find any deviations, then this packet is bad.</span>
00733 <span class="comment">        */</span>
00734 <span class="preprocessor">#define NAKCIVOID(opt, neg, code) \</span>
00735 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
00736 <span class="preprocessor">                        len &gt;= CILEN_VOID &amp;&amp; \</span>
00737 <span class="preprocessor">                        p[1] == CILEN_VOID &amp;&amp; \</span>
00738 <span class="preprocessor">                        p[0] == opt) { \</span>
00739 <span class="preprocessor">                len -= CILEN_VOID; \</span>
00740 <span class="preprocessor">                INCPTR(CILEN_VOID, p); \</span>
00741 <span class="preprocessor">                no.neg = 1; \</span>
00742 <span class="preprocessor">                code \</span>
00743 <span class="preprocessor">        }</span>
00744 <span class="preprocessor"></span><span class="preprocessor">#define NAKCICHAP(opt, neg, code) \</span>
00745 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
00746 <span class="preprocessor">                        len &gt;= CILEN_CHAP &amp;&amp; \</span>
00747 <span class="preprocessor">                        p[1] == CILEN_CHAP &amp;&amp; \</span>
00748 <span class="preprocessor">                        p[0] == opt) { \</span>
00749 <span class="preprocessor">                len -= CILEN_CHAP; \</span>
00750 <span class="preprocessor">                INCPTR(2, p); \</span>
00751 <span class="preprocessor">                GETSHORT(cishort, p); \</span>
00752 <span class="preprocessor">                GETCHAR(cichar, p); \</span>
00753 <span class="preprocessor">                no.neg = 1; \</span>
00754 <span class="preprocessor">                code \</span>
00755 <span class="preprocessor">        }</span>
00756 <span class="preprocessor"></span><span class="preprocessor">#define NAKCICHAR(opt, neg, code) \</span>
00757 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
00758 <span class="preprocessor">                        len &gt;= CILEN_CHAR &amp;&amp; \</span>
00759 <span class="preprocessor">                        p[1] == CILEN_CHAR &amp;&amp; \</span>
00760 <span class="preprocessor">                        p[0] == opt) { \</span>
00761 <span class="preprocessor">                len -= CILEN_CHAR; \</span>
00762 <span class="preprocessor">                INCPTR(2, p); \</span>
00763 <span class="preprocessor">                GETCHAR(cichar, p); \</span>
00764 <span class="preprocessor">                no.neg = 1; \</span>
00765 <span class="preprocessor">                code \</span>
00766 <span class="preprocessor">        }</span>
00767 <span class="preprocessor"></span><span class="preprocessor">#define NAKCISHORT(opt, neg, code) \</span>
00768 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
00769 <span class="preprocessor">                        len &gt;= CILEN_SHORT &amp;&amp; \</span>
00770 <span class="preprocessor">                        p[1] == CILEN_SHORT &amp;&amp; \</span>
00771 <span class="preprocessor">                        p[0] == opt) { \</span>
00772 <span class="preprocessor">                len -= CILEN_SHORT; \</span>
00773 <span class="preprocessor">                INCPTR(2, p); \</span>
00774 <span class="preprocessor">                GETSHORT(cishort, p); \</span>
00775 <span class="preprocessor">                no.neg = 1; \</span>
00776 <span class="preprocessor">                code \</span>
00777 <span class="preprocessor">        }</span>
00778 <span class="preprocessor"></span><span class="preprocessor">#define NAKCILONG(opt, neg, code) \</span>
00779 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
00780 <span class="preprocessor">                        len &gt;= CILEN_LONG &amp;&amp; \</span>
00781 <span class="preprocessor">                        p[1] == CILEN_LONG &amp;&amp; \</span>
00782 <span class="preprocessor">                        p[0] == opt) { \</span>
00783 <span class="preprocessor">                len -= CILEN_LONG; \</span>
00784 <span class="preprocessor">                INCPTR(2, p); \</span>
00785 <span class="preprocessor">                GETLONG(cilong, p); \</span>
00786 <span class="preprocessor">                no.neg = 1; \</span>
00787 <span class="preprocessor">                code \</span>
00788 <span class="preprocessor">        }</span>
00789 <span class="preprocessor"></span><span class="preprocessor">#define NAKCILQR(opt, neg, code) \</span>
00790 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
00791 <span class="preprocessor">                        len &gt;= CILEN_LQR &amp;&amp; \</span>
00792 <span class="preprocessor">                        p[1] == CILEN_LQR &amp;&amp; \</span>
00793 <span class="preprocessor">                        p[0] == opt) { \</span>
00794 <span class="preprocessor">                len -= CILEN_LQR; \</span>
00795 <span class="preprocessor">                INCPTR(2, p); \</span>
00796 <span class="preprocessor">                GETSHORT(cishort, p); \</span>
00797 <span class="preprocessor">                GETLONG(cilong, p); \</span>
00798 <span class="preprocessor">                no.neg = 1; \</span>
00799 <span class="preprocessor">                code \</span>
00800 <span class="preprocessor">        }</span>
00801 <span class="preprocessor"></span>        
00802         <span class="comment">/*</span>
00803 <span class="comment">        * We don't care if they want to send us smaller packets than</span>
00804 <span class="comment">        * we want.  Therefore, accept any MRU less than what we asked for,</span>
00805 <span class="comment">        * but then ignore the new value when setting the MRU in the kernel.</span>
00806 <span class="comment">        * If they send us a bigger MRU than what we asked, accept it, up to</span>
00807 <span class="comment">        * the limit of the default MRU we'd get if we didn't negotiate.</span>
00808 <span class="comment">        */</span>
00809         <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structlcp__options.html#o3">neg_mru</a> &amp;&amp; go-&gt;<a class="code" href="structlcp__options.html#o12">mru</a> != PPP_DEFMRU) {
00810                 NAKCISHORT(CI_MRU, neg_mru,
00811                         <span class="keywordflow">if</span> (cishort &lt;= wo-&gt;mru || cishort &lt; PPP_DEFMRU)
00812                                 <span class="keywordflow">try</span>.mru = cishort;
00813                 );
00814         }
00815         
00816         <span class="comment">/*</span>
00817 <span class="comment">        * Add any characters they want to our (receive-side) asyncmap.</span>
00818 <span class="comment">        */</span>
00819         <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structlcp__options.html#o4">neg_asyncmap</a> &amp;&amp; go-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a> != 0xFFFFFFFFl) {
00820                 NAKCILONG(CI_ASYNCMAP, neg_asyncmap,
00821                         <span class="keywordflow">try</span>.asyncmap = go-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a> | cilong;
00822                 );
00823         }
00824         
00825         <span class="comment">/*</span>
00826 <span class="comment">        * If they've nak'd our authentication-protocol, check whether</span>
00827 <span class="comment">        * they are proposing a different protocol, or a different</span>
00828 <span class="comment">        * hash algorithm for CHAP.</span>
00829 <span class="comment">        */</span>
00830         <span class="keywordflow">if</span> ((go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a> || go-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a>)
00831                         &amp;&amp; len &gt;= CILEN_SHORT
00832                         &amp;&amp; p[0] == <a class="code" href="lcp_8h.html#a2">CI_AUTHTYPE</a> &amp;&amp; p[1] &gt;= CILEN_SHORT &amp;&amp; p[1] &lt;= len) {
00833                 cilen = p[1];
00834         len -= cilen;
00835         no.<a class="code" href="structlcp__options.html#o6">neg_chap</a> = go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>;
00836         no.<a class="code" href="structlcp__options.html#o5">neg_upap</a> = go-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a>;
00837         INCPTR(2, p);
00838         GETSHORT(cishort, p);
00839         <span class="keywordflow">if</span> (cishort == PPP_PAP &amp;&amp; cilen == CILEN_SHORT) {
00840                 <span class="comment">/*</span>
00841 <span class="comment">                 * If we were asking for CHAP, they obviously don't want to do it.</span>
00842 <span class="comment">                 * If we weren't asking for CHAP, then we were asking for PAP,</span>
00843 <span class="comment">                 * in which case this Nak is bad.</span>
00844 <span class="comment">                 */</span>
00845                 <span class="keywordflow">if</span> (!go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>)
00846                         <span class="keywordflow">goto</span> bad;
00847                 <span class="keywordflow">try</span>.neg_chap = 0;
00848         
00849         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cishort == PPP_CHAP &amp;&amp; cilen == CILEN_CHAP) {
00850                 GETCHAR(cichar, p);
00851                 <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>) {
00852                         <span class="comment">/*</span>
00853 <span class="comment">                         * We were asking for CHAP/MD5; they must want a different</span>
00854 <span class="comment">                         * algorithm.  If they can't do MD5, we'll have to stop</span>
00855 <span class="comment">                         * asking for CHAP.</span>
00856 <span class="comment">                         */</span>
00857                         <span class="keywordflow">if</span> (cichar != go-&gt;<a class="code" href="structlcp__options.html#o13">chap_mdtype</a>)
00858                                 <span class="keywordflow">try</span>.neg_chap = 0;
00859                 } <span class="keywordflow">else</span> {
00860                         <span class="comment">/*</span>
00861 <span class="comment">                         * Stop asking for PAP if we were asking for it.</span>
00862 <span class="comment">                         */</span>
00863                         <span class="keywordflow">try</span>.neg_upap = 0;
00864                 }
00865         
00866         } <span class="keywordflow">else</span> {
00867                 <span class="comment">/*</span>
00868 <span class="comment">                 * We don't recognize what they're suggesting.</span>
00869 <span class="comment">                 * Stop asking for what we were asking for.</span>
00870 <span class="comment">                 */</span>
00871                 <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>)
00872                         <span class="keywordflow">try</span>.neg_chap = 0;
00873                 <span class="keywordflow">else</span>
00874                         <span class="keywordflow">try</span>.neg_upap = 0;
00875                 p += cilen - CILEN_SHORT;
00876         }
00877         }
00878         
00879         <span class="comment">/*</span>
00880 <span class="comment">        * If they can't cope with our link quality protocol, we'll have</span>
00881 <span class="comment">        * to stop asking for LQR.  We haven't got any other protocol.</span>
00882 <span class="comment">        * If they Nak the reporting period, take their value XXX ?</span>
00883 <span class="comment">        */</span>
00884         NAKCILQR(CI_QUALITY, neg_lqr,
00885                 <span class="keywordflow">if</span> (cishort != PPP_LQR)
00886                         <span class="keywordflow">try</span>.neg_lqr = 0;
00887                 <span class="keywordflow">else</span>
00888                         <span class="keywordflow">try</span>.lqr_period = cilong;
00889         );
00890         
00891         <span class="comment">/*</span>
00892 <span class="comment">        * Only implementing CBCP...not the rest of the callback options</span>
00893 <span class="comment">        */</span>
00894         NAKCICHAR(CI_CALLBACK, neg_cbcp,
00895                 <span class="keywordflow">try</span>.neg_cbcp = 0;
00896         );
00897         
00898         <span class="comment">/*</span>
00899 <span class="comment">        * Check for a looped-back line.</span>
00900 <span class="comment">        */</span>
00901         NAKCILONG(CI_MAGICNUMBER, neg_magicnumber,
00902                 <span class="keywordflow">try</span>.magicnumber = <a class="code" href="magic_8c.html#a1">magic</a>();
00903                 looped_back = 1;
00904         );
00905         
00906         <span class="comment">/*</span>
00907 <span class="comment">        * Peer shouldn't send Nak for protocol compression or</span>
00908 <span class="comment">        * address/control compression requests; they should send</span>
00909 <span class="comment">        * a Reject instead.  If they send a Nak, treat it as a Reject.</span>
00910 <span class="comment">        */</span>
00911         NAKCIVOID(CI_PCOMPRESSION, neg_pcompression,
00912                 <span class="keywordflow">try</span>.neg_pcompression = 0;
00913         );
00914         NAKCIVOID(CI_ACCOMPRESSION, neg_accompression,
00915                 <span class="keywordflow">try</span>.neg_accompression = 0;
00916         );
00917         
00918         <span class="comment">/*</span>
00919 <span class="comment">        * There may be remaining CIs, if the peer is requesting negotiation</span>
00920 <span class="comment">        * on an option that we didn't include in our request packet.</span>
00921 <span class="comment">        * If we see an option that we requested, or one we've already seen</span>
00922 <span class="comment">        * in this packet, then this packet is bad.</span>
00923 <span class="comment">        * If we wanted to respond by starting to negotiate on the requested</span>
00924 <span class="comment">        * option(s), we could, but we don't, because except for the</span>
00925 <span class="comment">        * authentication type and quality protocol, if we are not negotiating</span>
00926 <span class="comment">        * an option, it is because we were told not to.</span>
00927 <span class="comment">        * For the authentication type, the Nak from the peer means</span>
00928 <span class="comment">        * `let me authenticate myself with you' which is a bit pointless.</span>
00929 <span class="comment">        * For the quality protocol, the Nak means `ask me to send you quality</span>
00930 <span class="comment">        * reports', but if we didn't ask for them, we don't want them.</span>
00931 <span class="comment">        * An option we don't recognize represents the peer asking to</span>
00932 <span class="comment">        * negotiate some option we don't support, so ignore it.</span>
00933 <span class="comment">        */</span>
00934         <span class="keywordflow">while</span> (len &gt; CILEN_VOID) {
00935                 GETCHAR(citype, p);
00936                 GETCHAR(cilen, p);
00937                 <span class="keywordflow">if</span> (cilen &lt; CILEN_VOID || (len -= cilen) &lt; 0)
00938                         <span class="keywordflow">goto</span> bad;
00939                 next = p + cilen - 2;
00940                 
00941                 <span class="keywordflow">switch</span> (citype) {
00942                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a0">CI_MRU</a>:
00943                         <span class="keywordflow">if</span> ((go-&gt;<a class="code" href="structlcp__options.html#o3">neg_mru</a> &amp;&amp; go-&gt;<a class="code" href="structlcp__options.html#o12">mru</a> != PPP_DEFMRU)
00944                                         || no.<a class="code" href="structlcp__options.html#o3">neg_mru</a> || cilen != CILEN_SHORT)
00945                                 <span class="keywordflow">goto</span> bad;
00946                         GETSHORT(cishort, p);
00947                         <span class="keywordflow">if</span> (cishort &lt; PPP_DEFMRU)
00948                                 <span class="keywordflow">try</span>.mru = cishort;
00949                         <span class="keywordflow">break</span>;
00950                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a1">CI_ASYNCMAP</a>:
00951                         <span class="keywordflow">if</span> ((go-&gt;<a class="code" href="structlcp__options.html#o4">neg_asyncmap</a> &amp;&amp; go-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a> != 0xFFFFFFFFl)
00952                                         || no.<a class="code" href="structlcp__options.html#o4">neg_asyncmap</a> || cilen != CILEN_LONG)
00953                                 <span class="keywordflow">goto</span> bad;
00954                         <span class="keywordflow">break</span>;
00955                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a2">CI_AUTHTYPE</a>:
00956                         <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a> || no.<a class="code" href="structlcp__options.html#o6">neg_chap</a> || go-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a> || no.<a class="code" href="structlcp__options.html#o5">neg_upap</a>)
00957                                 <span class="keywordflow">goto</span> bad;
00958                         <span class="keywordflow">break</span>;
00959                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a4">CI_MAGICNUMBER</a>:
00960                         <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structlcp__options.html#o7">neg_magicnumber</a> || no.<a class="code" href="structlcp__options.html#o7">neg_magicnumber</a> ||
00961                                         cilen != CILEN_LONG)
00962                                 <span class="keywordflow">goto</span> bad;
00963                         <span class="keywordflow">break</span>;
00964                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a5">CI_PCOMPRESSION</a>:
00965                         <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structlcp__options.html#o8">neg_pcompression</a> || no.<a class="code" href="structlcp__options.html#o8">neg_pcompression</a>
00966                                         || cilen != CILEN_VOID)
00967                                 <span class="keywordflow">goto</span> bad;
00968                         <span class="keywordflow">break</span>;
00969                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a6">CI_ACCOMPRESSION</a>:
00970                         <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structlcp__options.html#o9">neg_accompression</a> || no.<a class="code" href="structlcp__options.html#o9">neg_accompression</a>
00971                                         || cilen != CILEN_VOID)
00972                                 <span class="keywordflow">goto</span> bad;
00973                         <span class="keywordflow">break</span>;
00974                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a3">CI_QUALITY</a>:
00975                         <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structlcp__options.html#o10">neg_lqr</a> || no.<a class="code" href="structlcp__options.html#o10">neg_lqr</a> || cilen != CILEN_LQR)
00976                                 <span class="keywordflow">goto</span> bad;
00977                         <span class="keywordflow">break</span>;
00978                 }
00979                 p = next;
00980         }
00981         
00982         <span class="comment">/* If there is still anything left, this packet is bad. */</span>
00983         <span class="keywordflow">if</span> (len != 0)
00984                 <span class="keywordflow">goto</span> bad;
00985         
00986         <span class="comment">/*</span>
00987 <span class="comment">        * OK, the Nak is good.  Now we can update state.</span>
00988 <span class="comment">        */</span>
00989         <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structfsm.html#o2">state</a> != <a class="code" href="fsm_8h.html#a17">OPENED</a>) {
00990                 <span class="keywordflow">if</span> (looped_back) {
00991                         <span class="keywordflow">if</span> (++<span class="keywordflow">try</span>.numloops &gt;= lcp_loopbackfail) {
00992                                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_NOTICE, <span class="stringliteral">"Serial line is looped back.\n"</span>));
00993                                 <a class="code" href="lcp_8h.html#a34">lcp_close</a>(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, <span class="stringliteral">"Loopback detected"</span>);
00994                         }
00995                 } 
00996                 <span class="keywordflow">else</span>
00997                         <span class="keywordflow">try</span>.numloops = 0;
00998                 *go = <span class="keywordflow">try</span>;
00999         }
01000         
01001         <span class="keywordflow">return</span> 1;
01002         
01003 bad:
01004         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"lcp_nakci: received bad Nak!\n"</span>));
01005         <span class="keywordflow">return</span> 0;
01006 }
01007 
01008 
01009 <span class="comment">/*</span>
01010 <span class="comment"> * lcp_rejci - Peer has Rejected some of our CIs.</span>
01011 <span class="comment"> * This should not modify any state if the Reject is bad</span>
01012 <span class="comment"> * or if LCP is in the OPENED state.</span>
01013 <span class="comment"> *</span>
01014 <span class="comment"> * Returns:</span>
01015 <span class="comment"> *      0 - Reject was bad.</span>
01016 <span class="comment"> *      1 - Reject was good.</span>
01017 <span class="comment"> */</span>
01018 <span class="keyword">static</span> <span class="keywordtype">int</span> lcp_rejci(<a class="code" href="structfsm.html">fsm</a> *f, u_char *p, <span class="keywordtype">int</span> len)
01019 {
01020         <a class="code" href="structlcp__options.html">lcp_options</a> *go = &amp;<a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
01021         u_char cichar;
01022         u_short cishort;
01023         u32_t cilong;
01024         <a class="code" href="structlcp__options.html">lcp_options</a> <span class="keywordflow">try</span>;                <span class="comment">/* options to request next time */</span>
01025         
01026         <span class="keywordflow">try</span> = *go;
01027         
01028         <span class="comment">/*</span>
01029 <span class="comment">        * Any Rejected CIs must be in exactly the same order that we sent.</span>
01030 <span class="comment">        * Check packet length and CI length at each step.</span>
01031 <span class="comment">        * If we find any deviations, then this packet is bad.</span>
01032 <span class="comment">        */</span>
01033 <span class="preprocessor">#define REJCIVOID(opt, neg) \</span>
01034 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
01035 <span class="preprocessor">                        len &gt;= CILEN_VOID &amp;&amp; \</span>
01036 <span class="preprocessor">                        p[1] == CILEN_VOID &amp;&amp; \</span>
01037 <span class="preprocessor">                        p[0] == opt) { \</span>
01038 <span class="preprocessor">                len -= CILEN_VOID; \</span>
01039 <span class="preprocessor">                INCPTR(CILEN_VOID, p); \</span>
01040 <span class="preprocessor">                try.neg = 0; \</span>
01041 <span class="preprocessor">                LCPDEBUG((LOG_INFO, "lcp_rejci: void opt %d rejected\n", opt)); \</span>
01042 <span class="preprocessor">        }</span>
01043 <span class="preprocessor"></span><span class="preprocessor">#define REJCISHORT(opt, neg, val) \</span>
01044 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
01045 <span class="preprocessor">                        len &gt;= CILEN_SHORT &amp;&amp; \</span>
01046 <span class="preprocessor">                        p[1] == CILEN_SHORT &amp;&amp; \</span>
01047 <span class="preprocessor">                        p[0] == opt) { \</span>
01048 <span class="preprocessor">                len -= CILEN_SHORT; \</span>
01049 <span class="preprocessor">                INCPTR(2, p); \</span>
01050 <span class="preprocessor">                GETSHORT(cishort, p); \</span>
01051 <span class="preprocessor">                </span><span class="comment">/* Check rejected value. */</span> \
01052                 if (cishort != val) \
01053                         goto bad; \
01054                 try.neg = 0; \
01055                 LCPDEBUG((LOG_INFO,"lcp_rejci: short opt %d rejected\n", opt)); \
01056         }
01057 <span class="preprocessor">#define REJCICHAP(opt, neg, val, digest) \</span>
01058 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
01059 <span class="preprocessor">                        len &gt;= CILEN_CHAP &amp;&amp; \</span>
01060 <span class="preprocessor">                        p[1] == CILEN_CHAP &amp;&amp; \</span>
01061 <span class="preprocessor">                        p[0] == opt) { \</span>
01062 <span class="preprocessor">                len -= CILEN_CHAP; \</span>
01063 <span class="preprocessor">                INCPTR(2, p); \</span>
01064 <span class="preprocessor">                GETSHORT(cishort, p); \</span>
01065 <span class="preprocessor">                GETCHAR(cichar, p); \</span>
01066 <span class="preprocessor">                </span><span class="comment">/* Check rejected value. */</span> \
01067                 if (cishort != val || cichar != digest) \
01068                         goto bad; \
01069                 try.neg = 0; \
01070                 try.neg_upap = 0; \
01071                 LCPDEBUG((LOG_INFO,"lcp_rejci: chap opt %d rejected\n", opt)); \
01072         }
01073 <span class="preprocessor">#define REJCILONG(opt, neg, val) \</span>
01074 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
01075 <span class="preprocessor">                        len &gt;= CILEN_LONG &amp;&amp; \</span>
01076 <span class="preprocessor">                        p[1] == CILEN_LONG &amp;&amp; \</span>
01077 <span class="preprocessor">                        p[0] == opt) { \</span>
01078 <span class="preprocessor">                len -= CILEN_LONG; \</span>
01079 <span class="preprocessor">                INCPTR(2, p); \</span>
01080 <span class="preprocessor">                GETLONG(cilong, p); \</span>
01081 <span class="preprocessor">                </span><span class="comment">/* Check rejected value. */</span> \
01082                 if (cilong != val) \
01083                         goto bad; \
01084                 try.neg = 0; \
01085                 LCPDEBUG((LOG_INFO,"lcp_rejci: long opt %d rejected\n", opt)); \
01086         }
01087 <span class="preprocessor">#define REJCILQR(opt, neg, val) \</span>
01088 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
01089 <span class="preprocessor">                        len &gt;= CILEN_LQR &amp;&amp; \</span>
01090 <span class="preprocessor">                        p[1] == CILEN_LQR &amp;&amp; \</span>
01091 <span class="preprocessor">                        p[0] == opt) { \</span>
01092 <span class="preprocessor">                len -= CILEN_LQR; \</span>
01093 <span class="preprocessor">                INCPTR(2, p); \</span>
01094 <span class="preprocessor">                GETSHORT(cishort, p); \</span>
01095 <span class="preprocessor">                GETLONG(cilong, p); \</span>
01096 <span class="preprocessor">                </span><span class="comment">/* Check rejected value. */</span> \
01097                 if (cishort != PPP_LQR || cilong != val) \
01098                         goto bad; \
01099                 try.neg = 0; \
01100                 LCPDEBUG((LOG_INFO,"lcp_rejci: LQR opt %d rejected\n", opt)); \
01101         }
01102 <span class="preprocessor">#define REJCICBCP(opt, neg, val) \</span>
01103 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
01104 <span class="preprocessor">                        len &gt;= CILEN_CBCP &amp;&amp; \</span>
01105 <span class="preprocessor">                        p[1] == CILEN_CBCP &amp;&amp; \</span>
01106 <span class="preprocessor">                        p[0] == opt) { \</span>
01107 <span class="preprocessor">                len -= CILEN_CBCP; \</span>
01108 <span class="preprocessor">                INCPTR(2, p); \</span>
01109 <span class="preprocessor">                GETCHAR(cichar, p); \</span>
01110 <span class="preprocessor">                </span><span class="comment">/* Check rejected value. */</span> \
01111                 if (cichar != val) \
01112                         goto bad; \
01113                 try.neg = 0; \
01114                 LCPDEBUG((LOG_INFO,"lcp_rejci: Callback opt %d rejected\n", opt)); \
01115         }
01116         
01117         REJCISHORT(CI_MRU, neg_mru, go-&gt;<a class="code" href="structlcp__options.html#o12">mru</a>);
01118         REJCILONG(CI_ASYNCMAP, neg_asyncmap, go-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a>);
01119         REJCICHAP(CI_AUTHTYPE, neg_chap, PPP_CHAP, go-&gt;<a class="code" href="structlcp__options.html#o13">chap_mdtype</a>);
01120         <span class="keywordflow">if</span> (!go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>) {
01121                 REJCISHORT(CI_AUTHTYPE, neg_upap, PPP_PAP);
01122         }
01123         REJCILQR(CI_QUALITY, neg_lqr, go-&gt;<a class="code" href="structlcp__options.html#o17">lqr_period</a>);
01124         REJCICBCP(CI_CALLBACK, neg_cbcp, CBCP_OPT);
01125         REJCILONG(CI_MAGICNUMBER, neg_magicnumber, go-&gt;<a class="code" href="structlcp__options.html#o15">magicnumber</a>);
01126         REJCIVOID(CI_PCOMPRESSION, neg_pcompression);
01127         REJCIVOID(CI_ACCOMPRESSION, neg_accompression);
01128         
01129         <span class="comment">/*</span>
01130 <span class="comment">        * If there are any remaining CIs, then this packet is bad.</span>
01131 <span class="comment">        */</span>
01132         <span class="keywordflow">if</span> (len != 0)
01133                 <span class="keywordflow">goto</span> bad;
01134         <span class="comment">/*</span>
01135 <span class="comment">        * Now we can update state.</span>
01136 <span class="comment">        */</span>
01137         <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structfsm.html#o2">state</a> != <a class="code" href="fsm_8h.html#a17">OPENED</a>)
01138                 *go = <span class="keywordflow">try</span>;
01139         <span class="keywordflow">return</span> 1;
01140         
01141 bad:
01142         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"lcp_rejci: received bad Reject!\n"</span>));
01143         <span class="keywordflow">return</span> 0;
01144 }
01145 
01146 
01147 <span class="comment">/*</span>
01148 <span class="comment"> * lcp_reqci - Check the peer's requested CIs and send appropriate response.</span>
01149 <span class="comment"> *</span>
01150 <span class="comment"> * Returns: CONFACK, CONFNAK or CONFREJ and input packet modified</span>
01151 <span class="comment"> * appropriately.  If reject_if_disagree is non-zero, doesn't return</span>
01152 <span class="comment"> * CONFNAK; returns CONFREJ if it can't return CONFACK.</span>
01153 <span class="comment"> */</span>
01154 <span class="keyword">static</span> <span class="keywordtype">int</span> lcp_reqci(<a class="code" href="structfsm.html">fsm</a> *f, 
01155                                                 u_char *inp,            <span class="comment">/* Requested CIs */</span>
01156                                                 <span class="keywordtype">int</span> *lenp,                      <span class="comment">/* Length of requested CIs */</span>
01157                                                 <span class="keywordtype">int</span> reject_if_disagree)
01158 {
01159         <a class="code" href="structlcp__options.html">lcp_options</a> *go = &amp;<a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
01160         <a class="code" href="structlcp__options.html">lcp_options</a> *ho = &amp;<a class="code" href="lcp_8h.html#a22">lcp_hisoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
01161         <a class="code" href="structlcp__options.html">lcp_options</a> *ao = &amp;<a class="code" href="lcp_8h.html#a21">lcp_allowoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
01162         u_char *cip, *next;                     <span class="comment">/* Pointer to current and next CIs */</span>
01163         <span class="keywordtype">int</span> cilen, citype, cichar;      <span class="comment">/* Parsed len, type, char value */</span>
01164         u_short cishort;                        <span class="comment">/* Parsed short value */</span>
01165         u32_t cilong;                   <span class="comment">/* Parse long value */</span>
01166         <span class="keywordtype">int</span> rc = <a class="code" href="fsm_8h.html#a2">CONFACK</a>;                       <span class="comment">/* Final packet return code */</span>
01167         <span class="keywordtype">int</span> orc;                                        <span class="comment">/* Individual option return code */</span>
01168         u_char *p;                                      <span class="comment">/* Pointer to next char to parse */</span>
01169         u_char *rejp;                           <span class="comment">/* Pointer to next char in reject frame */</span>
01170         u_char *nakp;                           <span class="comment">/* Pointer to next char in Nak frame */</span>
01171         <span class="keywordtype">int</span> l = *lenp;                          <span class="comment">/* Length left */</span>
01172 <span class="preprocessor">#if TRACELCP &gt; 0</span>
01173 <span class="preprocessor"></span>        <span class="keywordtype">char</span> traceBuf[80];
01174         <span class="keywordtype">int</span> traceNdx = 0;
01175 <span class="preprocessor">#endif</span>
01176 <span class="preprocessor"></span>        
01177         <span class="comment">/*</span>
01178 <span class="comment">         * Reset all his options.</span>
01179 <span class="comment">         */</span>
01180         BZERO(ho, <span class="keyword">sizeof</span>(*ho));
01181         
01182         <span class="comment">/*</span>
01183 <span class="comment">         * Process all his options.</span>
01184 <span class="comment">         */</span>
01185         next = inp;
01186         nakp = nak_buffer;
01187         rejp = inp;
01188         <span class="keywordflow">while</span> (l) {
01189                 orc = <a class="code" href="fsm_8h.html#a2">CONFACK</a>;                  <span class="comment">/* Assume success */</span>
01190                 cip = p = next;                 <span class="comment">/* Remember begining of CI */</span>
01191                 <span class="keywordflow">if</span> (l &lt; 2 ||                    <span class="comment">/* Not enough data for CI header or */</span>
01192                                 p[1] &lt; 2 ||                     <span class="comment">/*  CI length too small or */</span>
01193                                 p[1] &gt; l) {                     <span class="comment">/*  CI length too big? */</span>
01194                         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"lcp_reqci: bad CI length!\n"</span>));
01195                         orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;          <span class="comment">/* Reject bad CI */</span>
01196                         cilen = l;                      <span class="comment">/* Reject till end of packet */</span>
01197                         l = 0;                  <span class="comment">/* Don't loop again */</span>
01198                         citype = 0;
01199                         <span class="keywordflow">goto</span> endswitch;
01200                 }
01201                 GETCHAR(citype, p);             <span class="comment">/* Parse CI type */</span>
01202                 GETCHAR(cilen, p);              <span class="comment">/* Parse CI length */</span>
01203                 l -= cilen;                     <span class="comment">/* Adjust remaining length */</span>
01204                 next += cilen;                  <span class="comment">/* Step to next CI */</span>
01205                 
01206                 <span class="keywordflow">switch</span> (citype) {               <span class="comment">/* Check CI type */</span>
01207                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a0">CI_MRU</a>:
01208                         <span class="keywordflow">if</span> (!ao-&gt;<a class="code" href="structlcp__options.html#o3">neg_mru</a>) {             <span class="comment">/* Allow option? */</span>
01209                                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"lcp_reqci: Reject MRU - not allowed\n"</span>));
01210                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;          <span class="comment">/* Reject CI */</span>
01211                                 <span class="keywordflow">break</span>;
01212                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cilen != CILEN_SHORT) {      <span class="comment">/* Check CI length */</span>
01213                                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"lcp_reqci: Reject MRU - bad length\n"</span>));
01214                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;          <span class="comment">/* Reject CI */</span>
01215                                 <span class="keywordflow">break</span>;
01216                         }
01217                         GETSHORT(cishort, p);   <span class="comment">/* Parse MRU */</span>
01218                         
01219                         <span class="comment">/*</span>
01220 <span class="comment">                         * He must be able to receive at least our minimum.</span>
01221 <span class="comment">                         * No need to check a maximum.  If he sends a large number,</span>
01222 <span class="comment">                         * we'll just ignore it.</span>
01223 <span class="comment">                         */</span>
01224                         <span class="keywordflow">if</span> (cishort &lt; PPP_MINMRU) {
01225                                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"lcp_reqci: Nak - MRU too small\n"</span>));
01226                                 orc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;          <span class="comment">/* Nak CI */</span>
01227                                 PUTCHAR(CI_MRU, nakp);
01228                                 PUTCHAR(CILEN_SHORT, nakp);
01229                                 PUTSHORT(PPP_MINMRU, nakp);     <span class="comment">/* Give him a hint */</span>
01230                                 <span class="keywordflow">break</span>;
01231                         }
01232                         ho-&gt;<a class="code" href="structlcp__options.html#o3">neg_mru</a> = 1;                <span class="comment">/* Remember he sent MRU */</span>
01233                         ho-&gt;<a class="code" href="structlcp__options.html#o12">mru</a> = cishort;              <span class="comment">/* And remember value */</span>
01234 <span class="preprocessor">#if TRACELCP &gt; 0</span>
01235 <span class="preprocessor"></span>                        sprintf(&amp;traceBuf[traceNdx], <span class="stringliteral">" MRU %d"</span>, cishort);
01236                         traceNdx = strlen(traceBuf);
01237 <span class="preprocessor">#endif</span>
01238 <span class="preprocessor"></span>                        <span class="keywordflow">break</span>;
01239                 
01240                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a1">CI_ASYNCMAP</a>:
01241                         <span class="keywordflow">if</span> (!ao-&gt;<a class="code" href="structlcp__options.html#o4">neg_asyncmap</a>) {
01242                                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"lcp_reqci: Reject ASYNCMAP not allowed\n"</span>));
01243                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01244                                 <span class="keywordflow">break</span>;
01245                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cilen != CILEN_LONG) {
01246                                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"lcp_reqci: Reject ASYNCMAP bad length\n"</span>));
01247                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01248                                 <span class="keywordflow">break</span>;
01249                         }
01250                         GETLONG(cilong, p);
01251                         
01252                         <span class="comment">/*</span>
01253 <span class="comment">                         * Asyncmap must have set at least the bits</span>
01254 <span class="comment">                         * which are set in lcp_allowoptions[unit].asyncmap.</span>
01255 <span class="comment">                         */</span>
01256                         <span class="keywordflow">if</span> ((ao-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a> &amp; ~cilong) != 0) {
01257                                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"lcp_reqci: Nak ASYNCMAP %lX missing %lX\n"</span>, 
01258                                                         cilong, ao-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a>));
01259                                 orc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;
01260                                 PUTCHAR(CI_ASYNCMAP, nakp);
01261                                 PUTCHAR(CILEN_LONG, nakp);
01262                                 PUTLONG(ao-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a> | cilong, nakp);
01263                                 <span class="keywordflow">break</span>;
01264                         }
01265                         ho-&gt;<a class="code" href="structlcp__options.html#o4">neg_asyncmap</a> = 1;
01266                         ho-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a> = cilong;
01267 <span class="preprocessor">#if TRACELCP &gt; 0</span>
01268 <span class="preprocessor"></span>                        sprintf(&amp;traceBuf[traceNdx], <span class="stringliteral">" ASYNCMAP=%lX"</span>, cilong);
01269                         traceNdx = strlen(traceBuf);
01270 <span class="preprocessor">#endif</span>
01271 <span class="preprocessor"></span>                        <span class="keywordflow">break</span>;
01272                 
01273                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a2">CI_AUTHTYPE</a>:
01274                         <span class="keywordflow">if</span> (cilen &lt; CILEN_SHORT) {
01275                                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"lcp_reqci: Reject AUTHTYPE missing arg\n"</span>));
01276                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01277                                 <span class="keywordflow">break</span>;
01278                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(ao-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a> || ao-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>)) {
01279                                 <span class="comment">/*</span>
01280 <span class="comment">                                 * Reject the option if we're not willing to authenticate.</span>
01281 <span class="comment">                                 */</span>
01282                                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"lcp_reqci: Reject AUTHTYPE not allowed\n"</span>));
01283                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01284                                 <span class="keywordflow">break</span>;
01285                         }
01286                         GETSHORT(cishort, p);
01287                         
01288                         <span class="comment">/*</span>
01289 <span class="comment">                         * Authtype must be UPAP or CHAP.</span>
01290 <span class="comment">                         *</span>
01291 <span class="comment">                         * Note: if both ao-&gt;neg_upap and ao-&gt;neg_chap are set,</span>
01292 <span class="comment">                         * and the peer sends a Configure-Request with two</span>
01293 <span class="comment">                         * authenticate-protocol requests, one for CHAP and one</span>
01294 <span class="comment">                         * for UPAP, then we will reject the second request.</span>
01295 <span class="comment">                         * Whether we end up doing CHAP or UPAP depends then on</span>
01296 <span class="comment">                         * the ordering of the CIs in the peer's Configure-Request.</span>
01297 <span class="comment">                         */</span>
01298                         
01299                         <span class="keywordflow">if</span> (cishort == PPP_PAP) {
01300                                 <span class="keywordflow">if</span> (ho-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>) {     <span class="comment">/* we've already accepted CHAP */</span>
01301                                         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"lcp_reqci: Reject AUTHTYPE PAP already accepted\n"</span>));
01302                                         orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01303                                         <span class="keywordflow">break</span>;
01304                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cilen != CILEN_SHORT) {
01305                                         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"lcp_reqci: Reject AUTHTYPE PAP bad len\n"</span>));
01306                                         orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01307                                         <span class="keywordflow">break</span>;
01308                                 }
01309                                 <span class="keywordflow">if</span> (!ao-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a>) {    <span class="comment">/* we don't want to do PAP */</span>
01310                                         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"lcp_reqci: Nak AUTHTYPE PAP not allowed\n"</span>));
01311                                         orc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;  <span class="comment">/* NAK it and suggest CHAP */</span>
01312                                         PUTCHAR(CI_AUTHTYPE, nakp);
01313                                         PUTCHAR(CILEN_CHAP, nakp);
01314                                         PUTSHORT(PPP_CHAP, nakp);
01315                                         PUTCHAR(ao-&gt;<a class="code" href="structlcp__options.html#o13">chap_mdtype</a>, nakp);
01316                                         <span class="keywordflow">break</span>;
01317                                 }
01318                                 ho-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a> = 1;
01319 <span class="preprocessor">#if TRACELCP &gt; 0</span>
01320 <span class="preprocessor"></span>                                sprintf(&amp;traceBuf[traceNdx], <span class="stringliteral">" PAP (%X)"</span>, cishort);
01321                                 traceNdx = strlen(traceBuf);
01322 <span class="preprocessor">#endif</span>
01323 <span class="preprocessor"></span>                                <span class="keywordflow">break</span>;
01324                         }
01325                         <span class="keywordflow">if</span> (cishort == PPP_CHAP) {
01326                                 <span class="keywordflow">if</span> (ho-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a>) {     <span class="comment">/* we've already accepted PAP */</span>
01327                                         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"lcp_reqci: Reject AUTHTYPE CHAP accepted PAP\n"</span>));
01328                                         orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01329                                         <span class="keywordflow">break</span>;
01330                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cilen != CILEN_CHAP) {
01331                                         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"lcp_reqci: Reject AUTHTYPE CHAP bad len\n"</span>));
01332                                         orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01333                                         <span class="keywordflow">break</span>;
01334                                 }
01335                                 <span class="keywordflow">if</span> (!ao-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>) {    <span class="comment">/* we don't want to do CHAP */</span>
01336                                         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"lcp_reqci: Nak AUTHTYPE CHAP not allowed\n"</span>));
01337                                         orc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;  <span class="comment">/* NAK it and suggest PAP */</span>
01338                                         PUTCHAR(CI_AUTHTYPE, nakp);
01339                                         PUTCHAR(CILEN_SHORT, nakp);
01340                                         PUTSHORT(PPP_PAP, nakp);
01341                                         <span class="keywordflow">break</span>;
01342                                 }
01343                                 GETCHAR(cichar, p);     <span class="comment">/* get digest type*/</span>
01344                                 <span class="keywordflow">if</span> (cichar != <a class="code" href="chap_8h.html#a1">CHAP_DIGEST_MD5</a>
01345 <span class="preprocessor">#ifdef CHAPMS</span>
01346 <span class="preprocessor"></span>                                                &amp;&amp; cichar != <a class="code" href="chap_8h.html#a3">CHAP_MICROSOFT</a>
01347 <span class="preprocessor">#endif</span>
01348 <span class="preprocessor"></span>                                ) {
01349                                         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"lcp_reqci: Nak AUTHTYPE CHAP digest=%d\n"</span>, cichar));
01350                                         orc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;
01351                                         PUTCHAR(CI_AUTHTYPE, nakp);
01352                                         PUTCHAR(CILEN_CHAP, nakp);
01353                                         PUTSHORT(PPP_CHAP, nakp);
01354                                         PUTCHAR(ao-&gt;<a class="code" href="structlcp__options.html#o13">chap_mdtype</a>, nakp);
01355                                         <span class="keywordflow">break</span>;
01356                                 }
01357 <span class="preprocessor">#if TRACELCP &gt; 0</span>
01358 <span class="preprocessor"></span>                                sprintf(&amp;traceBuf[traceNdx], <span class="stringliteral">" CHAP %X,%d"</span>, cishort, cichar);
01359                                 traceNdx = strlen(traceBuf);
01360 <span class="preprocessor">#endif</span>
01361 <span class="preprocessor"></span>                                ho-&gt;<a class="code" href="structlcp__options.html#o13">chap_mdtype</a> = cichar; <span class="comment">/* save md type */</span>
01362                                 ho-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a> = 1;
01363                                 <span class="keywordflow">break</span>;
01364                         }
01365                         
01366                         <span class="comment">/*</span>
01367 <span class="comment">                         * We don't recognize the protocol they're asking for.</span>
01368 <span class="comment">                         * Nak it with something we're willing to do.</span>
01369 <span class="comment">                         * (At this point we know ao-&gt;neg_upap || ao-&gt;neg_chap.)</span>
01370 <span class="comment">                         */</span>
01371                         orc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;
01372                         PUTCHAR(CI_AUTHTYPE, nakp);
01373                         <span class="keywordflow">if</span> (ao-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>) {
01374                                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"lcp_reqci: Nak AUTHTYPE %d req CHAP\n"</span>, cishort));
01375                                 PUTCHAR(CILEN_CHAP, nakp);
01376                                 PUTSHORT(PPP_CHAP, nakp);
01377                                 PUTCHAR(ao-&gt;<a class="code" href="structlcp__options.html#o13">chap_mdtype</a>, nakp);
01378                         } 
01379                         <span class="keywordflow">else</span> {
01380                                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"lcp_reqci: Nak AUTHTYPE %d req PAP\n"</span>, cishort));
01381                                 PUTCHAR(CILEN_SHORT, nakp);
01382                                 PUTSHORT(PPP_PAP, nakp);
01383                         }
01384                         <span class="keywordflow">break</span>;
01385                 
01386                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a3">CI_QUALITY</a>:
01387                         GETSHORT(cishort, p);
01388                         GETLONG(cilong, p);
01389 <span class="preprocessor">#if TRACELCP &gt; 0</span>
01390 <span class="preprocessor"></span>                        sprintf(&amp;traceBuf[traceNdx], <span class="stringliteral">" QUALITY (%x %x)"</span>, cishort, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) cilong);
01391                         traceNdx = strlen(traceBuf);
01392 <span class="preprocessor">#endif</span>
01393 <span class="preprocessor"></span>
01394                         <span class="keywordflow">if</span> (!ao-&gt;<a class="code" href="structlcp__options.html#o10">neg_lqr</a> ||
01395                                         cilen != CILEN_LQR) {
01396                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01397                                 <span class="keywordflow">break</span>;
01398                         }
01399                         
01400                         <span class="comment">/*</span>
01401 <span class="comment">                         * Check the protocol and the reporting period.</span>
01402 <span class="comment">                         * XXX When should we Nak this, and what with?</span>
01403 <span class="comment">                         */</span>
01404                         <span class="keywordflow">if</span> (cishort != PPP_LQR) {
01405                                 orc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;
01406                                 PUTCHAR(CI_QUALITY, nakp);
01407                                 PUTCHAR(CILEN_LQR, nakp);
01408                                 PUTSHORT(PPP_LQR, nakp);
01409                                 PUTLONG(ao-&gt;<a class="code" href="structlcp__options.html#o17">lqr_period</a>, nakp);
01410                                 <span class="keywordflow">break</span>;
01411                         }
01412                         <span class="keywordflow">break</span>;
01413                 
01414                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a4">CI_MAGICNUMBER</a>:
01415                         <span class="keywordflow">if</span> (!(ao-&gt;<a class="code" href="structlcp__options.html#o7">neg_magicnumber</a> || go-&gt;<a class="code" href="structlcp__options.html#o7">neg_magicnumber</a>) ||
01416                                         cilen != CILEN_LONG) {
01417                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01418                                 <span class="keywordflow">break</span>;
01419                         }
01420                         GETLONG(cilong, p);
01421 <span class="preprocessor">#if TRACELCP &gt; 0</span>
01422 <span class="preprocessor"></span>                        sprintf(&amp;traceBuf[traceNdx], <span class="stringliteral">" MAGICNUMBER (%lX)"</span>, cilong);
01423                         traceNdx = strlen(traceBuf);
01424 <span class="preprocessor">#endif</span>
01425 <span class="preprocessor"></span>
01426                         <span class="comment">/*</span>
01427 <span class="comment">                         * He must have a different magic number.</span>
01428 <span class="comment">                         */</span>
01429                         <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structlcp__options.html#o7">neg_magicnumber</a> &amp;&amp;
01430                                         cilong == go-&gt;<a class="code" href="structlcp__options.html#o15">magicnumber</a>) {
01431                                 cilong = <a class="code" href="magic_8c.html#a1">magic</a>();       <span class="comment">/* Don't put magic() inside macro! */</span>
01432                                 orc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;
01433                                 PUTCHAR(CI_MAGICNUMBER, nakp);
01434                                 PUTCHAR(CILEN_LONG, nakp);
01435                                 PUTLONG(cilong, nakp);
01436                                 <span class="keywordflow">break</span>;
01437                         }
01438                         ho-&gt;<a class="code" href="structlcp__options.html#o7">neg_magicnumber</a> = 1;
01439                         ho-&gt;<a class="code" href="structlcp__options.html#o15">magicnumber</a> = cilong;
01440                         <span class="keywordflow">break</span>;
01441                 
01442                 
01443                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a5">CI_PCOMPRESSION</a>:
01444 <span class="preprocessor">#if TRACELCP &gt; 0</span>
01445 <span class="preprocessor"></span>                        sprintf(&amp;traceBuf[traceNdx], <span class="stringliteral">" PCOMPRESSION"</span>);
01446                         traceNdx = strlen(traceBuf);
01447 <span class="preprocessor">#endif</span>
01448 <span class="preprocessor"></span>                        <span class="keywordflow">if</span> (!ao-&gt;<a class="code" href="structlcp__options.html#o8">neg_pcompression</a> ||
01449                                         cilen != CILEN_VOID) {
01450                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01451                                 <span class="keywordflow">break</span>;
01452                         }
01453                         ho-&gt;<a class="code" href="structlcp__options.html#o8">neg_pcompression</a> = 1;
01454                         <span class="keywordflow">break</span>;
01455                 
01456                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a6">CI_ACCOMPRESSION</a>:
01457 <span class="preprocessor">#if TRACELCP &gt; 0</span>
01458 <span class="preprocessor"></span>                        sprintf(&amp;traceBuf[traceNdx], <span class="stringliteral">" ACCOMPRESSION"</span>);
01459                         traceNdx = strlen(traceBuf);
01460 <span class="preprocessor">#endif</span>
01461 <span class="preprocessor"></span>                        <span class="keywordflow">if</span> (!ao-&gt;<a class="code" href="structlcp__options.html#o9">neg_accompression</a> ||
01462                                         cilen != CILEN_VOID) {
01463                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01464                                 <span class="keywordflow">break</span>;
01465                         }
01466                         ho-&gt;<a class="code" href="structlcp__options.html#o9">neg_accompression</a> = 1;
01467                         <span class="keywordflow">break</span>;
01468                 
01469                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a8">CI_MRRU</a>:
01470 <span class="preprocessor">#if TRACELCP &gt; 0</span>
01471 <span class="preprocessor"></span>                        sprintf(&amp;traceBuf[traceNdx], <span class="stringliteral">" CI_MRRU"</span>);
01472                         traceNdx = strlen(traceBuf);
01473 <span class="preprocessor">#endif</span>
01474 <span class="preprocessor"></span>                        orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01475                         <span class="keywordflow">break</span>;
01476                 
01477                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a9">CI_SSNHF</a>:
01478 <span class="preprocessor">#if TRACELCP &gt; 0</span>
01479 <span class="preprocessor"></span>                        sprintf(&amp;traceBuf[traceNdx], <span class="stringliteral">" CI_SSNHF"</span>);
01480                         traceNdx = strlen(traceBuf);
01481 <span class="preprocessor">#endif</span>
01482 <span class="preprocessor"></span>                        orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01483                         <span class="keywordflow">break</span>;
01484                 
01485                 <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a10">CI_EPDISC</a>:
01486 <span class="preprocessor">#if TRACELCP &gt; 0</span>
01487 <span class="preprocessor"></span>                        sprintf(&amp;traceBuf[traceNdx], <span class="stringliteral">" CI_EPDISC"</span>);
01488                         traceNdx = strlen(traceBuf);
01489 <span class="preprocessor">#endif</span>
01490 <span class="preprocessor"></span>                        orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01491                         <span class="keywordflow">break</span>;
01492                 
01493                 <span class="keywordflow">default</span>:
01494 <span class="preprocessor">#if TRACELCP</span>
01495 <span class="preprocessor"></span>                        sprintf(&amp;traceBuf[traceNdx], <span class="stringliteral">" unknown %d"</span>, citype);
01496                         traceNdx = strlen(traceBuf);
01497 <span class="preprocessor">#endif</span>
01498 <span class="preprocessor"></span>                        orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01499                         <span class="keywordflow">break</span>;
01500                 }
01501                 
01502         endswitch:
01503 <span class="preprocessor">#if TRACELCP</span>
01504 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (traceNdx &gt;= 80 - 32) {
01505                         <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"lcp_reqci: rcvd%s\n"</span>, traceBuf));
01506                         traceNdx = 0;
01507                 }
01508 <span class="preprocessor">#endif</span>
01509 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (orc == <a class="code" href="fsm_8h.html#a2">CONFACK</a> &amp;&amp;           <span class="comment">/* Good CI */</span>
01510                                 rc != <a class="code" href="fsm_8h.html#a2">CONFACK</a>)          <span class="comment">/*  but prior CI wasnt? */</span>
01511                         <span class="keywordflow">continue</span>;                       <span class="comment">/* Don't send this one */</span>
01512                 
01513                 <span class="keywordflow">if</span> (orc == <a class="code" href="fsm_8h.html#a3">CONFNAK</a>) {           <span class="comment">/* Nak this CI? */</span>
01514                         <span class="keywordflow">if</span> (reject_if_disagree  <span class="comment">/* Getting fed up with sending NAKs? */</span>
01515                                         &amp;&amp; citype != <a class="code" href="lcp_8h.html#a4">CI_MAGICNUMBER</a>) {
01516                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;          <span class="comment">/* Get tough if so */</span>
01517                         } 
01518                         <span class="keywordflow">else</span> {
01519                                 <span class="keywordflow">if</span> (rc == <a class="code" href="fsm_8h.html#a4">CONFREJ</a>)      <span class="comment">/* Rejecting prior CI? */</span>
01520                                         <span class="keywordflow">continue</span>;               <span class="comment">/* Don't send this one */</span>
01521                                 rc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;
01522                         }
01523                 }
01524                 <span class="keywordflow">if</span> (orc == <a class="code" href="fsm_8h.html#a4">CONFREJ</a>) {           <span class="comment">/* Reject this CI */</span>
01525                         rc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01526                         <span class="keywordflow">if</span> (cip != rejp)                <span class="comment">/* Need to move rejected CI? */</span>
01527                                 BCOPY(cip, rejp, cilen); <span class="comment">/* Move it */</span>
01528                         INCPTR(cilen, rejp);    <span class="comment">/* Update output pointer */</span>
01529                 }
01530         }
01531         
01532         <span class="comment">/*</span>
01533 <span class="comment">         * If we wanted to send additional NAKs (for unsent CIs), the</span>
01534 <span class="comment">         * code would go here.  The extra NAKs would go at *nakp.</span>
01535 <span class="comment">         * At present there are no cases where we want to ask the</span>
01536 <span class="comment">         * peer to negotiate an option.</span>
01537 <span class="comment">         */</span>
01538         
01539         <span class="keywordflow">switch</span> (rc) {
01540         <span class="keywordflow">case</span> <a class="code" href="fsm_8h.html#a2">CONFACK</a>:
01541                 *lenp = (<span class="keywordtype">int</span>)(next - inp);
01542                 <span class="keywordflow">break</span>;
01543         <span class="keywordflow">case</span> <a class="code" href="fsm_8h.html#a3">CONFNAK</a>:
01544                 <span class="comment">/*</span>
01545 <span class="comment">                 * Copy the Nak'd options from the nak_buffer to the caller's buffer.</span>
01546 <span class="comment">                 */</span>
01547                 *lenp = (<span class="keywordtype">int</span>)(nakp - nak_buffer);
01548                 BCOPY(nak_buffer, inp, *lenp);
01549                 <span class="keywordflow">break</span>;
01550         <span class="keywordflow">case</span> <a class="code" href="fsm_8h.html#a4">CONFREJ</a>:
01551                 *lenp = (<span class="keywordtype">int</span>)(rejp - inp);
01552                 <span class="keywordflow">break</span>;
01553         }
01554         
01555 <span class="preprocessor">#if TRACELCP &gt; 0</span>
01556 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (traceNdx &gt; 0) {
01557                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"lcp_reqci: %s\n"</span>, traceBuf));
01558         }
01559 <span class="preprocessor">#endif</span>
01560 <span class="preprocessor"></span>        <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"lcp_reqci: returning CONF%s.\n"</span>, CODENAME(rc)));
01561         <span class="keywordflow">return</span> (rc);                    <span class="comment">/* Return final code */</span>
01562 }
01563 
01564 
01565 <span class="comment">/*</span>
01566 <span class="comment"> * lcp_up - LCP has come UP.</span>
01567 <span class="comment"> */</span>
01568 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_up(<a class="code" href="structfsm.html">fsm</a> *f)
01569 {
01570         <a class="code" href="structlcp__options.html">lcp_options</a> *wo = &amp;<a class="code" href="lcp_8h.html#a19">lcp_wantoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
01571         <a class="code" href="structlcp__options.html">lcp_options</a> *ho = &amp;<a class="code" href="lcp_8h.html#a22">lcp_hisoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
01572         <a class="code" href="structlcp__options.html">lcp_options</a> *go = &amp;<a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
01573         <a class="code" href="structlcp__options.html">lcp_options</a> *ao = &amp;<a class="code" href="lcp_8h.html#a21">lcp_allowoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
01574         
01575         <span class="keywordflow">if</span> (!go-&gt;<a class="code" href="structlcp__options.html#o7">neg_magicnumber</a>)
01576                 go-&gt;<a class="code" href="structlcp__options.html#o15">magicnumber</a> = 0;
01577         <span class="keywordflow">if</span> (!ho-&gt;<a class="code" href="structlcp__options.html#o7">neg_magicnumber</a>)
01578                 ho-&gt;<a class="code" href="structlcp__options.html#o15">magicnumber</a> = 0;
01579         
01580         <span class="comment">/*</span>
01581 <span class="comment">        * Set our MTU to the smaller of the MTU we wanted and</span>
01582 <span class="comment">        * the MRU our peer wanted.  If we negotiated an MRU,</span>
01583 <span class="comment">        * set our MRU to the larger of value we wanted and</span>
01584 <span class="comment">        * the value we got in the negotiation.</span>
01585 <span class="comment">        */</span>
01586         ppp_send_config(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, <a class="code" href="def_8h.html#a1">LWIP_MIN</a>(ao-&gt;<a class="code" href="structlcp__options.html#o12">mru</a>, (ho-&gt;<a class="code" href="structlcp__options.html#o3">neg_mru</a>? ho-&gt;<a class="code" href="structlcp__options.html#o12">mru</a>: PPP_MRU)),
01587                                 (ho-&gt;<a class="code" href="structlcp__options.html#o4">neg_asyncmap</a>? ho-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a>: 0xffffffffl),
01588                                 ho-&gt;<a class="code" href="structlcp__options.html#o8">neg_pcompression</a>, ho-&gt;<a class="code" href="structlcp__options.html#o9">neg_accompression</a>);
01589         <span class="comment">/*</span>
01590 <span class="comment">        * If the asyncmap hasn't been negotiated, we really should</span>
01591 <span class="comment">        * set the receive asyncmap to ffffffff, but we set it to 0</span>
01592 <span class="comment">        * for backwards contemptibility.</span>
01593 <span class="comment">        */</span>
01594         ppp_recv_config(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, (go-&gt;<a class="code" href="structlcp__options.html#o3">neg_mru</a>? <a class="code" href="def_8h.html#a0">LWIP_MAX</a>(wo-&gt;<a class="code" href="structlcp__options.html#o12">mru</a>, go-&gt;<a class="code" href="structlcp__options.html#o12">mru</a>): PPP_MRU),
01595                                 (go-&gt;<a class="code" href="structlcp__options.html#o4">neg_asyncmap</a>? go-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a>: 0x00000000),
01596                                 go-&gt;<a class="code" href="structlcp__options.html#o8">neg_pcompression</a>, go-&gt;<a class="code" href="structlcp__options.html#o9">neg_accompression</a>);
01597         
01598         <span class="keywordflow">if</span> (ho-&gt;<a class="code" href="structlcp__options.html#o3">neg_mru</a>)
01599                 <a class="code" href="fsm_8h.html#a23">peer_mru</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>] = ho-&gt;<a class="code" href="structlcp__options.html#o12">mru</a>;
01600         
01601         lcp_echo_lowerup(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>);  <span class="comment">/* Enable echo messages */</span>
01602         
01603         <a class="code" href="auth_8h.html#a3">link_established</a>(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>);
01604 }
01605 
01606 
01607 <span class="comment">/*</span>
01608 <span class="comment"> * lcp_down - LCP has gone DOWN.</span>
01609 <span class="comment"> *</span>
01610 <span class="comment"> * Alert other protocols.</span>
01611 <span class="comment"> */</span>
01612 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_down(<a class="code" href="structfsm.html">fsm</a> *f)
01613 {
01614         <a class="code" href="structlcp__options.html">lcp_options</a> *go = &amp;<a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
01615         
01616         lcp_echo_lowerdown(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>);
01617         
01618         <a class="code" href="auth_8h.html#a2">link_down</a>(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>);
01619         
01620         ppp_send_config(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, PPP_MRU, 0xffffffffl, 0, 0);
01621         ppp_recv_config(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, PPP_MRU,
01622                                 (go-&gt;<a class="code" href="structlcp__options.html#o4">neg_asyncmap</a>? go-&gt;<a class="code" href="structlcp__options.html#o14">asyncmap</a>: 0x00000000),
01623                                 go-&gt;<a class="code" href="structlcp__options.html#o8">neg_pcompression</a>, go-&gt;<a class="code" href="structlcp__options.html#o9">neg_accompression</a>);
01624         <a class="code" href="fsm_8h.html#a23">peer_mru</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>] = PPP_MRU;
01625 }
01626 
01627 
01628 <span class="comment">/*</span>
01629 <span class="comment"> * lcp_starting - LCP needs the lower layer up.</span>
01630 <span class="comment"> */</span>
01631 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_starting(<a class="code" href="structfsm.html">fsm</a> *f)
01632 {
01633         <a class="code" href="auth_8h.html#a0">link_required</a>(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>);
01634 }
01635 
01636 
01637 <span class="comment">/*</span>
01638 <span class="comment"> * lcp_finished - LCP has finished with the lower layer.</span>
01639 <span class="comment"> */</span>
01640 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_finished(<a class="code" href="structfsm.html">fsm</a> *f)
01641 {
01642         <a class="code" href="auth_8h.html#a1">link_terminated</a>(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>);
01643 }
01644 
01645 
01646 <span class="preprocessor">#if 0</span>
01647 <span class="preprocessor"></span><span class="comment">/*</span>
01648 <span class="comment"> * print_string - print a readable representation of a string using</span>
01649 <span class="comment"> * printer.</span>
01650 <span class="comment"> */</span>
01651 <span class="keyword">static</span> <span class="keywordtype">void</span> print_string(
01652     <span class="keywordtype">char</span> *p,
01653     <span class="keywordtype">int</span> len,
01654     <span class="keywordtype">void</span> (*printer) (<span class="keywordtype">void</span> *, <span class="keywordtype">char</span> *, ...),
01655     <span class="keywordtype">void</span> *arg
01656 )
01657 {
01658     <span class="keywordtype">int</span> c;
01659     
01660     printer(arg, <span class="stringliteral">"\""</span>);
01661     <span class="keywordflow">for</span> (; len &gt; 0; --len) {
01662         c = *p++;
01663         <span class="keywordflow">if</span> (<span class="charliteral">' '</span> &lt;= c &amp;&amp; c &lt;= <span class="charliteral">'~'</span>) {
01664             <span class="keywordflow">if</span> (c == <span class="charliteral">'\\'</span> || c == <span class="charliteral">'"'</span>)
01665                 printer(arg, <span class="stringliteral">"\\"</span>);
01666             printer(arg, <span class="stringliteral">"%c"</span>, c);
01667         } <span class="keywordflow">else</span> {
01668             <span class="keywordflow">switch</span> (c) {
01669             <span class="keywordflow">case</span> <span class="charliteral">'\n'</span>:
01670                 printer(arg, <span class="stringliteral">"\\n"</span>);
01671                 <span class="keywordflow">break</span>;
01672             <span class="keywordflow">case</span> <span class="charliteral">'\r'</span>:
01673                 printer(arg, <span class="stringliteral">"\\r"</span>);
01674                 <span class="keywordflow">break</span>;
01675             <span class="keywordflow">case</span> <span class="charliteral">'\t'</span>:
01676                 printer(arg, <span class="stringliteral">"\\t"</span>);
01677                 <span class="keywordflow">break</span>;
01678             <span class="keywordflow">default</span>:
01679                 printer(arg, <span class="stringliteral">"\\%.3o"</span>, c);
01680             }
01681         }
01682     }
01683     printer(arg, <span class="stringliteral">"\""</span>);
01684 }
01685 
01686 
01687 <span class="comment">/*</span>
01688 <span class="comment"> * lcp_printpkt - print the contents of an LCP packet.</span>
01689 <span class="comment"> */</span>
01690 <span class="keyword">static</span> <span class="keywordtype">char</span> *lcp_codenames[] = {
01691         <span class="stringliteral">"ConfReq"</span>, <span class="stringliteral">"ConfAck"</span>, <span class="stringliteral">"ConfNak"</span>, <span class="stringliteral">"ConfRej"</span>,
01692         <span class="stringliteral">"TermReq"</span>, <span class="stringliteral">"TermAck"</span>, <span class="stringliteral">"CodeRej"</span>, <span class="stringliteral">"ProtRej"</span>,
01693         <span class="stringliteral">"EchoReq"</span>, <span class="stringliteral">"EchoRep"</span>, <span class="stringliteral">"DiscReq"</span>
01694 };
01695 
01696 <span class="keyword">static</span> <span class="keywordtype">int</span> lcp_printpkt(
01697         u_char *p,
01698         <span class="keywordtype">int</span> plen,
01699         <span class="keywordtype">void</span> (*printer) (<span class="keywordtype">void</span> *, <span class="keywordtype">char</span> *, ...),
01700         <span class="keywordtype">void</span> *arg
01701 )
01702 {
01703         <span class="keywordtype">int</span> code, id, len, olen;
01704         u_char *pstart, *optend;
01705         u_short cishort;
01706         u32_t cilong;
01707         
01708         <span class="keywordflow">if</span> (plen &lt; <a class="code" href="fsm_8h.html#a0">HEADERLEN</a>)
01709                 <span class="keywordflow">return</span> 0;
01710         pstart = p;
01711         GETCHAR(code, p);
01712         GETCHAR(id, p);
01713         GETSHORT(len, p);
01714         <span class="keywordflow">if</span> (len &lt; HEADERLEN || len &gt; plen)
01715                 <span class="keywordflow">return</span> 0;
01716         
01717         <span class="keywordflow">if</span> (code &gt;= 1 &amp;&amp; code &lt;= <span class="keyword">sizeof</span>(lcp_codenames) / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *))
01718                 printer(arg, <span class="stringliteral">" %s"</span>, lcp_codenames[code-1]);
01719         <span class="keywordflow">else</span>
01720                 printer(arg, <span class="stringliteral">" code=0x%x"</span>, code);
01721         printer(arg, <span class="stringliteral">" id=0x%x"</span>, id);
01722         len -= <a class="code" href="fsm_8h.html#a0">HEADERLEN</a>;
01723         <span class="keywordflow">switch</span> (code) {
01724         <span class="keywordflow">case</span> <a class="code" href="fsm_8h.html#a1">CONFREQ</a>:
01725         <span class="keywordflow">case</span> <a class="code" href="fsm_8h.html#a2">CONFACK</a>:
01726         <span class="keywordflow">case</span> <a class="code" href="fsm_8h.html#a3">CONFNAK</a>:
01727         <span class="keywordflow">case</span> <a class="code" href="fsm_8h.html#a4">CONFREJ</a>:
01728                 <span class="comment">/* print option list */</span>
01729                 <span class="keywordflow">while</span> (len &gt;= 2) {
01730                         GETCHAR(code, p);
01731                         GETCHAR(olen, p);
01732                         p -= 2;
01733                         <span class="keywordflow">if</span> (olen &lt; 2 || olen &gt; len) {
01734                                 <span class="keywordflow">break</span>;
01735                         }
01736                         printer(arg, <span class="stringliteral">" &lt;"</span>);
01737                         len -= olen;
01738                         optend = p + olen;
01739                         <span class="keywordflow">switch</span> (code) {
01740                         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a0">CI_MRU</a>:
01741                                 <span class="keywordflow">if</span> (olen == CILEN_SHORT) {
01742                                         p += 2;
01743                                         GETSHORT(cishort, p);
01744                                         printer(arg, <span class="stringliteral">"mru %d"</span>, cishort);
01745                                 }
01746                                 <span class="keywordflow">break</span>;
01747                         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a1">CI_ASYNCMAP</a>:
01748                                 <span class="keywordflow">if</span> (olen == CILEN_LONG) {
01749                                         p += 2;
01750                                         GETLONG(cilong, p);
01751                                         printer(arg, <span class="stringliteral">"asyncmap 0x%lx"</span>, cilong);
01752                                 }
01753                                 <span class="keywordflow">break</span>;
01754                         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a2">CI_AUTHTYPE</a>:
01755                                 <span class="keywordflow">if</span> (olen &gt;= CILEN_SHORT) {
01756                                         p += 2;
01757                                         printer(arg, <span class="stringliteral">"auth "</span>);
01758                                         GETSHORT(cishort, p);
01759                                         <span class="keywordflow">switch</span> (cishort) {
01760                                         <span class="keywordflow">case</span> PPP_PAP:
01761                                                 printer(arg, <span class="stringliteral">"pap"</span>);
01762                                                 <span class="keywordflow">break</span>;
01763                                         <span class="keywordflow">case</span> PPP_CHAP:
01764                                                 printer(arg, <span class="stringliteral">"chap"</span>);
01765                                                 <span class="keywordflow">break</span>;
01766                                         <span class="keywordflow">default</span>:
01767                                                 printer(arg, <span class="stringliteral">"0x%x"</span>, cishort);
01768                                         }
01769                                 }
01770                                 <span class="keywordflow">break</span>;
01771                         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a3">CI_QUALITY</a>:
01772                                 <span class="keywordflow">if</span> (olen &gt;= CILEN_SHORT) {
01773                                         p += 2;
01774                                         printer(arg, <span class="stringliteral">"quality "</span>);
01775                                         GETSHORT(cishort, p);
01776                                         <span class="keywordflow">switch</span> (cishort) {
01777                                         <span class="keywordflow">case</span> PPP_LQR:
01778                                                 printer(arg, <span class="stringliteral">"lqr"</span>);
01779                                                 <span class="keywordflow">break</span>;
01780                                         <span class="keywordflow">default</span>:
01781                                                 printer(arg, <span class="stringliteral">"0x%x"</span>, cishort);
01782                                         }
01783                                 }
01784                                 <span class="keywordflow">break</span>;
01785                         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a7">CI_CALLBACK</a>:
01786                                 <span class="keywordflow">if</span> (olen &gt;= CILEN_CHAR) {
01787                                         p += 2;
01788                                         printer(arg, <span class="stringliteral">"callback "</span>);
01789                                         GETSHORT(cishort, p);
01790                                         <span class="keywordflow">switch</span> (cishort) {
01791                                         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a15">CBCP_OPT</a>:
01792                                                 printer(arg, <span class="stringliteral">"CBCP"</span>);
01793                                                 <span class="keywordflow">break</span>;
01794                                         <span class="keywordflow">default</span>:
01795                                                 printer(arg, <span class="stringliteral">"0x%x"</span>, cishort);
01796                                         }
01797                                 }
01798                                 <span class="keywordflow">break</span>;
01799                         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a4">CI_MAGICNUMBER</a>:
01800                                 <span class="keywordflow">if</span> (olen == CILEN_LONG) {
01801                                         p += 2;
01802                                         GETLONG(cilong, p);
01803                                         printer(arg, <span class="stringliteral">"magic 0x%x"</span>, cilong);
01804                                 }
01805                                 <span class="keywordflow">break</span>;
01806                         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a5">CI_PCOMPRESSION</a>:
01807                                 <span class="keywordflow">if</span> (olen == CILEN_VOID) {
01808                                         p += 2;
01809                                         printer(arg, <span class="stringliteral">"pcomp"</span>);
01810                                 }
01811                                 <span class="keywordflow">break</span>;
01812                         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a6">CI_ACCOMPRESSION</a>:
01813                                 <span class="keywordflow">if</span> (olen == CILEN_VOID) {
01814                                         p += 2;
01815                                         printer(arg, <span class="stringliteral">"accomp"</span>);
01816                                 }
01817                                 <span class="keywordflow">break</span>;
01818                         }
01819                         <span class="keywordflow">while</span> (p &lt; optend) {
01820                                 GETCHAR(code, p);
01821                                 printer(arg, <span class="stringliteral">" %.2x"</span>, code);
01822                         }
01823                         printer(arg, <span class="stringliteral">"&gt;"</span>);
01824                 }
01825                 <span class="keywordflow">break</span>;
01826         
01827         <span class="keywordflow">case</span> <a class="code" href="fsm_8h.html#a6">TERMACK</a>:
01828         <span class="keywordflow">case</span> <a class="code" href="fsm_8h.html#a5">TERMREQ</a>:
01829                 <span class="keywordflow">if</span> (len &gt; 0 &amp;&amp; *p &gt;= <span class="charliteral">' '</span> &amp;&amp; *p &lt; 0x7f) {
01830                         printer(arg, <span class="stringliteral">" "</span>);
01831                         print_string((<span class="keywordtype">char</span>*)p, len, printer, arg);
01832                         p += len;
01833                         len = 0;
01834                 }
01835                 <span class="keywordflow">break</span>;
01836         
01837         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a12">ECHOREQ</a>:
01838         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a13">ECHOREP</a>:
01839         <span class="keywordflow">case</span> <a class="code" href="lcp_8h.html#a14">DISCREQ</a>:
01840                 <span class="keywordflow">if</span> (len &gt;= 4) {
01841                         GETLONG(cilong, p);
01842                         printer(arg, <span class="stringliteral">" magic=0x%x"</span>, cilong);
01843                         p += 4;
01844                         len -= 4;
01845                 }
01846                 <span class="keywordflow">break</span>;
01847         }
01848         
01849         <span class="comment">/* print the rest of the bytes in the packet */</span>
01850         <span class="keywordflow">for</span> (; len &gt; 0; --len) {
01851                 GETCHAR(code, p);
01852                 printer(arg, <span class="stringliteral">" %.2x"</span>, code);
01853         }
01854         
01855         <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(p - pstart);
01856 }
01857 <span class="preprocessor">#endif</span>
01858 <span class="preprocessor"></span>
01859 <span class="comment">/*</span>
01860 <span class="comment"> * Time to shut down the link because there is nothing out there.</span>
01861 <span class="comment"> */</span>
01862 
01863 <span class="keyword">static</span> <span class="keywordtype">void</span> LcpLinkFailure (<a class="code" href="structfsm.html">fsm</a> *f)
01864 {
01865         <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structfsm.html#o2">state</a> == <a class="code" href="fsm_8h.html#a17">OPENED</a>) {
01866                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"No response to %d echo-requests\n"</span>, lcp_echos_pending));
01867                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_NOTICE, <span class="stringliteral">"Serial link appears to be disconnected.\n"</span>));
01868                 <a class="code" href="lcp_8h.html#a34">lcp_close</a>(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, <span class="stringliteral">"Peer not responding"</span>);
01869         }
01870 }
01871 
01872 <span class="comment">/*</span>
01873 <span class="comment"> * Timer expired for the LCP echo requests from this process.</span>
01874 <span class="comment"> */</span>
01875 
01876 <span class="keyword">static</span> <span class="keywordtype">void</span> LcpEchoCheck (<a class="code" href="structfsm.html">fsm</a> *f)
01877 {
01878         LcpSendEchoRequest (f);
01879         
01880         <span class="comment">/*</span>
01881 <span class="comment">         * Start the timer for the next interval.</span>
01882 <span class="comment">         */</span>
01883         <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"lcp_echo_timer_running == 0"</span>, lcp_echo_timer_running == 0);
01884 
01885         TIMEOUT (LcpEchoTimeout, f, lcp_echo_interval);
01886         lcp_echo_timer_running = 1;
01887 }
01888 
01889 <span class="comment">/*</span>
01890 <span class="comment"> * LcpEchoTimeout - Timer expired on the LCP echo</span>
01891 <span class="comment"> */</span>
01892 
01893 <span class="keyword">static</span> <span class="keywordtype">void</span> LcpEchoTimeout (<span class="keywordtype">void</span> *arg)
01894 {
01895         <span class="keywordflow">if</span> (lcp_echo_timer_running != 0) {
01896                 lcp_echo_timer_running = 0;
01897                 LcpEchoCheck ((<a class="code" href="structfsm.html">fsm</a> *) arg);
01898         }
01899 }
01900 
01901 <span class="comment">/*</span>
01902 <span class="comment"> * LcpEchoReply - LCP has received a reply to the echo</span>
01903 <span class="comment"> */</span>
01904 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_received_echo_reply (<a class="code" href="structfsm.html">fsm</a> *f, <span class="keywordtype">int</span> id, u_char *inp, <span class="keywordtype">int</span> len)
01905 {
01906         u32_t <a class="code" href="magic_8c.html#a1">magic</a>;
01907         
01908         (<span class="keywordtype">void</span>)id;
01909 
01910         <span class="comment">/* Check the magic number - don't count replies from ourselves. */</span>
01911         <span class="keywordflow">if</span> (len &lt; 4) {
01912                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"lcp: received short Echo-Reply, length %d\n"</span>, len));
01913                 <span class="keywordflow">return</span>;
01914         }
01915         GETLONG(magic, inp);
01916         <span class="keywordflow">if</span> (<a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>].neg_magicnumber
01917                         &amp;&amp; <a class="code" href="magic_8c.html#a1">magic</a> == <a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>].magicnumber) {
01918                 <a class="code" href="pppdebug_8h.html#a3">LCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"appear to have received our own echo-reply!\n"</span>));
01919                 <span class="keywordflow">return</span>;
01920         }
01921         
01922         <span class="comment">/* Reset the number of outstanding echo frames */</span>
01923         lcp_echos_pending = 0;
01924 }
01925 
01926 <span class="comment">/*</span>
01927 <span class="comment"> * LcpSendEchoRequest - Send an echo request frame to the peer</span>
01928 <span class="comment"> */</span>
01929 
01930 <span class="keyword">static</span> <span class="keywordtype">void</span> LcpSendEchoRequest (<a class="code" href="structfsm.html">fsm</a> *f)
01931 {
01932         u32_t lcp_magic;
01933         u_char pkt[4], *pktp;
01934         
01935         <span class="comment">/*</span>
01936 <span class="comment">        * Detect the failure of the peer at this point.</span>
01937 <span class="comment">        */</span>
01938         <span class="keywordflow">if</span> (lcp_echo_fails != 0) {
01939                 <span class="keywordflow">if</span> (lcp_echos_pending++ &gt;= lcp_echo_fails) {
01940                         LcpLinkFailure(f);
01941                         lcp_echos_pending = 0;
01942                 }
01943         }
01944         
01945         <span class="comment">/*</span>
01946 <span class="comment">        * Make and send the echo request frame.</span>
01947 <span class="comment">        */</span>
01948         <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structfsm.html#o2">state</a> == <a class="code" href="fsm_8h.html#a17">OPENED</a>) {
01949                 lcp_magic = <a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>].magicnumber;
01950                 pktp = pkt;
01951                 PUTLONG(lcp_magic, pktp);
01952                 <a class="code" href="fsm_8h.html#a31">fsm_sdata</a>(f, ECHOREQ, (u_char)(lcp_echo_number++ &amp; 0xFF), pkt, (<span class="keywordtype">int</span>)(pktp - pkt));
01953         }
01954 }
01955 
01956 <span class="comment">/*</span>
01957 <span class="comment"> * lcp_echo_lowerup - Start the timer for the LCP frame</span>
01958 <span class="comment"> */</span>
01959 
01960 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_echo_lowerup (<span class="keywordtype">int</span> unit)
01961 {
01962         <a class="code" href="structfsm.html">fsm</a> *f = &amp;lcp_fsm[unit];
01963         
01964         <span class="comment">/* Clear the parameters for generating echo frames */</span>
01965         lcp_echos_pending      = 0;
01966         lcp_echo_number        = 0;
01967         lcp_echo_timer_running = 0;
01968         
01969         <span class="comment">/* If a timeout interval is specified then start the timer */</span>
01970         <span class="keywordflow">if</span> (lcp_echo_interval != 0)
01971                 LcpEchoCheck (f);
01972 }
01973 
01974 <span class="comment">/*</span>
01975 <span class="comment"> * lcp_echo_lowerdown - Stop the timer for the LCP frame</span>
01976 <span class="comment"> */</span>
01977 
01978 <span class="keyword">static</span> <span class="keywordtype">void</span> lcp_echo_lowerdown (<span class="keywordtype">int</span> unit)
01979 {
01980         <a class="code" href="structfsm.html">fsm</a> *f = &amp;lcp_fsm[unit];
01981         
01982         <span class="keywordflow">if</span> (lcp_echo_timer_running != 0) {
01983                 UNTIMEOUT (LcpEchoTimeout, f);
01984                 lcp_echo_timer_running = 0;
01985         }
01986 }
01987 
01988 <span class="preprocessor">#endif </span><span class="comment">/* PPP_SUPPORT */</span>
</pre></div>	</td>
  </tr>
</table>
<hr>
<div align="center">Copyright (c) 2001-2003 Swedish Institute of Computer Science</div>
</html>
