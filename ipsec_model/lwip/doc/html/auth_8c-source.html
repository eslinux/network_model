
<html>
<head>
<title>lwIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="doxygen.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<table width="98%" border="0" align="center">
  <tr>
    <td>
      <h2>lwIP code documentation</h2>
<hr>

<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>auth.c</h1><a href="auth_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*****************************************************************************</span>
00002 <span class="comment">* auth.c - Network Authentication and Phase Control program file.</span>
00003 <span class="comment">*</span>
00004 <span class="comment">* Copyright (c) 2003 by Marc Boucher, Services Informatiques (MBSI) inc.</span>
00005 <span class="comment">* Copyright (c) 1997 by Global Election Systems Inc.  All rights reserved.</span>
00006 <span class="comment">*</span>
00007 <span class="comment">* The authors hereby grant permission to use, copy, modify, distribute,</span>
00008 <span class="comment">* and license this software and its documentation for any purpose, provided</span>
00009 <span class="comment">* that existing copyright notices are retained in all copies and that this</span>
00010 <span class="comment">* notice and the following disclaimer are included verbatim in any </span>
00011 <span class="comment">* distributions. No written agreement, license, or royalty fee is required</span>
00012 <span class="comment">* for any of the authorized uses.</span>
00013 <span class="comment">*</span>
00014 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS *AS IS* AND ANY EXPRESS OR</span>
00015 <span class="comment">* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
00016 <span class="comment">* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. </span>
00017 <span class="comment">* IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
00018 <span class="comment">* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
00019 <span class="comment">* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
00020 <span class="comment">* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
00021 <span class="comment">* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
00022 <span class="comment">* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
00023 <span class="comment">* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00024 <span class="comment">*</span>
00025 <span class="comment">******************************************************************************</span>
00026 <span class="comment">* REVISION HISTORY</span>
00027 <span class="comment">*</span>
00028 <span class="comment">* 03-01-01 Marc Boucher &lt;marc@mbsi.ca&gt;</span>
00029 <span class="comment">*   Ported to lwIP.</span>
00030 <span class="comment">* 97-12-08 Guy Lancaster &lt;lancasterg@acm.org&gt;, Global Election Systems Inc.</span>
00031 <span class="comment">*   Ported from public pppd code.</span>
00032 <span class="comment">*****************************************************************************/</span>
00033 <span class="comment">/*</span>
00034 <span class="comment"> * auth.c - PPP authentication and phase control.</span>
00035 <span class="comment"> *</span>
00036 <span class="comment"> * Copyright (c) 1993 The Australian National University.</span>
00037 <span class="comment"> * All rights reserved.</span>
00038 <span class="comment"> *</span>
00039 <span class="comment"> * Redistribution and use in source and binary forms are permitted</span>
00040 <span class="comment"> * provided that the above copyright notice and this paragraph are</span>
00041 <span class="comment"> * duplicated in all such forms and that any documentation,</span>
00042 <span class="comment"> * advertising materials, and other materials related to such</span>
00043 <span class="comment"> * distribution and use acknowledge that the software was developed</span>
00044 <span class="comment"> * by the Australian National University.  The name of the University</span>
00045 <span class="comment"> * may not be used to endorse or promote products derived from this</span>
00046 <span class="comment"> * software without specific prior written permission.</span>
00047 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR</span>
00048 <span class="comment"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
00049 <span class="comment"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
00050 <span class="comment"> *</span>
00051 <span class="comment"> * Copyright (c) 1989 Carnegie Mellon University.</span>
00052 <span class="comment"> * All rights reserved.</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * Redistribution and use in source and binary forms are permitted</span>
00055 <span class="comment"> * provided that the above copyright notice and this paragraph are</span>
00056 <span class="comment"> * duplicated in all such forms and that any documentation,</span>
00057 <span class="comment"> * advertising materials, and other materials related to such</span>
00058 <span class="comment"> * distribution and use acknowledge that the software was developed</span>
00059 <span class="comment"> * by Carnegie Mellon University.  The name of the</span>
00060 <span class="comment"> * University may not be used to endorse or promote products derived</span>
00061 <span class="comment"> * from this software without specific prior written permission.</span>
00062 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR</span>
00063 <span class="comment"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
00064 <span class="comment"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
00065 <span class="comment"> */</span>
00066 
00067 <span class="preprocessor">#include "<a class="code" href="ppp_8h.html">ppp.h</a>"</span>
00068 <span class="preprocessor">#if PPP_SUPPORT &gt; 0</span>
00069 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="fsm_8h.html">fsm.h</a>"</span>
00070 <span class="preprocessor">#include "<a class="code" href="lcp_8h.html">lcp.h</a>"</span>
00071 <span class="preprocessor">#include "<a class="code" href="pap_8h.html">pap.h</a>"</span>
00072 <span class="preprocessor">#include "<a class="code" href="chap_8h.html">chap.h</a>"</span>
00073 <span class="preprocessor">#include "<a class="code" href="auth_8h.html">auth.h</a>"</span>
00074 <span class="preprocessor">#include "<a class="code" href="ipcp_8h.html">ipcp.h</a>"</span>
00075 
00076 <span class="preprocessor">#if CBCP_SUPPORT &gt; 0</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#include "cbcp.h"</span>
00078 <span class="preprocessor">#endif</span>
00079 <span class="preprocessor"></span>
00080 <span class="preprocessor">#include "<a class="code" href="pppdebug_8h.html">pppdebug.h</a>"</span>
00081 
00082 
00083 <span class="comment">/*************************/</span>
00084 <span class="comment">/*** LOCAL DEFINITIONS ***/</span>
00085 <span class="comment">/*************************/</span>
00086 
00087 <span class="comment">/* Bits in auth_pending[] */</span>
00088 <span class="preprocessor">#define PAP_WITHPEER    1</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#define PAP_PEER    2</span>
00090 <span class="preprocessor"></span><span class="preprocessor">#define CHAP_WITHPEER   4</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#define CHAP_PEER   8</span>
00092 <span class="preprocessor"></span>
00093 
00094                                                                     
00095 <span class="comment">/************************/</span>
00096 <span class="comment">/*** LOCAL DATA TYPES ***/</span>
00097 <span class="comment">/************************/</span>
00098 <span class="comment">/* Used for storing a sequence of words.  Usually malloced. */</span>
00099 <span class="keyword">struct </span>wordlist {
00100     <span class="keyword">struct </span><a class="code" href="classwordlist.html">wordlist</a> *next;
00101     <span class="keywordtype">char</span>        word[1];
00102 };
00103 
00104 
00105 
00106 <span class="comment">/***********************************/</span>
00107 <span class="comment">/*** LOCAL FUNCTION DECLARATIONS ***/</span>
00108 <span class="comment">/***********************************/</span>
00109 <span class="keyword">extern</span> <span class="keywordtype">char</span> *crypt (<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
00110 
00111 <span class="comment">/* Prototypes for procedures local to this file. */</span>
00112 
00113 <span class="keyword">static</span> <span class="keywordtype">void</span> network_phase (<span class="keywordtype">int</span>);
00114 <span class="keyword">static</span> <span class="keywordtype">void</span> check_idle (<span class="keywordtype">void</span> *);
00115 <span class="keyword">static</span> <span class="keywordtype">void</span> connect_time_expired (<span class="keywordtype">void</span> *);
00116 <span class="preprocessor">#if 0</span>
00117 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span>  login (<span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *, <span class="keywordtype">char</span> **, <span class="keywordtype">int</span> *);
00118 <span class="preprocessor">#endif</span>
00119 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> logout (<span class="keywordtype">void</span>);
00120 <span class="keyword">static</span> <span class="keywordtype">int</span>  null_login (<span class="keywordtype">int</span>);
00121 <span class="keyword">static</span> <span class="keywordtype">int</span>  get_pap_passwd (<span class="keywordtype">int</span>, <span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *);
00122 <span class="keyword">static</span> <span class="keywordtype">int</span>  have_pap_secret (<span class="keywordtype">void</span>);
00123 <span class="keyword">static</span> <span class="keywordtype">int</span>  have_chap_secret (<span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *, u32_t);
00124 <span class="keyword">static</span> <span class="keywordtype">int</span>  ip_addr_check (u32_t, <span class="keyword">struct</span> <a class="code" href="classwordlist.html">wordlist</a> *);
00125 <span class="preprocessor">#if PAP_SUPPORT &gt; 0 || CHAP_SUPPORT &gt; 0</span>
00126 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> set_allowed_addrs(<span class="keywordtype">int</span> unit, <span class="keyword">struct</span> <a class="code" href="classwordlist.html">wordlist</a> *addrs);
00127 <span class="keyword">static</span> <span class="keywordtype">void</span> free_wordlist (<span class="keyword">struct</span> <a class="code" href="classwordlist.html">wordlist</a> *);
00128 <span class="preprocessor">#endif</span>
00129 <span class="preprocessor"></span><span class="preprocessor">#if CBCP_SUPPORT &gt; 0</span>
00130 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> callback_phase (<span class="keywordtype">int</span>);
00131 <span class="preprocessor">#endif</span>
00132 <span class="preprocessor"></span>
00133 
00134 <span class="comment">/******************************/</span>
00135 <span class="comment">/*** PUBLIC DATA STRUCTURES ***/</span>
00136 <span class="comment">/******************************/</span>
00137 
00138 
00139 <span class="comment">/*****************************/</span>
00140 <span class="comment">/*** LOCAL DATA STRUCTURES ***/</span>
00141 <span class="comment">/*****************************/</span>
00142 <span class="preprocessor">#if PAP_SUPPORT &gt; 0 || CHAP_SUPPORT &gt; 0</span>
00143 <span class="preprocessor"></span><span class="comment">/* The name by which the peer authenticated itself to us. */</span>
00144 <span class="keyword">static</span> <span class="keywordtype">char</span> peer_authname[MAXNAMELEN];
00145 <span class="preprocessor">#endif</span>
00146 <span class="preprocessor"></span>
00147 <span class="comment">/* Records which authentication operations haven't completed yet. */</span>
00148 <span class="keyword">static</span> <span class="keywordtype">int</span> auth_pending[NUM_PPP];
00149 
00150 <span class="comment">/* Set if we have successfully called login() */</span>
00151 <span class="keyword">static</span> <span class="keywordtype">int</span> logged_in;
00152 
00153 <span class="comment">/* Set if we have run the /etc/ppp/auth-up script. */</span>
00154 <span class="keyword">static</span> <span class="keywordtype">int</span> did_authup;
00155 
00156 <span class="comment">/* List of addresses which the peer may use. */</span>
00157 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="classwordlist.html">wordlist</a> *addresses[NUM_PPP];
00158 
00159 <span class="comment">/* Number of network protocols which we have opened. */</span>
00160 <span class="keyword">static</span> <span class="keywordtype">int</span> num_np_open;
00161 
00162 <span class="comment">/* Number of network protocols which have come up. */</span>
00163 <span class="keyword">static</span> <span class="keywordtype">int</span> num_np_up;
00164 
00165 <span class="preprocessor">#if PAP_SUPPORT &gt; 0 || CHAP_SUPPORT &gt; 0</span>
00166 <span class="preprocessor"></span><span class="comment">/* Set if we got the contents of passwd[] from the pap-secrets file. */</span>
00167 <span class="keyword">static</span> <span class="keywordtype">int</span> passwd_from_file;
00168 <span class="preprocessor">#endif</span>
00169 <span class="preprocessor"></span>
00170 
00171 
00172 <span class="comment">/***********************************/</span>
00173 <span class="comment">/*** PUBLIC FUNCTION DEFINITIONS ***/</span>
00174 <span class="comment">/***********************************/</span>
00175 <span class="comment">/*</span>
00176 <span class="comment"> * An Open on LCP has requested a change from Dead to Establish phase.</span>
00177 <span class="comment"> * Do what's necessary to bring the physical layer up.</span>
00178 <span class="comment"> */</span>
00179 <span class="keywordtype">void</span> <a class="code" href="auth_8h.html#a0">link_required</a>(<span class="keywordtype">int</span> unit)
00180 {
00181     <a class="code" href="pppdebug_8h.html#a0">AUTHDEBUG</a>((LOG_INFO, <span class="stringliteral">"link_required: %d\n"</span>, unit));
00182 }
00183 
00184 <span class="comment">/*</span>
00185 <span class="comment"> * LCP has terminated the link; go to the Dead phase and take the</span>
00186 <span class="comment"> * physical layer down.</span>
00187 <span class="comment"> */</span>
00188 <span class="keywordtype">void</span> <a class="code" href="auth_8h.html#a1">link_terminated</a>(<span class="keywordtype">int</span> unit)
00189 {
00190     <a class="code" href="pppdebug_8h.html#a0">AUTHDEBUG</a>((LOG_INFO, <span class="stringliteral">"link_terminated: %d\n"</span>, unit));
00191     
00192     <span class="keywordflow">if</span> (<a class="code" href="lcp_8h.html#a18">lcp_phase</a>[unit] == <a class="code" href="lcp_8h.html#a38a25">PHASE_DEAD</a>)
00193         <span class="keywordflow">return</span>;
00194     <span class="keywordflow">if</span> (logged_in)
00195         logout();
00196     <a class="code" href="lcp_8h.html#a18">lcp_phase</a>[unit] = <a class="code" href="lcp_8h.html#a38a25">PHASE_DEAD</a>;
00197     <a class="code" href="pppdebug_8h.html#a15">ppp_trace</a>(LOG_NOTICE, <span class="stringliteral">"Connection terminated.\n"</span>);
00198         pppMainWakeup(unit);
00199 }
00200 
00201 <span class="comment">/*</span>
00202 <span class="comment"> * LCP has gone down; it will either die or try to re-establish.</span>
00203 <span class="comment"> */</span>
00204 <span class="keywordtype">void</span> <a class="code" href="auth_8h.html#a2">link_down</a>(<span class="keywordtype">int</span> unit)
00205 {
00206     <span class="keywordtype">int</span> i;
00207     <span class="keyword">struct </span>protent *protp;
00208     
00209     <a class="code" href="pppdebug_8h.html#a0">AUTHDEBUG</a>((LOG_INFO, <span class="stringliteral">"link_down: %d\n"</span>, unit));
00210     <span class="keywordflow">if</span> (did_authup) {
00211         <span class="comment">/* XXX Do link down processing. */</span>
00212         did_authup = 0;
00213     }
00214     <span class="keywordflow">for</span> (i = 0; (protp = ppp_protocols[i]) != <a class="code" href="def_8h.html#a2">NULL</a>; ++i) {
00215         <span class="keywordflow">if</span> (!protp-&gt;enabled_flag)
00216             <span class="keywordflow">continue</span>;
00217         <span class="keywordflow">if</span> (protp-&gt;protocol != PPP_LCP &amp;&amp; protp-&gt;lowerdown != <a class="code" href="def_8h.html#a2">NULL</a>)
00218             (*protp-&gt;lowerdown)(unit);
00219         <span class="keywordflow">if</span> (protp-&gt;protocol &lt; 0xC000 &amp;&amp; protp-&gt;close != <a class="code" href="def_8h.html#a2">NULL</a>)
00220             (*protp-&gt;close)(unit, <span class="stringliteral">"LCP down"</span>);
00221     }
00222     num_np_open = 0;
00223     num_np_up = 0;
00224     <span class="keywordflow">if</span> (<a class="code" href="lcp_8h.html#a18">lcp_phase</a>[unit] != <a class="code" href="lcp_8h.html#a38a25">PHASE_DEAD</a>)
00225         <a class="code" href="lcp_8h.html#a18">lcp_phase</a>[unit] = <a class="code" href="lcp_8h.html#a38a31">PHASE_TERMINATE</a>;
00226         pppMainWakeup(unit);
00227 }
00228 
00229 <span class="comment">/*</span>
00230 <span class="comment"> * The link is established.</span>
00231 <span class="comment"> * Proceed to the Dead, Authenticate or Network phase as appropriate.</span>
00232 <span class="comment"> */</span>
00233 <span class="keywordtype">void</span> <a class="code" href="auth_8h.html#a3">link_established</a>(<span class="keywordtype">int</span> unit)
00234 {
00235     <span class="keywordtype">int</span> auth;
00236     <span class="keywordtype">int</span> i;
00237     <span class="keyword">struct </span>protent *protp;
00238     <a class="code" href="structlcp__options.html">lcp_options</a> *wo = &amp;<a class="code" href="lcp_8h.html#a19">lcp_wantoptions</a>[unit];
00239     <a class="code" href="structlcp__options.html">lcp_options</a> *go = &amp;<a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[unit];
00240 <span class="preprocessor">#if PAP_SUPPORT &gt; 0 || CHAP_SUPPORT &gt; 0</span>
00241 <span class="preprocessor"></span>    <a class="code" href="structlcp__options.html">lcp_options</a> *ho = &amp;<a class="code" href="lcp_8h.html#a22">lcp_hisoptions</a>[unit];
00242 <span class="preprocessor">#endif</span>
00243 <span class="preprocessor"></span>    
00244     <a class="code" href="pppdebug_8h.html#a0">AUTHDEBUG</a>((LOG_INFO, <span class="stringliteral">"link_established: %d\n"</span>, unit));
00245     <span class="comment">/*</span>
00246 <span class="comment">     * Tell higher-level protocols that LCP is up.</span>
00247 <span class="comment">     */</span>
00248     <span class="keywordflow">for</span> (i = 0; (protp = ppp_protocols[i]) != <a class="code" href="def_8h.html#a2">NULL</a>; ++i)
00249         <span class="keywordflow">if</span> (protp-&gt;protocol != PPP_LCP &amp;&amp; protp-&gt;enabled_flag
00250                 &amp;&amp; protp-&gt;lowerup != <a class="code" href="def_8h.html#a2">NULL</a>)
00251             (*protp-&gt;lowerup)(unit);
00252     
00253     <span class="keywordflow">if</span> (ppp_settings.auth_required &amp;&amp; !(go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a> || go-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a>)) {
00254         <span class="comment">/*</span>
00255 <span class="comment">         * We wanted the peer to authenticate itself, and it refused:</span>
00256 <span class="comment">         * treat it as though it authenticated with PAP using a username</span>
00257 <span class="comment">         * of "" and a password of "".  If that's not OK, boot it out.</span>
00258 <span class="comment">         */</span>
00259         <span class="keywordflow">if</span> (!wo-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a> || !null_login(unit)) {
00260             <a class="code" href="pppdebug_8h.html#a15">ppp_trace</a>(LOG_WARNING, <span class="stringliteral">"peer refused to authenticate\n"</span>);
00261             <a class="code" href="lcp_8h.html#a34">lcp_close</a>(unit, <span class="stringliteral">"peer refused to authenticate"</span>);
00262             <span class="keywordflow">return</span>;
00263         }
00264     }
00265     
00266     <a class="code" href="lcp_8h.html#a18">lcp_phase</a>[unit] = <a class="code" href="lcp_8h.html#a38a28">PHASE_AUTHENTICATE</a>;
00267     auth = 0;
00268 <span class="preprocessor">#if CHAP_SUPPORT &gt; 0</span>
00269 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>) {
00270         <a class="code" href="chap_8h.html#a29">ChapAuthPeer</a>(unit, ppp_settings.our_name, go-&gt;<a class="code" href="structlcp__options.html#o13">chap_mdtype</a>);
00271         auth |= CHAP_PEER;
00272     } 
00273 <span class="preprocessor">#endif</span>
00274 <span class="preprocessor"></span><span class="preprocessor">#if PAP_SUPPORT &gt; 0 &amp;&amp; CHAP_SUPPORT &gt; 0</span>
00275 <span class="preprocessor"></span>    <span class="keywordflow">else</span>
00276 <span class="preprocessor">#endif</span>
00277 <span class="preprocessor"></span><span class="preprocessor">#if PAP_SUPPORT &gt; 0</span>
00278 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a>) {
00279         <a class="code" href="pap_8h.html#a21">upap_authpeer</a>(unit);
00280         auth |= PAP_PEER;
00281     }
00282 <span class="preprocessor">#endif</span>
00283 <span class="preprocessor"></span><span class="preprocessor">#if CHAP_SUPPORT &gt; 0</span>
00284 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ho-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>) {
00285         <a class="code" href="chap_8h.html#a28">ChapAuthWithPeer</a>(unit, ppp_settings.user, ho-&gt;<a class="code" href="structlcp__options.html#o13">chap_mdtype</a>);
00286         auth |= CHAP_WITHPEER;
00287     }
00288 <span class="preprocessor">#endif</span>
00289 <span class="preprocessor"></span><span class="preprocessor">#if PAP_SUPPORT &gt; 0 &amp;&amp; CHAP_SUPPORT &gt; 0</span>
00290 <span class="preprocessor"></span>    <span class="keywordflow">else</span>
00291 <span class="preprocessor">#endif</span>
00292 <span class="preprocessor"></span><span class="preprocessor">#if PAP_SUPPORT &gt; 0</span>
00293 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ho-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a>) {
00294         <span class="keywordflow">if</span> (ppp_settings.passwd[0] == 0) {
00295             passwd_from_file = 1;
00296             <span class="keywordflow">if</span> (!get_pap_passwd(unit, ppp_settings.user, ppp_settings.passwd))
00297                 <a class="code" href="pppdebug_8h.html#a15">ppp_trace</a>(LOG_ERR, <span class="stringliteral">"No secret found for PAP login\n"</span>);
00298         }
00299         <a class="code" href="pap_8h.html#a20">upap_authwithpeer</a>(unit, ppp_settings.user, ppp_settings.passwd);
00300         auth |= PAP_WITHPEER;
00301     }
00302 <span class="preprocessor">#endif</span>
00303 <span class="preprocessor"></span>    auth_pending[unit] = auth;
00304     
00305     <span class="keywordflow">if</span> (!auth)
00306         network_phase(unit);
00307 }
00308 
00309 
00310 <span class="comment">/*</span>
00311 <span class="comment"> * The peer has failed to authenticate himself using `protocol'.</span>
00312 <span class="comment"> */</span>
00313 <span class="keywordtype">void</span> <a class="code" href="auth_8h.html#a7">auth_peer_fail</a>(<span class="keywordtype">int</span> unit, u16_t protocol)
00314 {
00315     <a class="code" href="pppdebug_8h.html#a0">AUTHDEBUG</a>((LOG_INFO, <span class="stringliteral">"auth_peer_fail: %d proto=%X\n"</span>, unit, protocol));
00316     <span class="comment">/*</span>
00317 <span class="comment">     * Authentication failure: take the link down</span>
00318 <span class="comment">     */</span>
00319     <a class="code" href="lcp_8h.html#a34">lcp_close</a>(unit, <span class="stringliteral">"Authentication failed"</span>);
00320 }
00321 
00322 
00323 <span class="preprocessor">#if PAP_SUPPORT &gt; 0 || CHAP_SUPPORT &gt; 0</span>
00324 <span class="preprocessor"></span><span class="comment">/*</span>
00325 <span class="comment"> * The peer has been successfully authenticated using `protocol'.</span>
00326 <span class="comment"> */</span>
00327 <span class="keywordtype">void</span> <a class="code" href="auth_8h.html#a8">auth_peer_success</a>(<span class="keywordtype">int</span> unit, u16_t protocol, <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> namelen)
00328 {
00329     <span class="keywordtype">int</span> pbit;
00330     
00331     <a class="code" href="pppdebug_8h.html#a0">AUTHDEBUG</a>((LOG_INFO, <span class="stringliteral">"auth_peer_success: %d proto=%X\n"</span>, unit, protocol));
00332     <span class="keywordflow">switch</span> (protocol) {
00333     <span class="keywordflow">case</span> PPP_CHAP:
00334         pbit = CHAP_PEER;
00335         <span class="keywordflow">break</span>;
00336     <span class="keywordflow">case</span> PPP_PAP:
00337         pbit = PAP_PEER;
00338         <span class="keywordflow">break</span>;
00339     <span class="keywordflow">default</span>:
00340         <a class="code" href="pppdebug_8h.html#a15">ppp_trace</a>(LOG_WARNING, <span class="stringliteral">"auth_peer_success: unknown protocol %x\n"</span>,
00341                protocol);
00342         <span class="keywordflow">return</span>;
00343     }
00344     
00345     <span class="comment">/*</span>
00346 <span class="comment">     * Save the authenticated name of the peer for later.</span>
00347 <span class="comment">     */</span>
00348     <span class="keywordflow">if</span> (namelen &gt; <span class="keyword">sizeof</span>(peer_authname) - 1)
00349         namelen = <span class="keyword">sizeof</span>(peer_authname) - 1;
00350     BCOPY(name, peer_authname, namelen);
00351     peer_authname[namelen] = 0;
00352     
00353     <span class="comment">/*</span>
00354 <span class="comment">     * If there is no more authentication still to be done,</span>
00355 <span class="comment">     * proceed to the network (or callback) phase.</span>
00356 <span class="comment">     */</span>
00357     <span class="keywordflow">if</span> ((auth_pending[unit] &amp;= ~pbit) == 0)
00358         network_phase(unit);
00359 }
00360 
00361 <span class="comment">/*</span>
00362 <span class="comment"> * We have failed to authenticate ourselves to the peer using `protocol'.</span>
00363 <span class="comment"> */</span>
00364 <span class="keywordtype">void</span> <a class="code" href="auth_8h.html#a9">auth_withpeer_fail</a>(<span class="keywordtype">int</span> unit, u16_t protocol)
00365 {
00366     <span class="keywordtype">int</span> errCode = PPPERR_AUTHFAIL;
00367     
00368     <a class="code" href="pppdebug_8h.html#a0">AUTHDEBUG</a>((LOG_INFO, <span class="stringliteral">"auth_withpeer_fail: %d proto=%X\n"</span>, unit, protocol));
00369     <span class="keywordflow">if</span> (passwd_from_file)
00370         BZERO(ppp_settings.passwd, MAXSECRETLEN);
00371     <span class="comment">/* </span>
00372 <span class="comment">     * XXX Warning: the unit number indicates the interface which is</span>
00373 <span class="comment">     * not necessarily the PPP connection.  It works here as long</span>
00374 <span class="comment">     * as we are only supporting PPP interfaces.</span>
00375 <span class="comment">     */</span>
00376     pppIOCtl(unit, PPPCTLS_ERRCODE, &amp;errCode);
00377 
00378     <span class="comment">/*</span>
00379 <span class="comment">     * We've failed to authenticate ourselves to our peer.</span>
00380 <span class="comment">     * He'll probably take the link down, and there's not much</span>
00381 <span class="comment">     * we can do except wait for that.</span>
00382 <span class="comment">     */</span>
00383 }
00384 
00385 <span class="comment">/*</span>
00386 <span class="comment"> * We have successfully authenticated ourselves with the peer using `protocol'.</span>
00387 <span class="comment"> */</span>
00388 <span class="keywordtype">void</span> <a class="code" href="auth_8h.html#a10">auth_withpeer_success</a>(<span class="keywordtype">int</span> unit, u16_t protocol)
00389 {
00390     <span class="keywordtype">int</span> pbit;
00391     
00392     <a class="code" href="pppdebug_8h.html#a0">AUTHDEBUG</a>((LOG_INFO, <span class="stringliteral">"auth_withpeer_success: %d proto=%X\n"</span>, unit, protocol));
00393     <span class="keywordflow">switch</span> (protocol) {
00394     <span class="keywordflow">case</span> PPP_CHAP:
00395         pbit = CHAP_WITHPEER;
00396         <span class="keywordflow">break</span>;
00397     <span class="keywordflow">case</span> PPP_PAP:
00398         <span class="keywordflow">if</span> (passwd_from_file)
00399             BZERO(ppp_settings.passwd, MAXSECRETLEN);
00400         pbit = PAP_WITHPEER;
00401         <span class="keywordflow">break</span>;
00402     <span class="keywordflow">default</span>:
00403         <a class="code" href="pppdebug_8h.html#a15">ppp_trace</a>(LOG_WARNING, <span class="stringliteral">"auth_peer_success: unknown protocol %x\n"</span>,
00404                protocol);
00405         pbit = 0;
00406     }
00407     
00408     <span class="comment">/*</span>
00409 <span class="comment">     * If there is no more authentication still being done,</span>
00410 <span class="comment">     * proceed to the network (or callback) phase.</span>
00411 <span class="comment">     */</span>
00412     <span class="keywordflow">if</span> ((auth_pending[unit] &amp;= ~pbit) == 0)
00413         network_phase(unit);
00414 }
00415 <span class="preprocessor">#endif</span>
00416 <span class="preprocessor"></span>
00417 
00418 <span class="comment">/*</span>
00419 <span class="comment"> * np_up - a network protocol has come up.</span>
00420 <span class="comment"> */</span>
00421 <span class="keywordtype">void</span> <a class="code" href="auth_8h.html#a4">np_up</a>(<span class="keywordtype">int</span> unit, u16_t proto)
00422 {
00423     <a class="code" href="pppdebug_8h.html#a0">AUTHDEBUG</a>((LOG_INFO, <span class="stringliteral">"np_up: %d proto=%X\n"</span>, unit, proto));
00424     <span class="keywordflow">if</span> (num_np_up == 0) {
00425         <a class="code" href="pppdebug_8h.html#a0">AUTHDEBUG</a>((LOG_INFO, <span class="stringliteral">"np_up: maxconnect=%d idle_time_limit=%d\n"</span>,ppp_settings.maxconnect,ppp_settings.idle_time_limit));
00426         <span class="comment">/*</span>
00427 <span class="comment">         * At this point we consider that the link has come up successfully.</span>
00428 <span class="comment">         */</span>
00429         <span class="keywordflow">if</span> (ppp_settings.idle_time_limit &gt; 0)
00430             TIMEOUT(check_idle, NULL, ppp_settings.idle_time_limit);
00431         
00432         <span class="comment">/*</span>
00433 <span class="comment">         * Set a timeout to close the connection once the maximum</span>
00434 <span class="comment">         * connect time has expired.</span>
00435 <span class="comment">         */</span>
00436         <span class="keywordflow">if</span> (ppp_settings.maxconnect &gt; 0)
00437             TIMEOUT(connect_time_expired, 0, ppp_settings.maxconnect);
00438     }
00439     ++num_np_up;
00440 }
00441 
00442 <span class="comment">/*</span>
00443 <span class="comment"> * np_down - a network protocol has gone down.</span>
00444 <span class="comment"> */</span>
00445 <span class="keywordtype">void</span> <a class="code" href="auth_8h.html#a5">np_down</a>(<span class="keywordtype">int</span> unit, u16_t proto)
00446 {
00447     <a class="code" href="pppdebug_8h.html#a0">AUTHDEBUG</a>((LOG_INFO, <span class="stringliteral">"np_down: %d proto=%X\n"</span>, unit, proto));
00448     <span class="keywordflow">if</span> (--num_np_up == 0 &amp;&amp; ppp_settings.idle_time_limit &gt; 0) {
00449         UNTIMEOUT(check_idle, NULL);
00450     }
00451 }
00452 
00453 <span class="comment">/*</span>
00454 <span class="comment"> * np_finished - a network protocol has finished using the link.</span>
00455 <span class="comment"> */</span>
00456 <span class="keywordtype">void</span> <a class="code" href="auth_8h.html#a6">np_finished</a>(<span class="keywordtype">int</span> unit, u16_t proto)
00457 {
00458     <a class="code" href="pppdebug_8h.html#a0">AUTHDEBUG</a>((LOG_INFO, <span class="stringliteral">"np_finished: %d proto=%X\n"</span>, unit, proto));
00459     <span class="keywordflow">if</span> (--num_np_open &lt;= 0) {
00460         <span class="comment">/* no further use for the link: shut up shop. */</span>
00461         <a class="code" href="lcp_8h.html#a34">lcp_close</a>(0, <span class="stringliteral">"No network protocols running"</span>);
00462     }
00463 }
00464 
00465 <span class="comment">/*</span>
00466 <span class="comment"> * auth_reset - called when LCP is starting negotiations to recheck</span>
00467 <span class="comment"> * authentication options, i.e. whether we have appropriate secrets</span>
00468 <span class="comment"> * to use for authenticating ourselves and/or the peer.</span>
00469 <span class="comment"> */</span>
00470 <span class="keywordtype">void</span> <a class="code" href="auth_8h.html#a12">auth_reset</a>(<span class="keywordtype">int</span> unit)
00471 {
00472     <a class="code" href="structlcp__options.html">lcp_options</a> *go = &amp;<a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[unit];
00473     <a class="code" href="structlcp__options.html">lcp_options</a> *ao = &amp;<a class="code" href="lcp_8h.html#a21">lcp_allowoptions</a>[0];
00474     <a class="code" href="structipcp__options.html">ipcp_options</a> *ipwo = &amp;<a class="code" href="ipcp_8h.html#a14">ipcp_wantoptions</a>[0];
00475     u32_t remote;
00476     
00477     <a class="code" href="pppdebug_8h.html#a0">AUTHDEBUG</a>((LOG_INFO, <span class="stringliteral">"auth_reset: %d\n"</span>, unit));
00478     ao-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a> = !ppp_settings.refuse_pap &amp;&amp; (ppp_settings.passwd[0] != 0 || get_pap_passwd(unit, NULL, NULL));
00479     ao-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a> = !ppp_settings.refuse_chap &amp;&amp; have_chap_secret(ppp_settings.user, ppp_settings.remote_name, (u32_t)0);
00480     
00481     <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a> &amp;&amp; !have_pap_secret())
00482         go-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a> = 0;
00483     <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>) {
00484         remote = ipwo-&gt;<a class="code" href="structipcp__options.html#o8">accept_remote</a>? 0: ipwo-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>;
00485         <span class="keywordflow">if</span> (!have_chap_secret(ppp_settings.remote_name, ppp_settings.our_name, remote))
00486             go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a> = 0;
00487     }
00488 }
00489 
00490 
00491 <span class="preprocessor">#if PAP_SUPPORT &gt; 0</span>
00492 <span class="preprocessor"></span><span class="comment">/*</span>
00493 <span class="comment"> * check_passwd - Check the user name and passwd against the PAP secrets</span>
00494 <span class="comment"> * file.  If requested, also check against the system password database,</span>
00495 <span class="comment"> * and login the user if OK.</span>
00496 <span class="comment"> *</span>
00497 <span class="comment"> * returns:</span>
00498 <span class="comment"> *  UPAP_AUTHNAK: Authentication failed.</span>
00499 <span class="comment"> *  UPAP_AUTHACK: Authentication succeeded.</span>
00500 <span class="comment"> * In either case, msg points to an appropriate message.</span>
00501 <span class="comment"> */</span>
00502 <span class="keywordtype">int</span> <a class="code" href="auth_8h.html#a13">check_passwd</a>(
00503         <span class="keywordtype">int</span> unit,
00504         <span class="keywordtype">char</span> *auser,
00505         <span class="keywordtype">int</span> userlen,
00506         <span class="keywordtype">char</span> *apasswd,
00507         <span class="keywordtype">int</span> passwdlen,
00508         <span class="keywordtype">char</span> **msg,
00509         <span class="keywordtype">int</span> *msglen
00510 )
00511 {
00512 <span class="preprocessor">#if 1</span>
00513 <span class="preprocessor"></span>        *msg = (<span class="keywordtype">char</span> *) 0;
00514         <span class="keywordflow">return</span> <a class="code" href="pap_8h.html#a2">UPAP_AUTHACK</a>;     <span class="comment">/* XXX Assume all entries OK. */</span>
00515 <span class="preprocessor">#else</span>
00516 <span class="preprocessor"></span>    <span class="keywordtype">int</span> ret = 0;
00517     <span class="keyword">struct </span><a class="code" href="classwordlist.html">wordlist</a> *addrs = <a class="code" href="def_8h.html#a2">NULL</a>;
00518     <span class="keywordtype">char</span> passwd[256], user[256];
00519     <span class="keywordtype">char</span> secret[MAXWORDLEN];
00520     <span class="keyword">static</span> u_short attempts = 0;
00521     
00522     <span class="comment">/*</span>
00523 <span class="comment">     * Make copies of apasswd and auser, then null-terminate them.</span>
00524 <span class="comment">     */</span>
00525     BCOPY(apasswd, passwd, passwdlen);
00526     passwd[passwdlen] = <span class="charliteral">'\0'</span>;
00527     BCOPY(auser, user, userlen);
00528     user[userlen] = <span class="charliteral">'\0'</span>;
00529     *msg = (<span class="keywordtype">char</span> *) 0;
00530 
00531     <span class="comment">/* XXX Validate user name and password. */</span>
00532     ret = <a class="code" href="pap_8h.html#a2">UPAP_AUTHACK</a>;     <span class="comment">/* XXX Assume all entries OK. */</span>
00533         
00534     <span class="keywordflow">if</span> (ret == <a class="code" href="pap_8h.html#a3">UPAP_AUTHNAK</a>) {
00535         <span class="keywordflow">if</span> (*msg == (<span class="keywordtype">char</span> *) 0)
00536             *msg = <span class="stringliteral">"Login incorrect"</span>;
00537         *msglen = strlen(*msg);
00538         <span class="comment">/*</span>
00539 <span class="comment">         * Frustrate passwd stealer programs.</span>
00540 <span class="comment">         * Allow 10 tries, but start backing off after 3 (stolen from login).</span>
00541 <span class="comment">         * On 10'th, drop the connection.</span>
00542 <span class="comment">         */</span>
00543         <span class="keywordflow">if</span> (attempts++ &gt;= 10) {
00544             <a class="code" href="pppdebug_8h.html#a15">ppp_trace</a>(LOG_WARNING, <span class="stringliteral">"%d LOGIN FAILURES BY %s\n"</span>, attempts, user);
00545             <span class="comment">/*ppp_panic("Excess Bad Logins");*/</span>
00546         }
00547         <span class="keywordflow">if</span> (attempts &gt; 3) {
00548             <a class="code" href="sys_8c.html#a6">sys_msleep</a>((attempts - 3) * 5);
00549         }
00550         <span class="keywordflow">if</span> (addrs != <a class="code" href="def_8h.html#a2">NULL</a>) {
00551             free_wordlist(addrs);
00552         }
00553     } <span class="keywordflow">else</span> {
00554         attempts = 0;           <span class="comment">/* Reset count */</span>
00555         <span class="keywordflow">if</span> (*msg == (<span class="keywordtype">char</span> *) 0)
00556             *msg = <span class="stringliteral">"Login ok"</span>;
00557         *msglen = strlen(*msg);
00558         set_allowed_addrs(unit, addrs);
00559     }
00560     
00561     BZERO(passwd, <span class="keyword">sizeof</span>(passwd));
00562     BZERO(secret, <span class="keyword">sizeof</span>(secret));
00563     
00564     <span class="keywordflow">return</span> ret;
00565 <span class="preprocessor">#endif</span>
00566 <span class="preprocessor"></span>}
00567 <span class="preprocessor">#endif</span>
00568 <span class="preprocessor"></span>
00569 
00570 <span class="comment">/*</span>
00571 <span class="comment"> * auth_ip_addr - check whether the peer is authorized to use</span>
00572 <span class="comment"> * a given IP address.  Returns 1 if authorized, 0 otherwise.</span>
00573 <span class="comment"> */</span>
00574 <span class="keywordtype">int</span> <a class="code" href="auth_8h.html#a15">auth_ip_addr</a>(<span class="keywordtype">int</span> unit, u32_t addr)
00575 {
00576     <span class="keywordflow">return</span> ip_addr_check(addr, addresses[unit]);
00577 }
00578 
00579 <span class="comment">/*</span>
00580 <span class="comment"> * bad_ip_adrs - return 1 if the IP address is one we don't want</span>
00581 <span class="comment"> * to use, such as an address in the loopback net or a multicast address.</span>
00582 <span class="comment"> * addr is in network byte order.</span>
00583 <span class="comment"> */</span>
00584 <span class="keywordtype">int</span> <a class="code" href="auth_8h.html#a16">bad_ip_adrs</a>(u32_t addr)
00585 {
00586     addr = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(addr);
00587     <span class="keywordflow">return</span> (addr &gt;&gt; <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a6">IN_CLASSA_NSHIFT</a>) == <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a25">IN_LOOPBACKNET</a>
00588         || <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a22">IN_MULTICAST</a>(addr) || <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a24">IN_BADCLASS</a>(addr);
00589 }
00590 
00591 
00592 <span class="preprocessor">#if CHAP_SUPPORT &gt; 0</span>
00593 <span class="preprocessor"></span><span class="comment">/*</span>
00594 <span class="comment"> * get_secret - open the CHAP secret file and return the secret</span>
00595 <span class="comment"> * for authenticating the given client on the given server.</span>
00596 <span class="comment"> * (We could be either client or server).</span>
00597 <span class="comment"> */</span>
00598 <span class="keywordtype">int</span> <a class="code" href="auth_8h.html#a14">get_secret</a>(
00599     <span class="keywordtype">int</span> unit,
00600     <span class="keywordtype">char</span> *client,
00601     <span class="keywordtype">char</span> *server,
00602     <span class="keywordtype">char</span> *secret,
00603     <span class="keywordtype">int</span> *secret_len,
00604     <span class="keywordtype">int</span> save_addrs
00605 )
00606 {
00607 <span class="preprocessor">#if 1</span>
00608 <span class="preprocessor"></span>        <span class="keywordflow">return</span> 0;
00609 <span class="preprocessor">#else</span>
00610 <span class="preprocessor"></span>    <span class="keywordtype">int</span> ret = 0, len;
00611     <span class="keyword">struct </span><a class="code" href="classwordlist.html">wordlist</a> *addrs;
00612     <span class="keywordtype">char</span> secbuf[MAXWORDLEN];
00613     
00614     addrs = <a class="code" href="def_8h.html#a2">NULL</a>;
00615     secbuf[0] = 0;
00616 
00617     <span class="comment">/* XXX Find secret. */</span>  
00618     <span class="keywordflow">if</span> (ret &lt; 0)
00619         <span class="keywordflow">return</span> 0;
00620     
00621     <span class="keywordflow">if</span> (save_addrs)
00622         set_allowed_addrs(unit, addrs);
00623     
00624     len = strlen(secbuf);
00625     <span class="keywordflow">if</span> (len &gt; MAXSECRETLEN) {
00626         <a class="code" href="pppdebug_8h.html#a15">ppp_trace</a>(LOG_ERR, <span class="stringliteral">"Secret for %s on %s is too long\n"</span>, client, server);
00627         len = MAXSECRETLEN;
00628     }
00629     BCOPY(secbuf, secret, len);
00630     BZERO(secbuf, <span class="keyword">sizeof</span>(secbuf));
00631     *secret_len = len;
00632     
00633     <span class="keywordflow">return</span> 1;
00634 <span class="preprocessor">#endif</span>
00635 <span class="preprocessor"></span>}
00636 <span class="preprocessor">#endif</span>
00637 <span class="preprocessor"></span>
00638 
00639 <span class="preprocessor">#if 0 </span><span class="comment">/* UNUSED */</span>
00640 <span class="comment">/*</span>
00641 <span class="comment"> * auth_check_options - called to check authentication options.</span>
00642 <span class="comment"> */</span>
00643 <span class="keywordtype">void</span> <a class="code" href="auth_8h.html#a11">auth_check_options</a>(<span class="keywordtype">void</span>)
00644 {
00645     <a class="code" href="structlcp__options.html">lcp_options</a> *wo = &amp;<a class="code" href="lcp_8h.html#a19">lcp_wantoptions</a>[0];
00646     <span class="keywordtype">int</span> can_auth;
00647     <a class="code" href="structipcp__options.html">ipcp_options</a> *ipwo = &amp;<a class="code" href="ipcp_8h.html#a14">ipcp_wantoptions</a>[0];
00648     u32_t remote;
00649     
00650     <span class="comment">/* Default our_name to hostname, and user to our_name */</span>
00651     <span class="keywordflow">if</span> (ppp_settings.our_name[0] == 0 || ppp_settings.usehostname)
00652         strcpy(ppp_settings.our_name, ppp_settings.hostname);
00653     <span class="keywordflow">if</span> (ppp_settings.user[0] == 0)
00654         strcpy(ppp_settings.user, ppp_settings.our_name);
00655     
00656     <span class="comment">/* If authentication is required, ask peer for CHAP or PAP. */</span>
00657     <span class="keywordflow">if</span> (ppp_settings.auth_required &amp;&amp; !wo-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a> &amp;&amp; !wo-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a>) {
00658         wo-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a> = 1;
00659         wo-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a> = 1;
00660     }
00661     
00662     <span class="comment">/*</span>
00663 <span class="comment">     * Check whether we have appropriate secrets to use</span>
00664 <span class="comment">     * to authenticate the peer.</span>
00665 <span class="comment">     */</span>
00666     can_auth = wo-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a> &amp;&amp; have_pap_secret();
00667     <span class="keywordflow">if</span> (!can_auth &amp;&amp; wo-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a>) {
00668         remote = ipwo-&gt;<a class="code" href="structipcp__options.html#o8">accept_remote</a>? 0: ipwo-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>;
00669         can_auth = have_chap_secret(ppp_settings.remote_name, ppp_settings.our_name, remote);
00670     }
00671     
00672     <span class="keywordflow">if</span> (ppp_settings.auth_required &amp;&amp; !can_auth) {
00673         ppp_panic(<span class="stringliteral">"No auth secret"</span>);
00674     }
00675 }
00676 <span class="preprocessor">#endif</span>
00677 <span class="preprocessor"></span>
00678 
00679 <span class="comment">/**********************************/</span>
00680 <span class="comment">/*** LOCAL FUNCTION DEFINITIONS ***/</span>
00681 <span class="comment">/**********************************/</span>
00682 <span class="comment">/*</span>
00683 <span class="comment"> * Proceed to the network phase.</span>
00684 <span class="comment"> */</span>
00685 <span class="keyword">static</span> <span class="keywordtype">void</span> network_phase(<span class="keywordtype">int</span> unit)
00686 {
00687     <span class="keywordtype">int</span> i;
00688     <span class="keyword">struct </span>protent *protp;
00689     <a class="code" href="structlcp__options.html">lcp_options</a> *go = &amp;<a class="code" href="lcp_8h.html#a20">lcp_gotoptions</a>[unit];
00690     
00691     <span class="comment">/*</span>
00692 <span class="comment">     * If the peer had to authenticate, run the auth-up script now.</span>
00693 <span class="comment">     */</span>
00694     <span class="keywordflow">if</span> ((go-&gt;<a class="code" href="structlcp__options.html#o6">neg_chap</a> || go-&gt;<a class="code" href="structlcp__options.html#o5">neg_upap</a>) &amp;&amp; !did_authup) {
00695         <span class="comment">/* XXX Do setup for peer authentication. */</span>
00696         did_authup = 1;
00697     }
00698     
00699 <span class="preprocessor">#if CBCP_SUPPORT &gt; 0</span>
00700 <span class="preprocessor"></span>    <span class="comment">/*</span>
00701 <span class="comment">     * If we negotiated callback, do it now.</span>
00702 <span class="comment">     */</span>
00703     <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structlcp__options.html#o11">neg_cbcp</a>) {
00704         <a class="code" href="lcp_8h.html#a18">lcp_phase</a>[unit] = <a class="code" href="lcp_8h.html#a38a29">PHASE_CALLBACK</a>;
00705         (*cbcp_protent.open)(unit);
00706         <span class="keywordflow">return</span>;
00707     }
00708 <span class="preprocessor">#endif</span>
00709 <span class="preprocessor"></span>    
00710     <a class="code" href="lcp_8h.html#a18">lcp_phase</a>[unit] = <a class="code" href="lcp_8h.html#a38a30">PHASE_NETWORK</a>;
00711     <span class="keywordflow">for</span> (i = 0; (protp = ppp_protocols[i]) != <a class="code" href="def_8h.html#a2">NULL</a>; ++i)
00712         <span class="keywordflow">if</span> (protp-&gt;protocol &lt; 0xC000 &amp;&amp; protp-&gt;enabled_flag
00713                 &amp;&amp; protp-&gt;open != <a class="code" href="def_8h.html#a2">NULL</a>) {
00714             (*protp-&gt;open)(unit);
00715             <span class="keywordflow">if</span> (protp-&gt;protocol != PPP_CCP)
00716                 ++num_np_open;
00717         }
00718     
00719     <span class="keywordflow">if</span> (num_np_open == 0)
00720         <span class="comment">/* nothing to do */</span>
00721         <a class="code" href="lcp_8h.html#a34">lcp_close</a>(0, <span class="stringliteral">"No network protocols running"</span>);
00722 }
00723 
00724 <span class="comment">/*</span>
00725 <span class="comment"> * check_idle - check whether the link has been idle for long</span>
00726 <span class="comment"> * enough that we can shut it down.</span>
00727 <span class="comment"> */</span>
00728 <span class="keyword">static</span> <span class="keywordtype">void</span> check_idle(<span class="keywordtype">void</span> *arg)
00729 {
00730     <span class="keyword">struct </span>ppp_idle idle;
00731     u_short itime;
00732     
00733         (<span class="keywordtype">void</span>)arg;
00734     <span class="keywordflow">if</span> (!get_idle_time(0, &amp;idle))
00735         <span class="keywordflow">return</span>;
00736     itime = <a class="code" href="def_8h.html#a1">LWIP_MIN</a>(idle.xmit_idle, idle.recv_idle);
00737     <span class="keywordflow">if</span> (itime &gt;= ppp_settings.idle_time_limit) {
00738         <span class="comment">/* link is idle: shut it down. */</span>
00739         <a class="code" href="pppdebug_8h.html#a15">ppp_trace</a>(LOG_INFO, <span class="stringliteral">"Terminating connection due to lack of activity.\n"</span>);
00740         <a class="code" href="lcp_8h.html#a34">lcp_close</a>(0, <span class="stringliteral">"Link inactive"</span>);
00741     } <span class="keywordflow">else</span> {
00742         TIMEOUT(check_idle, NULL, ppp_settings.idle_time_limit - itime);
00743     }
00744 }
00745 
00746 <span class="comment">/*</span>
00747 <span class="comment"> * connect_time_expired - log a message and close the connection.</span>
00748 <span class="comment"> */</span>
00749 <span class="keyword">static</span> <span class="keywordtype">void</span> connect_time_expired(<span class="keywordtype">void</span> *arg)
00750 {
00751         (<span class="keywordtype">void</span>)arg;
00752 
00753     <a class="code" href="pppdebug_8h.html#a15">ppp_trace</a>(LOG_INFO, <span class="stringliteral">"Connect time expired\n"</span>);
00754     <a class="code" href="lcp_8h.html#a34">lcp_close</a>(0, <span class="stringliteral">"Connect time expired"</span>);   <span class="comment">/* Close connection */</span>
00755 }
00756 
00757 <span class="preprocessor">#if 0</span>
00758 <span class="preprocessor"></span><span class="comment">/*</span>
00759 <span class="comment"> * login - Check the user name and password against the system</span>
00760 <span class="comment"> * password database, and login the user if OK.</span>
00761 <span class="comment"> *</span>
00762 <span class="comment"> * returns:</span>
00763 <span class="comment"> *  UPAP_AUTHNAK: Login failed.</span>
00764 <span class="comment"> *  UPAP_AUTHACK: Login succeeded.</span>
00765 <span class="comment"> * In either case, msg points to an appropriate message.</span>
00766 <span class="comment"> */</span>
00767 <span class="keyword">static</span> <span class="keywordtype">int</span> login(<span class="keywordtype">char</span> *user, <span class="keywordtype">char</span> *passwd, <span class="keywordtype">char</span> **msg, <span class="keywordtype">int</span> *msglen)
00768 {
00769     <span class="comment">/* XXX Fail until we decide that we want to support logins. */</span>
00770     <span class="keywordflow">return</span> (<a class="code" href="pap_8h.html#a3">UPAP_AUTHNAK</a>);
00771 }
00772 <span class="preprocessor">#endif</span>
00773 <span class="preprocessor"></span>
00774 <span class="comment">/*</span>
00775 <span class="comment"> * logout - Logout the user.</span>
00776 <span class="comment"> */</span>
00777 <span class="keyword">static</span> <span class="keywordtype">void</span> logout(<span class="keywordtype">void</span>)
00778 {
00779     logged_in = 0;
00780 }
00781 
00782 
00783 <span class="comment">/*</span>
00784 <span class="comment"> * null_login - Check if a username of "" and a password of "" are</span>
00785 <span class="comment"> * acceptable, and iff so, set the list of acceptable IP addresses</span>
00786 <span class="comment"> * and return 1.</span>
00787 <span class="comment"> */</span>
00788 <span class="keyword">static</span> <span class="keywordtype">int</span> null_login(<span class="keywordtype">int</span> unit)
00789 {
00790         (<span class="keywordtype">void</span>)unit;
00791     <span class="comment">/* XXX Fail until we decide that we want to support logins. */</span>
00792     <span class="keywordflow">return</span> 0;
00793 }
00794 
00795 
00796 <span class="comment">/*</span>
00797 <span class="comment"> * get_pap_passwd - get a password for authenticating ourselves with</span>
00798 <span class="comment"> * our peer using PAP.  Returns 1 on success, 0 if no suitable password</span>
00799 <span class="comment"> * could be found.</span>
00800 <span class="comment"> */</span>
00801 <span class="keyword">static</span> <span class="keywordtype">int</span> get_pap_passwd(<span class="keywordtype">int</span> unit, <span class="keywordtype">char</span> *user, <span class="keywordtype">char</span> *passwd)
00802 {
00803 <span class="comment">/* normally we would reject PAP if no password is provided,</span>
00804 <span class="comment">   but this causes problems with some providers (like CHT in Taiwan)</span>
00805 <span class="comment">   who incorrectly request PAP and expect a bogus/empty password, so</span>
00806 <span class="comment">   always provide a default user/passwd of "none"/"none"</span>
00807 <span class="comment">*/</span>
00808     <span class="keywordflow">if</span>(user)
00809         strcpy(user,   <span class="stringliteral">"none"</span>);
00810     <span class="keywordflow">if</span>(passwd)
00811         strcpy(passwd, <span class="stringliteral">"none"</span>);
00812 
00813     <span class="keywordflow">return</span> 1;
00814 }
00815 
00816 
00817 <span class="comment">/*</span>
00818 <span class="comment"> * have_pap_secret - check whether we have a PAP file with any</span>
00819 <span class="comment"> * secrets that we could possibly use for authenticating the peer.</span>
00820 <span class="comment"> */</span>
00821 <span class="keyword">static</span> <span class="keywordtype">int</span> have_pap_secret(<span class="keywordtype">void</span>)
00822 {
00823     <span class="comment">/* XXX Fail until we set up our passwords. */</span>
00824     <span class="keywordflow">return</span> 0;
00825 }
00826 
00827 
00828 <span class="comment">/*</span>
00829 <span class="comment"> * have_chap_secret - check whether we have a CHAP file with a</span>
00830 <span class="comment"> * secret that we could possibly use for authenticating `client'</span>
00831 <span class="comment"> * on `server'.  Either can be the null string, meaning we don't</span>
00832 <span class="comment"> * know the identity yet.</span>
00833 <span class="comment"> */</span>
00834 <span class="keyword">static</span> <span class="keywordtype">int</span> have_chap_secret(<span class="keywordtype">char</span> *client, <span class="keywordtype">char</span> *server, u32_t remote)
00835 {
00836         (<span class="keywordtype">void</span>)client;
00837         (<span class="keywordtype">void</span>)server;
00838         (<span class="keywordtype">void</span>)remote;
00839     <span class="comment">/* XXX Fail until we set up our passwords. */</span>
00840     <span class="keywordflow">return</span> 0;
00841 }
00842 
00843 
00844 <span class="preprocessor">#if PAP_SUPPORT &gt; 0 || CHAP_SUPPORT &gt; 0</span>
00845 <span class="preprocessor"></span><span class="comment">/*</span>
00846 <span class="comment"> * set_allowed_addrs() - set the list of allowed addresses.</span>
00847 <span class="comment"> */</span>
00848 <span class="keyword">static</span> <span class="keywordtype">void</span> set_allowed_addrs(<span class="keywordtype">int</span> unit, <span class="keyword">struct</span> <a class="code" href="classwordlist.html">wordlist</a> *addrs)
00849 {
00850     <span class="keywordflow">if</span> (addresses[unit] != <a class="code" href="def_8h.html#a2">NULL</a>)
00851         free_wordlist(addresses[unit]);
00852     addresses[unit] = addrs;
00853 
00854 <span class="preprocessor">#if 0</span>
00855 <span class="preprocessor"></span>    <span class="comment">/*</span>
00856 <span class="comment">     * If there's only one authorized address we might as well</span>
00857 <span class="comment">     * ask our peer for that one right away</span>
00858 <span class="comment">     */</span>
00859     <span class="keywordflow">if</span> (addrs != <a class="code" href="def_8h.html#a2">NULL</a> &amp;&amp; addrs-&gt;next == <a class="code" href="def_8h.html#a2">NULL</a>) {
00860         <span class="keywordtype">char</span> *p = addrs-&gt;word;
00861         <span class="keyword">struct </span><a class="code" href="structipcp__options.html">ipcp_options</a> *wo = &amp;<a class="code" href="ipcp_8h.html#a14">ipcp_wantoptions</a>[unit];
00862         u32_t a;
00863         <span class="keyword">struct </span>hostent *hp;
00864         
00865         <span class="keywordflow">if</span> (wo-&gt;hisaddr == 0 &amp;&amp; *p != <span class="charliteral">'!'</span> &amp;&amp; *p != <span class="charliteral">'-'</span>
00866                 &amp;&amp; strchr(p, <span class="charliteral">'/'</span>) == <a class="code" href="def_8h.html#a2">NULL</a>) {
00867             hp = gethostbyname(p);
00868             <span class="keywordflow">if</span> (hp != <a class="code" href="def_8h.html#a2">NULL</a> &amp;&amp; hp-&gt;h_addrtype == <a class="code" href="sockets_8h.html#a24">AF_INET</a>)
00869                 a = *(u32_t *)hp-&gt;h_addr;
00870             <span class="keywordflow">else</span>
00871                 a = <a class="code" href="inet_8c.html#a4">inet_addr</a>(p);
00872             <span class="keywordflow">if</span> (a != (u32_t) -1)
00873                 wo-&gt;hisaddr = a;
00874         }
00875     }
00876 <span class="preprocessor">#endif</span>
00877 <span class="preprocessor"></span>}
00878 <span class="preprocessor">#endif</span>
00879 <span class="preprocessor"></span>
00880 <span class="keyword">static</span> <span class="keywordtype">int</span> ip_addr_check(u32_t addr, <span class="keyword">struct</span> <a class="code" href="classwordlist.html">wordlist</a> *addrs)
00881 {
00882     
00883     <span class="comment">/* don't allow loopback or multicast address */</span>
00884     <span class="keywordflow">if</span> (<a class="code" href="auth_8h.html#a16">bad_ip_adrs</a>(addr))
00885         <span class="keywordflow">return</span> 0;
00886     
00887     <span class="keywordflow">if</span> (addrs == <a class="code" href="def_8h.html#a2">NULL</a>)
00888         <span class="keywordflow">return</span> !ppp_settings.auth_required;      <span class="comment">/* no addresses authorized */</span>
00889     
00890     <span class="comment">/* XXX All other addresses allowed. */</span>
00891     <span class="keywordflow">return</span> 1;
00892 }
00893 
00894 <span class="preprocessor">#if PAP_SUPPORT &gt; 0 || CHAP_SUPPORT</span>
00895 <span class="preprocessor"></span><span class="comment">/*</span>
00896 <span class="comment"> * free_wordlist - release memory allocated for a wordlist.</span>
00897 <span class="comment"> */</span>
00898 <span class="keyword">static</span> <span class="keywordtype">void</span> free_wordlist(<span class="keyword">struct</span> <a class="code" href="classwordlist.html">wordlist</a> *wp)
00899 {
00900     <span class="keyword">struct </span><a class="code" href="classwordlist.html">wordlist</a> *next;
00901     
00902     <span class="keywordflow">while</span> (wp != <a class="code" href="def_8h.html#a2">NULL</a>) {
00903         next = wp-&gt;next;
00904         free(wp);
00905         wp = next;
00906     }
00907 }
00908 <span class="preprocessor">#endif</span>
00909 <span class="preprocessor"></span>
00910 <span class="preprocessor">#endif </span><span class="comment">/* PPP_SUPPORT */</span>
</pre></div>	</td>
  </tr>
</table>
<hr>
<div align="center">Copyright (c) 2001-2003 Swedish Institute of Computer Science</div>
</html>
