
<html>
<head>
<title>lwIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="doxygen.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<table width="98%" border="0" align="center">
  <tr>
    <td>
      <h2>lwIP code documentation</h2>
<hr>

<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>tcp.c</h1><a href="tcp_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00007 <span class="comment">/*</span>
00008 <span class="comment"> * Copyright (c) 2001-2003 Swedish Institute of Computer Science.</span>
00009 <span class="comment"> * All rights reserved. </span>
00010 <span class="comment"> * </span>
00011 <span class="comment"> * Redistribution and use in source and binary forms, with or without modification, </span>
00012 <span class="comment"> * are permitted provided that the following conditions are met:</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span>
00015 <span class="comment"> *    this list of conditions and the following disclaimer.</span>
00016 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
00017 <span class="comment"> *    this list of conditions and the following disclaimer in the documentation</span>
00018 <span class="comment"> *    and/or other materials provided with the distribution.</span>
00019 <span class="comment"> * 3. The name of the author may not be used to endorse or promote products</span>
00020 <span class="comment"> *    derived from this software without specific prior written permission. </span>
00021 <span class="comment"> *</span>
00022 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED </span>
00023 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF </span>
00024 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT </span>
00025 <span class="comment"> * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, </span>
00026 <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT </span>
00027 <span class="comment"> * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS </span>
00028 <span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN </span>
00029 <span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING </span>
00030 <span class="comment"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY </span>
00031 <span class="comment"> * OF SUCH DAMAGE.</span>
00032 <span class="comment"> *</span>
00033 <span class="comment"> * This file is part of the lwIP TCP/IP stack.</span>
00034 <span class="comment"> * </span>
00035 <span class="comment"> * Author: Adam Dunkels &lt;adam@sics.se&gt;</span>
00036 <span class="comment"> *</span>
00037 <span class="comment"> */</span>
00038 
00039 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00040 <span class="comment">/* tcp.c</span>
00041 <span class="comment"> *</span>
00042 <span class="comment"> * This file contains common functions for the TCP implementation, such as functinos</span>
00043 <span class="comment"> * for manipulating the data structures and the TCP timer functions. TCP functions</span>
00044 <span class="comment"> * related to input and output is found in tcp_input.c and tcp_output.c respectively.</span>
00045 <span class="comment"> *</span>
00046 <span class="comment"> */</span>
00047 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00048 
00049 
00050 <span class="preprocessor">#include "<a class="code" href="opt_8h.html">lwip/opt.h</a>"</span>
00051 <span class="preprocessor">#include "<a class="code" href="def_8h.html">lwip/def.h</a>"</span>
00052 <span class="preprocessor">#include "<a class="code" href="mem_8h.html">lwip/mem.h</a>"</span>
00053 <span class="preprocessor">#include "<a class="code" href="memp_8h.html">lwip/memp.h</a>"</span>
00054 
00055 <span class="preprocessor">#include "<a class="code" href="tcp_8h.html">lwip/tcp.h</a>"</span>
00056 <span class="preprocessor">#if LWIP_TCP</span>
00057 <span class="preprocessor"></span>
00058 <span class="comment">/* Incremented every coarse grained timer shot</span>
00059 <span class="comment">   (typically every 500 ms, determined by TCP_COARSE_TIMEOUT). */</span>
00060 u32_t <a class="code" href="tcp_8h.html#a48">tcp_ticks</a>;
00061 <span class="keyword">const</span> u8_t tcp_backoff[13] =
00062     { 1, 2, 3, 4, 5, 6, 7, 7, 7, 7, 7, 7, 7};
00063 
00064 <span class="comment">/* The TCP PCB lists. */</span>
00065 <span class="keyword">struct </span><a class="code" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *<a class="code" href="tcp_8h.html#a49">tcp_listen_pcbs</a>;  <span class="comment">/* List of all TCP PCBs in LISTEN state. */</span>
00066 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *<a class="code" href="tcp_8h.html#a50">tcp_active_pcbs</a>;  <span class="comment">/* List of all TCP PCBs that are in a</span>
00067 <span class="comment">         state in which they accept or send</span>
00068 <span class="comment">         data. */</span>
00069 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *<a class="code" href="tcp_8h.html#a51">tcp_tw_pcbs</a>;      <span class="comment">/* List of all TCP PCBs in TIME-WAIT. */</span>
00070 
00071 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *<a class="code" href="tcp_8h.html#a52">tcp_tmp_pcb</a>;
00072 
00073 <span class="keyword">static</span> u8_t tcp_timer;
00074 
00075 <span class="keyword">static</span> u16_t tcp_new_port(<span class="keywordtype">void</span>);
00076 
00077 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00078 <span class="comment">/*</span>
00079 <span class="comment"> * tcp_init():</span>
00080 <span class="comment"> *</span>
00081 <span class="comment"> * Initializes the TCP layer.</span>
00082 <span class="comment"> */</span>
00083 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00084 <span class="keywordtype">void</span>
00085 <a class="code" href="tcp_8h.html#a64">tcp_init</a>(<span class="keywordtype">void</span>)
00086 {
00087   <span class="comment">/* Clear globals. */</span>
00088   <a class="code" href="tcp_8h.html#a49">tcp_listen_pcbs</a> = <a class="code" href="def_8h.html#a2">NULL</a>;
00089   <a class="code" href="tcp_8h.html#a50">tcp_active_pcbs</a> = <a class="code" href="def_8h.html#a2">NULL</a>;
00090   <a class="code" href="tcp_8h.html#a51">tcp_tw_pcbs</a> = <a class="code" href="def_8h.html#a2">NULL</a>;
00091   <a class="code" href="tcp_8h.html#a52">tcp_tmp_pcb</a> = <a class="code" href="def_8h.html#a2">NULL</a>;
00092   
00093   <span class="comment">/* initialize timer */</span>
00094   <a class="code" href="tcp_8h.html#a48">tcp_ticks</a> = 0;
00095   tcp_timer = 0;
00096   
00097 }
00098 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00099 <span class="comment">/*</span>
00100 <span class="comment"> * tcp_tmr():</span>
00101 <span class="comment"> *</span>
00102 <span class="comment"> * Called periodically to dispatch TCP timers.</span>
00103 <span class="comment"> *</span>
00104 <span class="comment"> */</span>
00105 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00106 <span class="keywordtype">void</span>
00107 <a class="code" href="tcp_8h.html#a65">tcp_tmr</a>(<span class="keywordtype">void</span>)
00108 {
00109   ++tcp_timer;
00110   <span class="keywordflow">if</span> (tcp_timer == 10) {
00111     tcp_timer = 0;
00112   }
00113   
00114   <span class="keywordflow">if</span> (tcp_timer &amp; 1) {
00115     <span class="comment">/* Call tcp_fasttmr() every 200 ms, i.e., every other timer</span>
00116 <span class="comment">       tcp_tmr() is called. */</span>
00117     <a class="code" href="tcp_8h.html#a83">tcp_fasttmr</a>();
00118   }
00119   <span class="keywordflow">if</span> (tcp_timer == 0 || tcp_timer == 5) {
00120     <span class="comment">/* Call tcp_slowtmr() every 500 ms, i.e., every fifth timer</span>
00121 <span class="comment">       tcp_tmr() is called. */</span>
00122     <a class="code" href="tcp_8h.html#a82">tcp_slowtmr</a>();
00123   }
00124 }
00125 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00126 <span class="comment">/*</span>
00127 <span class="comment"> * tcp_close():</span>
00128 <span class="comment"> *</span>
00129 <span class="comment"> * Closes the connection held by the PCB.</span>
00130 <span class="comment"> *</span>
00131 <span class="comment"> */</span>
00132 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00133 <a class="code" href="err_8h.html#a13">err_t</a>
00134 <a class="code" href="tcp_8h.html#a79">tcp_close</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
00135 {
00136   <a class="code" href="err_8h.html#a13">err_t</a> err;
00137 
00138 <span class="preprocessor">#if TCP_DEBUG</span>
00139 <span class="preprocessor"></span>  <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_close: closing in state "</span>));
00140   tcp_debug_print_state(pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a>);
00141   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"\n"</span>));
00142 <span class="preprocessor">#endif </span><span class="comment">/* TCP_DEBUG */</span>
00143   <span class="keywordflow">switch</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a>) {
00144   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a54">LISTEN</a>:
00145     err = <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00146     <a class="code" href="tcp_8h.html#a89">tcp_pcb_remove</a>((<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> **)&amp;tcp_listen_pcbs, pcb);
00147     <a class="code" href="memp_8c.html#a8">memp_free</a>(MEMP_TCP_PCB_LISTEN, pcb);
00148     pcb = <a class="code" href="def_8h.html#a2">NULL</a>;
00149     <span class="keywordflow">break</span>;
00150   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a55">SYN_SENT</a>:
00151     err = <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00152     <a class="code" href="tcp_8h.html#a89">tcp_pcb_remove</a>(&amp;tcp_active_pcbs, pcb);
00153     <a class="code" href="memp_8c.html#a8">memp_free</a>(MEMP_TCP_PCB, pcb);
00154     pcb = <a class="code" href="def_8h.html#a2">NULL</a>;
00155     <span class="keywordflow">break</span>;
00156   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a56">SYN_RCVD</a>:
00157     err = <a class="code" href="tcp_8h.html#a93">tcp_send_ctrl</a>(pcb, TCP_FIN);
00158     <span class="keywordflow">if</span> (err == <a class="code" href="err_8h.html#a0">ERR_OK</a>) {
00159       pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> = <a class="code" href="tcp_8h.html#a99a58">FIN_WAIT_1</a>;
00160     }
00161     <span class="keywordflow">break</span>;
00162   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a57">ESTABLISHED</a>:
00163     err = <a class="code" href="tcp_8h.html#a93">tcp_send_ctrl</a>(pcb, TCP_FIN);
00164     <span class="keywordflow">if</span> (err == <a class="code" href="err_8h.html#a0">ERR_OK</a>) {
00165       pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> = <a class="code" href="tcp_8h.html#a99a58">FIN_WAIT_1</a>;
00166     }
00167     <span class="keywordflow">break</span>;
00168   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a60">CLOSE_WAIT</a>:
00169     err = <a class="code" href="tcp_8h.html#a93">tcp_send_ctrl</a>(pcb, TCP_FIN);
00170     <span class="keywordflow">if</span> (err == <a class="code" href="err_8h.html#a0">ERR_OK</a>) {
00171       pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> = <a class="code" href="tcp_8h.html#a99a62">LAST_ACK</a>;
00172     }
00173     <span class="keywordflow">break</span>;
00174   <span class="keywordflow">default</span>:
00175     <span class="comment">/* Has already been closed, do nothing. */</span>
00176     err = <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00177     pcb = <a class="code" href="def_8h.html#a2">NULL</a>;
00178     <span class="keywordflow">break</span>;
00179   }
00180 
00181   <span class="keywordflow">if</span> (pcb != <a class="code" href="def_8h.html#a2">NULL</a> &amp;&amp; err == <a class="code" href="err_8h.html#a0">ERR_OK</a>) {
00182     err = <a class="code" href="tcp_8h.html#a85">tcp_output</a>(pcb);
00183   }
00184   <span class="keywordflow">return</span> err;
00185 }
00186 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00187 <span class="comment">/*</span>
00188 <span class="comment"> * tcp_abort()</span>
00189 <span class="comment"> *</span>
00190 <span class="comment"> * Aborts a connection by sending a RST to the remote host and deletes</span>
00191 <span class="comment"> * the local protocol control block. This is done when a connection is</span>
00192 <span class="comment"> * killed because of shortage of memory.</span>
00193 <span class="comment"> *</span>
00194 <span class="comment"> */</span>
00195 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00196 <span class="keywordtype">void</span>
00197 <a class="code" href="tcp_8h.html#a78">tcp_abort</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
00198 {
00199   u32_t seqno, ackno;
00200   u16_t remote_port, local_port;
00201   <span class="keyword">struct </span><a class="code" href="structip__addr.html">ip_addr</a> remote_ip, local_ip;
00202 <span class="preprocessor">#if LWIP_CALLBACK_API  </span>
00203 <span class="preprocessor"></span>  void (* errf)(<span class="keywordtype">void</span> *arg, <a class="code" href="err_8h.html#a13">err_t</a> err);
00204 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>
00205   <span class="keywordtype">void</span> *errf_arg;
00206 
00207   
00208   <span class="comment">/* Figure out on which TCP PCB list we are, and remove us. If we</span>
00209 <span class="comment">     are in an active state, call the receive function associated with</span>
00210 <span class="comment">     the PCB with a NULL argument, and send an RST to the remote end. */</span>
00211   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> == <a class="code" href="tcp_8h.html#a99a63">TIME_WAIT</a>) {
00212     <a class="code" href="tcp_8h.html#a89">tcp_pcb_remove</a>(&amp;tcp_tw_pcbs, pcb);
00213     <a class="code" href="memp_8c.html#a8">memp_free</a>(MEMP_TCP_PCB, pcb);
00214   } <span class="keywordflow">else</span> {
00215     seqno = pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a>;
00216     ackno = pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>;
00217     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a27">ip_addr_set</a>(&amp;local_ip, &amp;(pcb-&gt;<a class="code" href="structtcp__pcb.html#o3">local_ip</a>));
00218     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a27">ip_addr_set</a>(&amp;remote_ip, &amp;(pcb-&gt;<a class="code" href="structtcp__pcb.html#o6">remote_ip</a>));
00219     local_port = pcb-&gt;<a class="code" href="structtcp__pcb.html#o4">local_port</a>;
00220     remote_port = pcb-&gt;<a class="code" href="structtcp__pcb.html#o7">remote_port</a>;
00221 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
00222 <span class="preprocessor"></span>    errf = pcb-&gt;errf;
00223 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>
00224     errf_arg = pcb-&gt;<a class="code" href="structtcp__pcb.html#o2">callback_arg</a>;
00225     <a class="code" href="tcp_8h.html#a89">tcp_pcb_remove</a>(&amp;tcp_active_pcbs, pcb);
00226     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> != <a class="code" href="def_8h.html#a2">NULL</a>) {
00227       <a class="code" href="tcp_8h.html#a90">tcp_segs_free</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>);
00228     }
00229     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a> != <a class="code" href="def_8h.html#a2">NULL</a>) {
00230       <a class="code" href="tcp_8h.html#a90">tcp_segs_free</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a>);
00231     }
00232 <span class="preprocessor">#if TCP_QUEUE_OOSEQ    </span>
00233 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (pcb-&gt;ooseq != <a class="code" href="def_8h.html#a2">NULL</a>) {
00234       <a class="code" href="tcp_8h.html#a90">tcp_segs_free</a>(pcb-&gt;ooseq);
00235     }
00236 <span class="preprocessor">#endif </span><span class="comment">/* TCP_QUEUE_OOSEQ */</span>
00237     <a class="code" href="memp_8c.html#a8">memp_free</a>(MEMP_TCP_PCB, pcb);
00238     <a class="code" href="tcp_8h.html#a40">TCP_EVENT_ERR</a>(errf, errf_arg, ERR_ABRT);
00239     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_RST_DEBUG, (<span class="stringliteral">"tcp_abort: sending RST\n"</span>));
00240     <a class="code" href="tcp_8h.html#a96">tcp_rst</a>(seqno, ackno, &amp;local_ip, &amp;remote_ip, local_port, remote_port);
00241   }
00242 }
00243 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00244 <span class="comment">/*</span>
00245 <span class="comment"> * tcp_bind():</span>
00246 <span class="comment"> *</span>
00247 <span class="comment"> * Binds the connection to a local portnumber and IP address. If the</span>
00248 <span class="comment"> * IP address is not given (i.e., ipaddr == NULL), the IP address of</span>
00249 <span class="comment"> * the outgoing network interface is used instead.</span>
00250 <span class="comment"> *</span>
00251 <span class="comment"> */</span>
00252 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00253 <a class="code" href="err_8h.html#a13">err_t</a>
00254 <a class="code" href="tcp_8h.html#a75">tcp_bind</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *ipaddr, u16_t port)
00255 {
00256   <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *cpcb;
00257 
00258   <span class="keywordflow">if</span> (port == 0) {
00259     port = tcp_new_port();
00260   }
00261 
00262   <span class="comment">/* Check if the address already is in use. */</span>
00263   <span class="keywordflow">for</span>(cpcb = (<span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *)<a class="code" href="tcp_8h.html#a49">tcp_listen_pcbs</a>;
00264       cpcb != <a class="code" href="def_8h.html#a2">NULL</a>; cpcb = cpcb-&gt;next) {
00265     <span class="keywordflow">if</span> (cpcb-&gt;local_port == port) {
00266       <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;(cpcb-&gt;local_ip)) ||
00267         <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(ipaddr) ||
00268         <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(cpcb-&gt;local_ip), ipaddr)) {
00269           <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a10">ERR_USE</a>;
00270       }
00271     }
00272   }
00273   <span class="keywordflow">for</span>(cpcb = <a class="code" href="tcp_8h.html#a50">tcp_active_pcbs</a>;
00274       cpcb != <a class="code" href="def_8h.html#a2">NULL</a>; cpcb = cpcb-&gt;next) {
00275     <span class="keywordflow">if</span> (cpcb-&gt;local_port == port) {
00276       <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;(cpcb-&gt;local_ip)) ||
00277    <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(ipaddr) ||
00278    <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(cpcb-&gt;local_ip), ipaddr)) {
00279   <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a10">ERR_USE</a>;
00280       }
00281     }
00282   }
00283   <span class="keywordflow">if</span> (!<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(ipaddr)) {
00284     pcb-&gt;<a class="code" href="structtcp__pcb.html#o3">local_ip</a> = *ipaddr;
00285   }
00286   pcb-&gt;<a class="code" href="structtcp__pcb.html#o4">local_port</a> = port;
00287   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_bind: bind to port %u\n"</span>, port));
00288   <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00289 }
00290 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
00291 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="err_8h.html#a13">err_t</a>
00292 tcp_accept_null(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="code" href="err_8h.html#a13">err_t</a> err)
00293 {
00294   (<span class="keywordtype">void</span>)arg;
00295   (<span class="keywordtype">void</span>)pcb;
00296   (<span class="keywordtype">void</span>)err;
00297 
00298   <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a3">ERR_ABRT</a>;
00299 }
00300 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>
00301 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00302 <span class="comment">/*</span>
00303 <span class="comment"> * tcp_listen():</span>
00304 <span class="comment"> *</span>
00305 <span class="comment"> * Set the state of the connection to be LISTEN, which means that it</span>
00306 <span class="comment"> * is able to accept incoming connections. The protocol control block</span>
00307 <span class="comment"> * is reallocated in order to consume less memory. Setting the</span>
00308 <span class="comment"> * connection to LISTEN is an irreversible process.</span>
00309 <span class="comment"> *</span>
00310 <span class="comment"> */</span>
00311 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00312 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *
00313 <a class="code" href="tcp_8h.html#a77">tcp_listen</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
00314 {
00315   <span class="keyword">struct </span><a class="code" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *lpcb;
00316 
00317   <span class="comment">/* already listening? */</span>
00318   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> == <a class="code" href="tcp_8h.html#a99a54">LISTEN</a>) {
00319     <span class="keywordflow">return</span> pcb;
00320   }
00321   lpcb = <a class="code" href="memp_8c.html#a6">memp_malloc</a>(MEMP_TCP_PCB_LISTEN);
00322   <span class="keywordflow">if</span> (lpcb == <a class="code" href="def_8h.html#a2">NULL</a>) {
00323     <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00324   }
00325   lpcb-&gt;callback_arg = pcb-&gt;<a class="code" href="structtcp__pcb.html#o2">callback_arg</a>;
00326   lpcb-&gt;local_port = pcb-&gt;<a class="code" href="structtcp__pcb.html#o4">local_port</a>;
00327   lpcb-&gt;state = <a class="code" href="tcp_8h.html#a99a54">LISTEN</a>;
00328   <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a27">ip_addr_set</a>(&amp;lpcb-&gt;local_ip, &amp;pcb-&gt;<a class="code" href="structtcp__pcb.html#o3">local_ip</a>);
00329   <a class="code" href="memp_8c.html#a8">memp_free</a>(MEMP_TCP_PCB, pcb);
00330 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
00331 <span class="preprocessor"></span>  lpcb-&gt;accept = tcp_accept_null;
00332 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>
00333   <a class="code" href="tcp_8h.html#a44">TCP_REG</a>(&amp;tcp_listen_pcbs, lpcb);
00334   <span class="keywordflow">return</span> (<span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *)lpcb;
00335 }
00336 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00337 <span class="comment">/*</span>
00338 <span class="comment"> * tcp_recved():</span>
00339 <span class="comment"> *</span>
00340 <span class="comment"> * This function should be called by the application when it has</span>
00341 <span class="comment"> * processed the data. The purpose is to advertise a larger window</span>
00342 <span class="comment"> * when the data has been processed.</span>
00343 <span class="comment"> *</span>
00344 <span class="comment"> */</span>
00345 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00346 <span class="keywordtype">void</span>
00347 <a class="code" href="tcp_8h.html#a74">tcp_recved</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u16_t len)
00348 {
00349   pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a> += len;
00350   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a> &gt; <a class="code" href="opt_8h.html#a32">TCP_WND</a>) {
00351     pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a> = <a class="code" href="opt_8h.html#a32">TCP_WND</a>;
00352   }
00353   <span class="keywordflow">if</span> (!(pcb-&gt;<a class="code" href="structtcp__pcb.html#o15">flags</a> &amp; <a class="code" href="tcp_8h.html#a29">TF_ACK_DELAY</a>) &amp;&amp;
00354      !(pcb-&gt;<a class="code" href="structtcp__pcb.html#o15">flags</a> &amp; <a class="code" href="tcp_8h.html#a30">TF_ACK_NOW</a>)) {
00355     <a class="code" href="tcp_8h.html#a41">tcp_ack</a>(pcb);
00356   }
00357 
00358   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_recved: recveived %u bytes, wnd %u (%u).\n"</span>,
00359          len, pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a>, TCP_WND - pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a>));
00360 }
00361 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00362 <span class="comment">/*</span>
00363 <span class="comment"> * tcp_new_port():</span>
00364 <span class="comment"> *</span>
00365 <span class="comment"> * A nastly hack featuring 'goto' statements that allocates a</span>
00366 <span class="comment"> * new TCP local port.</span>
00367 <span class="comment"> */</span>
00368 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00369 <span class="keyword">static</span> u16_t
00370 tcp_new_port(<span class="keywordtype">void</span>)
00371 {
00372   <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb;
00373 <span class="preprocessor">#ifndef TCP_LOCAL_PORT_RANGE_START</span>
00374 <span class="preprocessor"></span><span class="preprocessor">#define TCP_LOCAL_PORT_RANGE_START 4096</span>
00375 <span class="preprocessor"></span><span class="preprocessor">#define TCP_LOCAL_PORT_RANGE_END   0x7fff</span>
00376 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00377 <span class="preprocessor"></span>  <span class="keyword">static</span> u16_t port = TCP_LOCAL_PORT_RANGE_START;
00378   
00379  again:
00380   <span class="keywordflow">if</span> (++port &gt; TCP_LOCAL_PORT_RANGE_END) {
00381     port = TCP_LOCAL_PORT_RANGE_START;
00382   }
00383   
00384   <span class="keywordflow">for</span>(pcb = <a class="code" href="tcp_8h.html#a50">tcp_active_pcbs</a>; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>) {
00385     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o4">local_port</a> == port) {
00386       <span class="keywordflow">goto</span> again;
00387     }
00388   }
00389   <span class="keywordflow">for</span>(pcb = <a class="code" href="tcp_8h.html#a51">tcp_tw_pcbs</a>; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>) {
00390     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o4">local_port</a> == port) {
00391       <span class="keywordflow">goto</span> again;
00392     }
00393   }
00394   <span class="keywordflow">for</span>(pcb = (<span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *)<a class="code" href="tcp_8h.html#a49">tcp_listen_pcbs</a>; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>) {
00395     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o4">local_port</a> == port) {
00396       <span class="keywordflow">goto</span> again;
00397     }
00398   }
00399   <span class="keywordflow">return</span> port;
00400 }
00401 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00402 <span class="comment">/*</span>
00403 <span class="comment"> * tcp_connect():</span>
00404 <span class="comment"> *</span>
00405 <span class="comment"> * Connects to another host. The function given as the "connected"</span>
00406 <span class="comment"> * argument will be called when the connection has been established.</span>
00407 <span class="comment"> *</span>
00408 <span class="comment"> */</span>
00409 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00410 <a class="code" href="err_8h.html#a13">err_t</a>
00411 <a class="code" href="tcp_8h.html#a76">tcp_connect</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *ipaddr, u16_t port,
00412       <a class="code" href="err_8h.html#a13">err_t</a> (* connected)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *tpcb, <a class="code" href="err_8h.html#a13">err_t</a> err))
00413 {
00414   u32_t optdata;
00415   <a class="code" href="err_8h.html#a13">err_t</a> ret;
00416   u32_t iss;
00417 
00418   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_connect to port %u\n"</span>, port));
00419   <span class="keywordflow">if</span> (ipaddr != <a class="code" href="def_8h.html#a2">NULL</a>) {
00420     pcb-&gt;<a class="code" href="structtcp__pcb.html#o6">remote_ip</a> = *ipaddr;
00421   } <span class="keywordflow">else</span> {
00422     <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a7">ERR_VAL</a>;
00423   }
00424   pcb-&gt;<a class="code" href="structtcp__pcb.html#o7">remote_port</a> = port;
00425   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o4">local_port</a> == 0) {
00426     pcb-&gt;<a class="code" href="structtcp__pcb.html#o4">local_port</a> = tcp_new_port();
00427   }
00428   iss = <a class="code" href="tcp_8h.html#a97">tcp_next_iss</a>();
00429   pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a> = 0;
00430   pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a> = iss;
00431   pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a> = iss - 1;
00432   pcb-&gt;<a class="code" href="structtcp__pcb.html#o31">snd_lbb</a> = iss - 1;
00433   pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a> = <a class="code" href="opt_8h.html#a32">TCP_WND</a>;
00434   pcb-&gt;<a class="code" href="structtcp__pcb.html#o28">snd_wnd</a> = <a class="code" href="opt_8h.html#a32">TCP_WND</a>;
00435   pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a> = <a class="code" href="opt_8h.html#a36">TCP_MSS</a>;
00436   pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a> = 1;
00437   pcb-&gt;<a class="code" href="structtcp__pcb.html#o25">ssthresh</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a> * 10;
00438   pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> = <a class="code" href="tcp_8h.html#a99a55">SYN_SENT</a>;
00439 <span class="preprocessor">#if LWIP_CALLBACK_API  </span>
00440 <span class="preprocessor"></span>  pcb-&gt;connected = connected;
00441 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>  
00442   <a class="code" href="tcp_8h.html#a44">TCP_REG</a>(&amp;tcp_active_pcbs, pcb);
00443   
00444   <span class="comment">/* Build an MSS option */</span>
00445   optdata = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(((u32_t)2 &lt;&lt; 24) | 
00446       ((u32_t)4 &lt;&lt; 16) | 
00447       (((u32_t)pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a> / 256) &lt;&lt; 8) |
00448       (pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a> &amp; 255));
00449 
00450   ret = <a class="code" href="tcp_8h.html#a94">tcp_enqueue</a>(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&amp;optdata, 4);
00451   <span class="keywordflow">if</span> (ret == <a class="code" href="err_8h.html#a0">ERR_OK</a>) { 
00452     <a class="code" href="tcp_8h.html#a85">tcp_output</a>(pcb);
00453   }
00454   <span class="keywordflow">return</span> ret;
00455 } 
00456 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00457 <span class="comment">/*</span>
00458 <span class="comment"> * tcp_slowtmr():</span>
00459 <span class="comment"> *</span>
00460 <span class="comment"> * Called every 500 ms and implements the retransmission timer and the timer that</span>
00461 <span class="comment"> * removes PCBs that have been in TIME-WAIT for enough time. It also increments</span>
00462 <span class="comment"> * various timers such as the inactivity timer in each PCB.</span>
00463 <span class="comment"> */</span>
00464 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00465 <span class="keywordtype">void</span>
00466 <a class="code" href="tcp_8h.html#a82">tcp_slowtmr</a>(<span class="keywordtype">void</span>)
00467 {
00468   <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, *pcb2, *prev;
00469   u32_t eff_wnd;
00470   u8_t pcb_remove;      <span class="comment">/* flag if a PCB should be removed */</span>
00471   <a class="code" href="err_8h.html#a13">err_t</a> err;
00472 
00473   err = <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00474 
00475   ++<a class="code" href="tcp_8h.html#a48">tcp_ticks</a>;
00476 
00477   <span class="comment">/* Steps through all of the active PCBs. */</span>
00478   prev = <a class="code" href="def_8h.html#a2">NULL</a>;
00479   pcb = <a class="code" href="tcp_8h.html#a50">tcp_active_pcbs</a>;
00480   <span class="keywordflow">if</span> (pcb == <a class="code" href="def_8h.html#a2">NULL</a>) <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_slowtmr: no active pcbs\n"</span>));
00481   <span class="keywordflow">while</span> (pcb != <a class="code" href="def_8h.html#a2">NULL</a>) {
00482     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_slowtmr: processing active pcb\n"</span>));
00483     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_slowtmr: active pcb-&gt;state != CLOSED\n"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> != CLOSED);
00484     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_slowtmr: active pcb-&gt;state != LISTEN\n"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> != LISTEN);
00485     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_slowtmr: active pcb-&gt;state != TIME-WAIT\n"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> != TIME_WAIT);
00486 
00487     pcb_remove = 0;
00488 
00489     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> == <a class="code" href="tcp_8h.html#a99a55">SYN_SENT</a> &amp;&amp; pcb-&gt;<a class="code" href="structtcp__pcb.html#o21">nrtx</a> == <a class="code" href="opt_8h.html#a34">TCP_SYNMAXRTX</a>) {
00490       ++pcb_remove;
00491       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_slowtmr: max SYN retries reached\n"</span>));
00492     }
00493     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o21">nrtx</a> == <a class="code" href="opt_8h.html#a33">TCP_MAXRTX</a>) {
00494       ++pcb_remove;
00495       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_slowtmr: max DATA retries reached\n"</span>));
00496     } <span class="keywordflow">else</span> {
00497       ++pcb-&gt;<a class="code" href="structtcp__pcb.html#o13">rtime</a>;
00498       <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> != <a class="code" href="def_8h.html#a2">NULL</a> &amp;&amp; pcb-&gt;<a class="code" href="structtcp__pcb.html#o13">rtime</a> &gt;= pcb-&gt;<a class="code" href="structtcp__pcb.html#o20">rto</a>) {
00499 
00500         <span class="comment">/* Time for a retransmission. */</span>
00501         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_RTO_DEBUG, (<span class="stringliteral">"tcp_slowtmr: rtime %u pcb-&gt;rto %u\n"</span>,
00502           pcb-&gt;<a class="code" href="structtcp__pcb.html#o13">rtime</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o20">rto</a>));
00503 
00504         <span class="comment">/* Double retransmission time-out unless we are trying to</span>
00505 <span class="comment">         * connect to somebody (i.e., we are in SYN_SENT). */</span>
00506         <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> != <a class="code" href="tcp_8h.html#a99a55">SYN_SENT</a>) {
00507           pcb-&gt;<a class="code" href="structtcp__pcb.html#o20">rto</a> = ((pcb-&gt;<a class="code" href="structtcp__pcb.html#o18">sa</a> &gt;&gt; 3) + pcb-&gt;<a class="code" href="structtcp__pcb.html#o19">sv</a>) &lt;&lt; tcp_backoff[pcb-&gt;<a class="code" href="structtcp__pcb.html#o21">nrtx</a>];
00508         }
00509         <a class="code" href="tcp_8h.html#a86">tcp_rexmit</a>(pcb);
00510         <span class="comment">/* Reduce congestion window and ssthresh. */</span>
00511         eff_wnd = <a class="code" href="def_8h.html#a1">LWIP_MIN</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o28">snd_wnd</a>);
00512         pcb-&gt;<a class="code" href="structtcp__pcb.html#o25">ssthresh</a> = eff_wnd &gt;&gt; 1;
00513         <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o25">ssthresh</a> &lt; pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a>) {
00514           pcb-&gt;<a class="code" href="structtcp__pcb.html#o25">ssthresh</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a> * 2;
00515         }
00516         pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a>;
00517         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_CWND_DEBUG, (<span class="stringliteral">"tcp_slowtmr: cwnd %u ssthresh %u\n"</span>,
00518                                 pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o25">ssthresh</a>));
00519       }
00520     }
00521     <span class="comment">/* Check if this PCB has stayed too long in FIN-WAIT-2 */</span>
00522     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> == <a class="code" href="tcp_8h.html#a99a59">FIN_WAIT_2</a>) {
00523       <span class="keywordflow">if</span> ((u32_t)(<a class="code" href="tcp_8h.html#a48">tcp_ticks</a> - pcb-&gt;<a class="code" href="structtcp__pcb.html#o10">tmr</a>) &gt;
00524         <a class="code" href="tcp_8h.html#a20">TCP_FIN_WAIT_TIMEOUT</a> / <a class="code" href="tcp_8h.html#a19">TCP_SLOW_INTERVAL</a>) {
00525         ++pcb_remove;
00526         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"</span>));
00527       }
00528     }
00529 
00530     <span class="comment">/* If this PCB has queued out of sequence data, but has been</span>
00531 <span class="comment">       inactive for too long, will drop the data (it will eventually</span>
00532 <span class="comment">       be retransmitted). */</span>
00533 <span class="preprocessor">#if TCP_QUEUE_OOSEQ    </span>
00534 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (pcb-&gt;ooseq != <a class="code" href="def_8h.html#a2">NULL</a> &amp;&amp;
00535        (u32_t)<a class="code" href="tcp_8h.html#a48">tcp_ticks</a> - pcb-&gt;<a class="code" href="structtcp__pcb.html#o10">tmr</a> &gt;=
00536        pcb-&gt;<a class="code" href="structtcp__pcb.html#o20">rto</a> * <a class="code" href="tcp_8h.html#a22">TCP_OOSEQ_TIMEOUT</a>) {
00537       <a class="code" href="tcp_8h.html#a90">tcp_segs_free</a>(pcb-&gt;ooseq);
00538       pcb-&gt;ooseq = <a class="code" href="def_8h.html#a2">NULL</a>;
00539       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_CWND_DEBUG, (<span class="stringliteral">"tcp_slowtmr: dropping OOSEQ queued data\n"</span>));
00540     }
00541 <span class="preprocessor">#endif </span><span class="comment">/* TCP_QUEUE_OOSEQ */</span>
00542 
00543     <span class="comment">/* Check if this PCB has stayed too long in SYN-RCVD */</span>
00544     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> == <a class="code" href="tcp_8h.html#a99a56">SYN_RCVD</a>) {
00545       <span class="keywordflow">if</span> ((u32_t)(<a class="code" href="tcp_8h.html#a48">tcp_ticks</a> - pcb-&gt;<a class="code" href="structtcp__pcb.html#o10">tmr</a>) &gt;
00546    <a class="code" href="tcp_8h.html#a21">TCP_SYN_RCVD_TIMEOUT</a> / <a class="code" href="tcp_8h.html#a19">TCP_SLOW_INTERVAL</a>) {
00547         ++pcb_remove;
00548         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"</span>));
00549       }
00550     }
00551 
00552 
00553     <span class="comment">/* If the PCB should be removed, do it. */</span>
00554     <span class="keywordflow">if</span> (pcb_remove) {
00555       <a class="code" href="tcp_8h.html#a88">tcp_pcb_purge</a>(pcb);      
00556       <span class="comment">/* Remove PCB from tcp_active_pcbs list. */</span>
00557       <span class="keywordflow">if</span> (prev != <a class="code" href="def_8h.html#a2">NULL</a>) {
00558   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_slowtmr: middle tcp != tcp_active_pcbs"</span>, pcb != tcp_active_pcbs);
00559         prev-&gt;next = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>;
00560       } <span class="keywordflow">else</span> {
00561         <span class="comment">/* This PCB was the first. */</span>
00562         <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_slowtmr: first pcb == tcp_active_pcbs"</span>, tcp_active_pcbs == pcb);
00563         <a class="code" href="tcp_8h.html#a50">tcp_active_pcbs</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>;
00564       }
00565 
00566       <a class="code" href="tcp_8h.html#a40">TCP_EVENT_ERR</a>(pcb-&gt;errf, pcb-&gt;<a class="code" href="structtcp__pcb.html#o2">callback_arg</a>, ERR_ABRT);
00567 
00568       pcb2 = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>;
00569       <a class="code" href="memp_8c.html#a8">memp_free</a>(MEMP_TCP_PCB, pcb);
00570       pcb = pcb2;
00571     } <span class="keywordflow">else</span> {
00572 
00573       <span class="comment">/* We check if we should poll the connection. */</span>
00574       ++pcb-&gt;<a class="code" href="structtcp__pcb.html#o11">polltmr</a>;
00575       <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o11">polltmr</a> &gt;= pcb-&gt;<a class="code" href="structtcp__pcb.html#o12">pollinterval</a>) {
00576         pcb-&gt;<a class="code" href="structtcp__pcb.html#o11">polltmr</a> = 0;
00577         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_slowtmr: polling application\n"</span>));
00578         <a class="code" href="tcp_8h.html#a39">TCP_EVENT_POLL</a>(pcb, err);
00579         <span class="keywordflow">if</span> (err == <a class="code" href="err_8h.html#a0">ERR_OK</a>) {
00580           <a class="code" href="tcp_8h.html#a85">tcp_output</a>(pcb);
00581         }
00582       }
00583       
00584       prev = pcb;
00585       pcb = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>;
00586     }
00587   }
00588 
00589   
00590   <span class="comment">/* Steps through all of the TIME-WAIT PCBs. */</span>
00591   prev = <a class="code" href="def_8h.html#a2">NULL</a>;    
00592   pcb = <a class="code" href="tcp_8h.html#a51">tcp_tw_pcbs</a>;
00593   <span class="keywordflow">while</span> (pcb != <a class="code" href="def_8h.html#a2">NULL</a>) {
00594     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_slowtmr: TIME-WAIT pcb-&gt;state == TIME-WAIT"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> == TIME_WAIT);
00595     pcb_remove = 0;
00596 
00597     <span class="comment">/* Check if this PCB has stayed long enough in TIME-WAIT */</span>
00598     <span class="keywordflow">if</span> ((u32_t)(<a class="code" href="tcp_8h.html#a48">tcp_ticks</a> - pcb-&gt;<a class="code" href="structtcp__pcb.html#o10">tmr</a>) &gt; 2 * <a class="code" href="tcp_8h.html#a23">TCP_MSL</a> / <a class="code" href="tcp_8h.html#a19">TCP_SLOW_INTERVAL</a>) {
00599       ++pcb_remove;
00600     }
00601     
00602 
00603 
00604     <span class="comment">/* If the PCB should be removed, do it. */</span>
00605     <span class="keywordflow">if</span> (pcb_remove) {
00606       <a class="code" href="tcp_8h.html#a88">tcp_pcb_purge</a>(pcb);      
00607       <span class="comment">/* Remove PCB from tcp_tw_pcbs list. */</span>
00608       <span class="keywordflow">if</span> (prev != <a class="code" href="def_8h.html#a2">NULL</a>) {
00609   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_slowtmr: middle tcp != tcp_tw_pcbs"</span>, pcb != tcp_tw_pcbs);
00610         prev-&gt;next = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>;
00611       } <span class="keywordflow">else</span> {
00612         <span class="comment">/* This PCB was the first. */</span>
00613         <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_slowtmr: first pcb == tcp_tw_pcbs"</span>, tcp_tw_pcbs == pcb);
00614         <a class="code" href="tcp_8h.html#a51">tcp_tw_pcbs</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>;
00615       }
00616       pcb2 = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>;
00617       <a class="code" href="memp_8c.html#a8">memp_free</a>(MEMP_TCP_PCB, pcb);
00618       pcb = pcb2;
00619     } <span class="keywordflow">else</span> {
00620       prev = pcb;
00621       pcb = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>;
00622     }
00623   }
00624 }
00625 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00626 <span class="comment">/*</span>
00627 <span class="comment"> * tcp_fasttmr():</span>
00628 <span class="comment"> *</span>
00629 <span class="comment"> * Is called every TCP_FINE_TIMEOUT (100 ms) and sends delayed ACKs.</span>
00630 <span class="comment"> */</span>
00631 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00632 <span class="keywordtype">void</span>
00633 <a class="code" href="tcp_8h.html#a83">tcp_fasttmr</a>(<span class="keywordtype">void</span>)
00634 {
00635   <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb;
00636 
00637   <span class="comment">/* send delayed ACKs */</span>  
00638   <span class="keywordflow">for</span>(pcb = <a class="code" href="tcp_8h.html#a50">tcp_active_pcbs</a>; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>) {
00639     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o15">flags</a> &amp; <a class="code" href="tcp_8h.html#a29">TF_ACK_DELAY</a>) {
00640       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_fasttmr: delayed ACK\n"</span>));
00641       <a class="code" href="tcp_8h.html#a42">tcp_ack_now</a>(pcb);
00642       pcb-&gt;<a class="code" href="structtcp__pcb.html#o15">flags</a> &amp;= ~(<a class="code" href="tcp_8h.html#a29">TF_ACK_DELAY</a> | <a class="code" href="tcp_8h.html#a30">TF_ACK_NOW</a>);
00643     }
00644   }
00645 }
00646 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00647 <span class="comment">/*</span>
00648 <span class="comment"> * tcp_segs_free():</span>
00649 <span class="comment"> *</span>
00650 <span class="comment"> * Deallocates a list of TCP segments (tcp_seg structures).</span>
00651 <span class="comment"> *</span>
00652 <span class="comment"> */</span>
00653 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00654 u8_t
00655 <a class="code" href="tcp_8h.html#a90">tcp_segs_free</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a> *seg)
00656 {
00657   u8_t count = 0;
00658   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *next;
00659  again:  
00660   <span class="keywordflow">if</span> (seg != <a class="code" href="def_8h.html#a2">NULL</a>) {
00661     next = seg-&gt;<a class="code" href="structtcp__seg.html#o0">next</a>;
00662     count += <a class="code" href="tcp_8h.html#a91">tcp_seg_free</a>(seg);
00663     seg = next;
00664     <span class="keywordflow">goto</span> again;
00665   }
00666   <span class="keywordflow">return</span> count;
00667 }
00668 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00669 <span class="comment">/*</span>
00670 <span class="comment"> * tcp_seg_free():</span>
00671 <span class="comment"> *</span>
00672 <span class="comment"> * Frees a TCP segment.</span>
00673 <span class="comment"> *</span>
00674 <span class="comment"> */</span>
00675 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00676 u8_t
00677 <a class="code" href="tcp_8h.html#a91">tcp_seg_free</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a> *seg)
00678 {
00679   u8_t count = 0;
00680   
00681   <span class="keywordflow">if</span> (seg != <a class="code" href="def_8h.html#a2">NULL</a>) {
00682     <span class="keywordflow">if</span> (seg-&gt;<a class="code" href="structtcp__seg.html#o1">p</a> == <a class="code" href="def_8h.html#a2">NULL</a>) {
00683       <a class="code" href="memp_8c.html#a8">memp_free</a>(MEMP_TCP_SEG, seg);
00684     } <span class="keywordflow">else</span> {
00685       count = <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(seg-&gt;<a class="code" href="structtcp__seg.html#o1">p</a>);
00686 <span class="preprocessor">#if TCP_DEBUG</span>
00687 <span class="preprocessor"></span>      seg-&gt;<a class="code" href="structtcp__seg.html#o1">p</a> = <a class="code" href="def_8h.html#a2">NULL</a>;
00688 <span class="preprocessor">#endif </span><span class="comment">/* TCP_DEBUG */</span>
00689       <a class="code" href="memp_8c.html#a8">memp_free</a>(MEMP_TCP_SEG, seg);
00690     }
00691   }
00692   <span class="keywordflow">return</span> count;
00693 }
00694 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00695 <span class="comment">/*</span>
00696 <span class="comment"> * tcp_setprio():</span>
00697 <span class="comment"> *</span>
00698 <span class="comment"> * Sets the priority of a connection.</span>
00699 <span class="comment"> *</span>
00700 <span class="comment"> */</span>
00701 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00702 <span class="keywordtype">void</span>
00703 <a class="code" href="tcp_8h.html#a81">tcp_setprio</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t prio)
00704 {
00705   pcb-&gt;<a class="code" href="structtcp__pcb.html#o1">prio</a> = prio;
00706 }
00707 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00708 <span class="comment">/*</span>
00709 <span class="comment"> * tcp_seg_copy():</span>
00710 <span class="comment"> *</span>
00711 <span class="comment"> * Returns a copy of the given TCP segment.</span>
00712 <span class="comment"> *</span>
00713 <span class="comment"> */</span> 
00714 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00715 <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *
00716 <a class="code" href="tcp_8h.html#a92">tcp_seg_copy</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a> *seg)
00717 {
00718   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *cseg;
00719 
00720   cseg = <a class="code" href="memp_8c.html#a6">memp_malloc</a>(MEMP_TCP_SEG);
00721   <span class="keywordflow">if</span> (cseg == <a class="code" href="def_8h.html#a2">NULL</a>) {
00722     <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00723   }
00724   memcpy((<span class="keywordtype">char</span> *)cseg, (<span class="keyword">const</span> <span class="keywordtype">char</span> *)seg, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a>)); 
00725   <a class="code" href="pbuf_8c.html#a16">pbuf_ref</a>(cseg-&gt;p);
00726   <span class="keywordflow">return</span> cseg;
00727 }
00728 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00729 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
00730 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="err_8h.html#a13">err_t</a>
00731 tcp_recv_null(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p, <a class="code" href="err_8h.html#a13">err_t</a> err)
00732 {
00733   arg = arg;
00734   <span class="keywordflow">if</span> (p != <a class="code" href="def_8h.html#a2">NULL</a>) {
00735     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00736   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (err == <a class="code" href="err_8h.html#a0">ERR_OK</a>) {
00737     <span class="keywordflow">return</span> <a class="code" href="tcp_8h.html#a79">tcp_close</a>(pcb);
00738   }
00739   <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00740 }
00741 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>
00742 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00743 <span class="keyword">static</span> <span class="keywordtype">void</span>
00744 tcp_kill_prio(u8_t prio)
00745 {
00746   <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, *inactive;
00747   u32_t inactivity;
00748   u8_t mprio;
00749 
00750 
00751   mprio = <a class="code" href="tcp_8h.html#a4">TCP_PRIO_MAX</a>;
00752   
00753   <span class="comment">/* We kill the oldest active connection that has lower priority than</span>
00754 <span class="comment">     prio. */</span>
00755   inactivity = 0;
00756   inactive = <a class="code" href="def_8h.html#a2">NULL</a>;
00757   <span class="keywordflow">for</span>(pcb = <a class="code" href="tcp_8h.html#a50">tcp_active_pcbs</a>; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>) {
00758     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o1">prio</a> &lt;= prio &amp;&amp;
00759        pcb-&gt;<a class="code" href="structtcp__pcb.html#o1">prio</a> &lt;= mprio &amp;&amp;
00760        (u32_t)(<a class="code" href="tcp_8h.html#a48">tcp_ticks</a> - pcb-&gt;<a class="code" href="structtcp__pcb.html#o10">tmr</a>) &gt;= inactivity) {
00761       inactivity = <a class="code" href="tcp_8h.html#a48">tcp_ticks</a> - pcb-&gt;<a class="code" href="structtcp__pcb.html#o10">tmr</a>;
00762       inactive = pcb;
00763       mprio = pcb-&gt;<a class="code" href="structtcp__pcb.html#o1">prio</a>;
00764     }
00765   }
00766   <span class="keywordflow">if</span> (inactive != <a class="code" href="def_8h.html#a2">NULL</a>) {
00767     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_kill_prio: killing oldest PCB 0x%p (%ld)\n"</span>,
00768            (<span class="keywordtype">void</span> *)inactive, inactivity));
00769     <a class="code" href="tcp_8h.html#a78">tcp_abort</a>(inactive);
00770   }      
00771 }
00772 
00773 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00774 <span class="keyword">static</span> <span class="keywordtype">void</span>
00775 tcp_kill_timewait(<span class="keywordtype">void</span>)
00776 {
00777   <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, *inactive;
00778   u32_t inactivity;
00779 
00780   inactivity = 0;
00781   inactive = <a class="code" href="def_8h.html#a2">NULL</a>;
00782   <span class="keywordflow">for</span>(pcb = <a class="code" href="tcp_8h.html#a51">tcp_tw_pcbs</a>; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>) {
00783     <span class="keywordflow">if</span> ((u32_t)(<a class="code" href="tcp_8h.html#a48">tcp_ticks</a> - pcb-&gt;<a class="code" href="structtcp__pcb.html#o10">tmr</a>) &gt;= inactivity) {
00784       inactivity = <a class="code" href="tcp_8h.html#a48">tcp_ticks</a> - pcb-&gt;<a class="code" href="structtcp__pcb.html#o10">tmr</a>;
00785       inactive = pcb;
00786     }
00787   }
00788   <span class="keywordflow">if</span> (inactive != <a class="code" href="def_8h.html#a2">NULL</a>) {
00789     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_kill_timewait: killing oldest TIME-WAIT PCB 0x%p (%ld)\n"</span>,
00790            (<span class="keywordtype">void</span> *)inactive, inactivity));
00791     <a class="code" href="tcp_8h.html#a78">tcp_abort</a>(inactive);
00792   }      
00793 }
00794 
00795 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00796 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00797 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *
00798 <a class="code" href="tcp_8h.html#a67">tcp_alloc</a>(u8_t prio)
00799 {
00800   <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb;
00801   u32_t iss;
00802   
00803   pcb = <a class="code" href="memp_8c.html#a6">memp_malloc</a>(MEMP_TCP_PCB);
00804   <span class="keywordflow">if</span> (pcb == <a class="code" href="def_8h.html#a2">NULL</a>) {
00805     <span class="comment">/* Try killing oldest connection in TIME-WAIT. */</span>
00806     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_alloc: killing off oldest TIME-WAIT connection\n"</span>));
00807     tcp_kill_timewait();
00808     pcb = <a class="code" href="memp_8c.html#a6">memp_malloc</a>(MEMP_TCP_PCB);
00809     <span class="keywordflow">if</span> (pcb == <a class="code" href="def_8h.html#a2">NULL</a>) {
00810       tcp_kill_prio(prio);    
00811       pcb = <a class="code" href="memp_8c.html#a6">memp_malloc</a>(MEMP_TCP_PCB);
00812     }
00813   }
00814   <span class="keywordflow">if</span> (pcb != <a class="code" href="def_8h.html#a2">NULL</a>) {
00815     memset(pcb, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a>));
00816     pcb-&gt;<a class="code" href="structtcp__pcb.html#o1">prio</a> = <a class="code" href="tcp_8h.html#a3">TCP_PRIO_NORMAL</a>;
00817     pcb-&gt;<a class="code" href="structtcp__pcb.html#o33">snd_buf</a> = <a class="code" href="opt_8h.html#a37">TCP_SND_BUF</a>;
00818     pcb-&gt;<a class="code" href="structtcp__pcb.html#o34">snd_queuelen</a> = 0;
00819     pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a> = <a class="code" href="opt_8h.html#a32">TCP_WND</a>;
00820     pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a> = <a class="code" href="opt_8h.html#a36">TCP_MSS</a>;
00821     pcb-&gt;<a class="code" href="structtcp__pcb.html#o20">rto</a> = 3000 / <a class="code" href="tcp_8h.html#a19">TCP_SLOW_INTERVAL</a>;
00822     pcb-&gt;<a class="code" href="structtcp__pcb.html#o18">sa</a> = 0;
00823     pcb-&gt;<a class="code" href="structtcp__pcb.html#o19">sv</a> = 3000 / <a class="code" href="tcp_8h.html#a19">TCP_SLOW_INTERVAL</a>;
00824     pcb-&gt;<a class="code" href="structtcp__pcb.html#o13">rtime</a> = 0;
00825     pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a> = 1;
00826     iss = <a class="code" href="tcp_8h.html#a97">tcp_next_iss</a>();
00827     pcb-&gt;<a class="code" href="structtcp__pcb.html#o30">snd_wl2</a> = iss;
00828     pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a> = iss;
00829     pcb-&gt;<a class="code" href="structtcp__pcb.html#o27">snd_max</a> = iss;
00830     pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a> = iss;
00831     pcb-&gt;<a class="code" href="structtcp__pcb.html#o31">snd_lbb</a> = iss;   
00832     pcb-&gt;<a class="code" href="structtcp__pcb.html#o10">tmr</a> = <a class="code" href="tcp_8h.html#a48">tcp_ticks</a>;
00833 
00834     pcb-&gt;<a class="code" href="structtcp__pcb.html#o11">polltmr</a> = 0;
00835 
00836 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
00837 <span class="preprocessor"></span>    pcb-&gt;recv = tcp_recv_null;
00838 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>  
00839   }
00840   <span class="keywordflow">return</span> pcb;
00841 }
00842 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00843 <span class="comment">/*</span>
00844 <span class="comment"> * tcp_new():</span>
00845 <span class="comment"> *</span>
00846 <span class="comment"> * Creates a new TCP protocol control block but doesn't place it on</span>
00847 <span class="comment"> * any of the TCP PCB lists.</span>
00848 <span class="comment"> *</span>
00849 <span class="comment"> */</span>
00850 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00851 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *
00852 <a class="code" href="tcp_8h.html#a66">tcp_new</a>(<span class="keywordtype">void</span>)
00853 {
00854   <span class="keywordflow">return</span> <a class="code" href="tcp_8h.html#a67">tcp_alloc</a>(TCP_PRIO_NORMAL);
00855 }
00856 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00857 <span class="comment">/*</span>
00858 <span class="comment"> * tcp_arg():</span>
00859 <span class="comment"> *</span>
00860 <span class="comment"> * Used to specify the argument that should be passed callback</span>
00861 <span class="comment"> * functions.</span>
00862 <span class="comment"> *</span>
00863 <span class="comment"> */</span> 
00864 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00865 <span class="keywordtype">void</span>
00866 <a class="code" href="tcp_8h.html#a68">tcp_arg</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keywordtype">void</span> *arg)
00867 {  
00868   pcb-&gt;<a class="code" href="structtcp__pcb.html#o2">callback_arg</a> = arg;
00869 }
00870 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00871 <span class="comment">/*</span>
00872 <span class="comment"> * tcp_recv():</span>
00873 <span class="comment"> *</span>
00874 <span class="comment"> * Used to specify the function that should be called when a TCP</span>
00875 <span class="comment"> * connection receives data.</span>
00876 <span class="comment"> *</span>
00877 <span class="comment"> */</span> 
00878 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00879 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
00880 <span class="preprocessor"></span><span class="keywordtype">void</span>
00881 <a class="code" href="tcp_8h.html#a70">tcp_recv</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
00882    <a class="code" href="err_8h.html#a13">err_t</a> (* recv)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *tpcb, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p, <a class="code" href="err_8h.html#a13">err_t</a> err))
00883 {
00884   pcb-&gt;recv = recv;
00885 }
00886 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>
00887 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00888 <span class="comment">/*</span>
00889 <span class="comment"> * tcp_sent():</span>
00890 <span class="comment"> *</span>
00891 <span class="comment"> * Used to specify the function that should be called when TCP data</span>
00892 <span class="comment"> * has been successfully delivered to the remote host.</span>
00893 <span class="comment"> *</span>
00894 <span class="comment"> */</span> 
00895 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00896 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
00897 <span class="preprocessor"></span><span class="keywordtype">void</span>
00898 <a class="code" href="tcp_8h.html#a71">tcp_sent</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
00899    <a class="code" href="err_8h.html#a13">err_t</a> (* sent)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *tpcb, u16_t len))
00900 {
00901   pcb-&gt;sent = sent;
00902 }
00903 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>
00904 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00905 <span class="comment">/*</span>
00906 <span class="comment"> * tcp_err():</span>
00907 <span class="comment"> *</span>
00908 <span class="comment"> * Used to specify the function that should be called when a fatal error</span>
00909 <span class="comment"> * has occured on the connection.</span>
00910 <span class="comment"> *</span>
00911 <span class="comment"> */</span> 
00912 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00913 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
00914 <span class="preprocessor"></span><span class="keywordtype">void</span>
00915 <a class="code" href="tcp_8h.html#a73">tcp_err</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
00916    <span class="keywordtype">void</span> (* errf)(<span class="keywordtype">void</span> *arg, <a class="code" href="err_8h.html#a13">err_t</a> err))
00917 {
00918   pcb-&gt;errf = errf;
00919 }
00920 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>
00921 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00922 <span class="comment">/*</span>
00923 <span class="comment"> * tcp_poll():</span>
00924 <span class="comment"> *</span>
00925 <span class="comment"> * Used to specify the function that should be called periodically</span>
00926 <span class="comment"> * from TCP. The interval is specified in terms of the TCP coarse</span>
00927 <span class="comment"> * timer interval, which is called twice a second.</span>
00928 <span class="comment"> *</span>
00929 <span class="comment"> */</span> 
00930 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00931 <span class="keywordtype">void</span>
00932 <a class="code" href="tcp_8h.html#a72">tcp_poll</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
00933    <a class="code" href="err_8h.html#a13">err_t</a> (* poll)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *tpcb), u8_t interval)
00934 {
00935 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
00936 <span class="preprocessor"></span>  pcb-&gt;poll = poll;
00937 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>  
00938   pcb-&gt;<a class="code" href="structtcp__pcb.html#o12">pollinterval</a> = interval;
00939 }
00940 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00941 <span class="comment">/*</span>
00942 <span class="comment"> * tcp_accept():</span>
00943 <span class="comment"> *</span>
00944 <span class="comment"> * Used for specifying the function that should be called when a</span>
00945 <span class="comment"> * LISTENing connection has been connected to another host.</span>
00946 <span class="comment"> *</span>
00947 <span class="comment"> */</span> 
00948 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00949 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
00950 <span class="preprocessor"></span><span class="keywordtype">void</span>
00951 <a class="code" href="tcp_8h.html#a69">tcp_accept</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
00952      <a class="code" href="err_8h.html#a13">err_t</a> (* accept)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *newpcb, <a class="code" href="err_8h.html#a13">err_t</a> err))
00953 {
00954   ((<span class="keyword">struct </span><a class="code" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *)pcb)-&gt;accept = accept;
00955 }
00956 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>
00957 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00958 <span class="comment">/*</span>
00959 <span class="comment"> * tcp_pcb_purge():</span>
00960 <span class="comment"> *</span>
00961 <span class="comment"> * Purges a TCP PCB. Removes any buffered data and frees the buffer memory.</span>
00962 <span class="comment"> *</span>
00963 <span class="comment"> */</span>
00964 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00965 <span class="keywordtype">void</span>
00966 <a class="code" href="tcp_8h.html#a88">tcp_pcb_purge</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
00967 {
00968   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> != <a class="code" href="fsm_8h.html#a10">CLOSED</a> &amp;&amp;
00969      pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> != <a class="code" href="tcp_8h.html#a99a63">TIME_WAIT</a> &amp;&amp;
00970      pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> != <a class="code" href="tcp_8h.html#a99a54">LISTEN</a>) {
00971 
00972     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_pcb_purge\n"</span>));
00973     
00974 <span class="preprocessor">#if TCP_DEBUG</span>
00975 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a> != <a class="code" href="def_8h.html#a2">NULL</a>) {    
00976       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_pcb_purge: not all data sent\n"</span>));
00977     }
00978     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> != <a class="code" href="def_8h.html#a2">NULL</a>) {    
00979       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_pcb_purge: data left on -&gt;unacked\n"</span>));
00980     }
00981 <span class="preprocessor">#if TCP_QUEUE_OOSEQ </span><span class="comment">/* LW */</span>
00982     <span class="keywordflow">if</span> (pcb-&gt;ooseq != <a class="code" href="def_8h.html#a2">NULL</a>) {    
00983       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_pcb_purge: data left on -&gt;ooseq\n"</span>));
00984     }
00985 <span class="preprocessor">#endif</span>
00986 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* TCP_DEBUG */</span>
00987     <a class="code" href="tcp_8h.html#a90">tcp_segs_free</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a>);
00988 <span class="preprocessor">#if TCP_QUEUE_OOSEQ</span>
00989 <span class="preprocessor"></span>    <a class="code" href="tcp_8h.html#a90">tcp_segs_free</a>(pcb-&gt;ooseq);
00990 <span class="preprocessor">#endif </span><span class="comment">/* TCP_QUEUE_OOSEQ */</span>
00991     <a class="code" href="tcp_8h.html#a90">tcp_segs_free</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>);
00992     pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a> =
00993 <span class="preprocessor">#if TCP_QUEUE_OOSEQ</span>
00994 <span class="preprocessor"></span>      pcb-&gt;ooseq =
00995 <span class="preprocessor">#endif </span><span class="comment">/* TCP_QUEUE_OOSEQ */</span>
00996       <a class="code" href="def_8h.html#a2">NULL</a>;
00997   }
00998 }
00999 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
01000 <span class="comment">/*</span>
01001 <span class="comment"> * tcp_pcb_remove():</span>
01002 <span class="comment"> *</span>
01003 <span class="comment"> * Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.</span>
01004 <span class="comment"> *</span>
01005 <span class="comment"> */</span>
01006 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
01007 <span class="keywordtype">void</span>
01008 <a class="code" href="tcp_8h.html#a89">tcp_pcb_remove</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> **pcblist, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
01009 {
01010   <a class="code" href="tcp_8h.html#a45">TCP_RMV</a>(pcblist, pcb);
01011 
01012   <a class="code" href="tcp_8h.html#a88">tcp_pcb_purge</a>(pcb);
01013   
01014   <span class="comment">/* if there is an outstanding delayed ACKs, send it */</span>
01015   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> != <a class="code" href="tcp_8h.html#a99a63">TIME_WAIT</a> &amp;&amp;
01016      pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> != <a class="code" href="tcp_8h.html#a99a54">LISTEN</a> &amp;&amp;
01017      pcb-&gt;<a class="code" href="structtcp__pcb.html#o15">flags</a> &amp; <a class="code" href="tcp_8h.html#a29">TF_ACK_DELAY</a>) {
01018     pcb-&gt;<a class="code" href="structtcp__pcb.html#o15">flags</a> |= <a class="code" href="tcp_8h.html#a30">TF_ACK_NOW</a>;
01019     <a class="code" href="tcp_8h.html#a85">tcp_output</a>(pcb);
01020   }  
01021   pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> = <a class="code" href="fsm_8h.html#a10">CLOSED</a>;
01022 
01023   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_pcb_remove: tcp_pcbs_sane()"</span>, <a class="code" href="tcp_8h.html#a43">tcp_pcbs_sane</a>());
01024 }
01025 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
01026 <span class="comment">/*</span>
01027 <span class="comment"> * tcp_next_iss():</span>
01028 <span class="comment"> *</span>
01029 <span class="comment"> * Calculates a new initial sequence number for new connections.</span>
01030 <span class="comment"> *</span>
01031 <span class="comment"> */</span>
01032 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
01033 u32_t
01034 <a class="code" href="tcp_8h.html#a97">tcp_next_iss</a>(<span class="keywordtype">void</span>)
01035 {
01036   <span class="keyword">static</span> u32_t iss = 6510;
01037   
01038   iss += <a class="code" href="tcp_8h.html#a48">tcp_ticks</a>;       <span class="comment">/* XXX */</span>
01039   <span class="keywordflow">return</span> iss;
01040 }
01041 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
01042 <span class="preprocessor">#if TCP_DEBUG || TCP_INPUT_DEBUG || TCP_OUTPUT_DEBUG</span>
01043 <span class="preprocessor"></span><span class="keywordtype">void</span>
01044 tcp_debug_print(<span class="keyword">struct</span> <a class="code" href="structtcp__hdr.html">tcp_hdr</a> *<a class="code" href="structtcphdr.html">tcphdr</a>)
01045 {
01046   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"TCP header:\n"</span>));
01047   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"+-------------------------------+\n"</span>));
01048   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"|      %04x     |      %04x     | (src port, dest port)\n"</span>,
01049          tcphdr-&gt;src, tcphdr-&gt;dest));
01050   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"+-------------------------------+\n"</span>));
01051   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"|            %08lu           | (seq no)\n"</span>,
01052           tcphdr-&gt;seqno));
01053   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"+-------------------------------+\n"</span>));
01054   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"|            %08lu           | (ack no)\n"</span>,
01055          tcphdr-&gt;ackno));
01056   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"+-------------------------------+\n"</span>));
01057   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"| %2u |    |%u%u%u%u%u|    %5u      | (offset, flags ("</span>,
01058        <a class="code" href="tcp_8h.html#a24">TCPH_OFFSET</a>(tcphdr),
01059          <a class="code" href="tcp_8h.html#a25">TCPH_FLAGS</a>(tcphdr) &gt;&gt; 4 &amp; 1,
01060          <a class="code" href="tcp_8h.html#a25">TCPH_FLAGS</a>(tcphdr) &gt;&gt; 4 &amp; 1,
01061          <a class="code" href="tcp_8h.html#a25">TCPH_FLAGS</a>(tcphdr) &gt;&gt; 3 &amp; 1,
01062          <a class="code" href="tcp_8h.html#a25">TCPH_FLAGS</a>(tcphdr) &gt;&gt; 2 &amp; 1,
01063          <a class="code" href="tcp_8h.html#a25">TCPH_FLAGS</a>(tcphdr) &gt;&gt; 1 &amp; 1,
01064          <a class="code" href="tcp_8h.html#a25">TCPH_FLAGS</a>(tcphdr) &amp; 1,
01065          tcphdr-&gt;wnd));
01066   tcp_debug_print_flags(<a class="code" href="tcp_8h.html#a25">TCPH_FLAGS</a>(tcphdr));
01067   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"), win)\n"</span>));
01068   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"+-------------------------------+\n"</span>));
01069   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"|    0x%04x     |     %5u     | (chksum, urgp)\n"</span>,
01070          <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(tcphdr-&gt;chksum), <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(tcphdr-&gt;urgp)));
01071   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"+-------------------------------+\n"</span>));
01072 }
01073 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
01074 <span class="keywordtype">void</span>
01075 tcp_debug_print_state(<span class="keyword">enum</span> tcp_state s)
01076 {
01077   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"State: "</span>));
01078   <span class="keywordflow">switch</span> (s) {
01079   <span class="keywordflow">case</span> <a class="code" href="fsm_8h.html#a10">CLOSED</a>:
01080     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"CLOSED\n"</span>));
01081     <span class="keywordflow">break</span>;
01082  <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a54">LISTEN</a>:
01083    <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"LISTEN\n"</span>));
01084    <span class="keywordflow">break</span>;
01085   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a55">SYN_SENT</a>:
01086     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"SYN_SENT\n"</span>));
01087     <span class="keywordflow">break</span>;
01088   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a56">SYN_RCVD</a>:
01089     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"SYN_RCVD\n"</span>));
01090     <span class="keywordflow">break</span>;
01091   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a57">ESTABLISHED</a>:
01092     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"ESTABLISHED\n"</span>));
01093     <span class="keywordflow">break</span>;
01094   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a58">FIN_WAIT_1</a>:
01095     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"FIN_WAIT_1\n"</span>));
01096     <span class="keywordflow">break</span>;
01097   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a59">FIN_WAIT_2</a>:
01098     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"FIN_WAIT_2\n"</span>));
01099     <span class="keywordflow">break</span>;
01100   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a60">CLOSE_WAIT</a>:
01101     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"CLOSE_WAIT\n"</span>));
01102     <span class="keywordflow">break</span>;
01103   <span class="keywordflow">case</span> <a class="code" href="fsm_8h.html#a12">CLOSING</a>:
01104     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"CLOSING\n"</span>));
01105     <span class="keywordflow">break</span>;
01106   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a62">LAST_ACK</a>:
01107     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"LAST_ACK\n"</span>));
01108     <span class="keywordflow">break</span>;
01109   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a63">TIME_WAIT</a>:
01110     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"TIME_WAIT\n"</span>));
01111    <span class="keywordflow">break</span>;
01112   }
01113 }
01114 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
01115 <span class="keywordtype">void</span>
01116 tcp_debug_print_flags(u8_t flags)
01117 {
01118   <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a9">TCP_FIN</a>) {
01119     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"FIN "</span>));
01120   }
01121   <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a10">TCP_SYN</a>) {
01122     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"SYN "</span>));
01123   }
01124   <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a11">TCP_RST</a>) {
01125     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"RST "</span>));
01126   }
01127   <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a12">TCP_PSH</a>) {
01128     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"PSH "</span>));
01129   }
01130   <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a13">TCP_ACK</a>) {
01131     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"ACK "</span>));
01132   }
01133   <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a14">TCP_URG</a>) {
01134     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"URG "</span>));
01135   }
01136 }
01137 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
01138 <span class="keywordtype">void</span>
01139 tcp_debug_print_pcbs(<span class="keywordtype">void</span>)
01140 {
01141   <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb;
01142   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"Active PCB states:\n"</span>));
01143   <span class="keywordflow">for</span>(pcb = <a class="code" href="tcp_8h.html#a50">tcp_active_pcbs</a>; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>) {
01144     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"Local port %u, foreign port %u snd_nxt %lu rcv_nxt %lu "</span>,
01145                        pcb-&gt;<a class="code" href="structtcp__pcb.html#o4">local_port</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o7">remote_port</a>,
01146                        pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>));
01147     tcp_debug_print_state(pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a>);
01148   }    
01149   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"Listen PCB states:\n"</span>));
01150   <span class="keywordflow">for</span>(pcb = (<span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *)<a class="code" href="tcp_8h.html#a49">tcp_listen_pcbs</a>; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>) {
01151     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"Local port %u, foreign port %u snd_nxt %lu rcv_nxt %lu "</span>,
01152                        pcb-&gt;<a class="code" href="structtcp__pcb.html#o4">local_port</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o7">remote_port</a>,
01153                        pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>));
01154     tcp_debug_print_state(pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a>);
01155   }    
01156   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"TIME-WAIT PCB states:\n"</span>));
01157   <span class="keywordflow">for</span>(pcb = <a class="code" href="tcp_8h.html#a51">tcp_tw_pcbs</a>; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>) {
01158     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"Local port %u, foreign port %u snd_nxt %lu rcv_nxt %lu "</span>,
01159                        pcb-&gt;<a class="code" href="structtcp__pcb.html#o4">local_port</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o7">remote_port</a>,
01160                        pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>));
01161     tcp_debug_print_state(pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a>);
01162   }    
01163 }
01164 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
01165 <span class="keywordtype">int</span>
01166 <a class="code" href="tcp_8h.html#a43">tcp_pcbs_sane</a>(<span class="keywordtype">void</span>)
01167 {
01168   <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb;
01169   <span class="keywordflow">for</span>(pcb = <a class="code" href="tcp_8h.html#a50">tcp_active_pcbs</a>; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>) {
01170     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_pcbs_sane: active pcb-&gt;state != CLOSED"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> != CLOSED);
01171     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_pcbs_sane: active pcb-&gt;state != LISTEN"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> != LISTEN);
01172     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_pcbs_sane: active pcb-&gt;state != TIME-WAIT"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> != TIME_WAIT);
01173   }
01174   <span class="keywordflow">for</span>(pcb = <a class="code" href="tcp_8h.html#a51">tcp_tw_pcbs</a>; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>) {
01175     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_pcbs_sane: tw pcb-&gt;state == TIME-WAIT"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> == TIME_WAIT);
01176   }
01177   <span class="keywordflow">return</span> 1;
01178 }
01179 <span class="preprocessor">#endif </span><span class="comment">/* TCP_DEBUG */</span>
01180 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_TCP */</span>
01181 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
01182 
01183 
01184 
01185 
01186 
01187 
01188 
01189 
01190 
</pre></div>	</td>
  </tr>
</table>
<hr>
<div align="center">Copyright (c) 2001-2003 Swedish Institute of Computer Science</div>
</html>
