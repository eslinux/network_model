
<html>
<head>
<title>lwIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="doxygen.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<table width="98%" border="0" align="center">
  <tr>
    <td>
      <h2>lwIP code documentation</h2>
<hr>

<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>sockets.c</h1><a href="sockets_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2001-2003 Swedish Institute of Computer Science.</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without modification,</span>
00006 <span class="comment"> * are permitted provided that the following conditions are met:</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span>
00009 <span class="comment"> *    this list of conditions and the following disclaimer.</span>
00010 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
00011 <span class="comment"> *    this list of conditions and the following disclaimer in the documentation</span>
00012 <span class="comment"> *    and/or other materials provided with the distribution.</span>
00013 <span class="comment"> * 3. The name of the author may not be used to endorse or promote products</span>
00014 <span class="comment"> *    derived from this software without specific prior written permission.</span>
00015 <span class="comment"> *</span>
00016 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED</span>
00017 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
00018 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT</span>
00019 <span class="comment"> * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
00020 <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT</span>
00021 <span class="comment"> * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
00022 <span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
00023 <span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
00024 <span class="comment"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY</span>
00025 <span class="comment"> * OF SUCH DAMAGE.</span>
00026 <span class="comment"> *</span>
00027 <span class="comment"> * This file is part of the lwIP TCP/IP stack.</span>
00028 <span class="comment"> *</span>
00029 <span class="comment"> * Author: Adam Dunkels &lt;adam@sics.se&gt;</span>
00030 <span class="comment"> *</span>
00031 <span class="comment"> * Improved by Marc Boucher &lt;marc@mbsi.ca&gt; and David Haas &lt;dhaas@alum.rpi.edu&gt;</span>
00032 <span class="comment"> *</span>
00033 <span class="comment"> */</span>
00034 
00035 <span class="preprocessor">#include "<a class="code" href="opt_8h.html">lwip/opt.h</a>"</span>
00036 <span class="preprocessor">#include "<a class="code" href="api_8h.html">lwip/api.h</a>"</span>
00037 <span class="preprocessor">#include "<a class="code" href="arch_8h.html">lwip/arch.h</a>"</span>
00038 <span class="preprocessor">#include "<a class="code" href="sys_8h.html">lwip/sys.h</a>"</span>
00039 
00040 <span class="preprocessor">#include "<a class="code" href="sockets_8h.html">lwip/sockets.h</a>"</span>
00041 
<a name="l00042"></a><a class="code" href="sockets_8c.html#a0">00042</a> <span class="preprocessor">#define NUM_SOCKETS MEMP_NUM_NETCONN</span>
00043 <span class="preprocessor"></span>
<a name="l00044"></a><a class="code" href="structlwip__socket.html">00044</a> <span class="keyword">struct </span><a class="code" href="structlwip__socket.html">lwip_socket</a> {
<a name="l00045"></a><a class="code" href="structlwip__socket.html#o0">00045</a>   <span class="keyword">struct </span><a class="code" href="structnetconn.html">netconn</a> *<a class="code" href="structlwip__socket.html#o0">conn</a>;
<a name="l00046"></a><a class="code" href="structlwip__socket.html#o1">00046</a>   <span class="keyword">struct </span><a class="code" href="structnetbuf.html">netbuf</a> *<a class="code" href="structlwip__socket.html#o1">lastdata</a>;
<a name="l00047"></a><a class="code" href="structlwip__socket.html#o2">00047</a>   u16_t <a class="code" href="structlwip__socket.html#o2">lastoffset</a>;
<a name="l00048"></a><a class="code" href="structlwip__socket.html#o3">00048</a>   u16_t <a class="code" href="structlwip__socket.html#o3">rcvevent</a>;
<a name="l00049"></a><a class="code" href="structlwip__socket.html#o4">00049</a>   u16_t <a class="code" href="structlwip__socket.html#o4">sendevent</a>;
<a name="l00050"></a><a class="code" href="structlwip__socket.html#o5">00050</a>   u16_t  <a class="code" href="structlwip__socket.html#o5">flags</a>;
<a name="l00051"></a><a class="code" href="structlwip__socket.html#o6">00051</a>   <span class="keywordtype">int</span> <a class="code" href="structlwip__socket.html#o6">err</a>;
00052 };
00053 
<a name="l00054"></a><a class="code" href="structlwip__select__cb.html">00054</a> <span class="keyword">struct </span><a class="code" href="structlwip__select__cb.html">lwip_select_cb</a>
00055 {
<a name="l00056"></a><a class="code" href="structlwip__select__cb.html#o0">00056</a>     <span class="keyword">struct </span><a class="code" href="structlwip__select__cb.html">lwip_select_cb</a> *<a class="code" href="structlwip__select__cb.html#o0">next</a>;
<a name="l00057"></a><a class="code" href="structlwip__select__cb.html#o1">00057</a>     <a class="code" href="structfd__set.html">fd_set</a> *<a class="code" href="structlwip__select__cb.html#o1">readset</a>;
<a name="l00058"></a><a class="code" href="structlwip__select__cb.html#o2">00058</a>     <a class="code" href="structfd__set.html">fd_set</a> *<a class="code" href="structlwip__select__cb.html#o2">writeset</a>;
<a name="l00059"></a><a class="code" href="structlwip__select__cb.html#o3">00059</a>     <a class="code" href="structfd__set.html">fd_set</a> *<a class="code" href="structlwip__select__cb.html#o3">exceptset</a>;
<a name="l00060"></a><a class="code" href="structlwip__select__cb.html#o4">00060</a>     <span class="keywordtype">int</span> <a class="code" href="structlwip__select__cb.html#o4">sem_signalled</a>;
<a name="l00061"></a><a class="code" href="structlwip__select__cb.html#o5">00061</a>     sys_sem_t <a class="code" href="structlwip__select__cb.html#o5">sem</a>;
00062 };
00063 
<a name="l00064"></a><a class="code" href="sockets_8c.html#a4">00064</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlwip__socket.html">lwip_socket</a> <a class="code" href="sockets_8c.html#a4">sockets</a>[<a class="code" href="sockets_8c.html#a0">NUM_SOCKETS</a>];
<a name="l00065"></a><a class="code" href="sockets_8c.html#a5">00065</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlwip__select__cb.html">lwip_select_cb</a> *<a class="code" href="sockets_8c.html#a5">select_cb_list</a> = 0;
00066 
<a name="l00067"></a><a class="code" href="sockets_8c.html#a6">00067</a> <span class="keyword">static</span> sys_sem_t <a class="code" href="sockets_8c.html#a6">socksem</a> = 0;
<a name="l00068"></a><a class="code" href="sockets_8c.html#a7">00068</a> <span class="keyword">static</span> sys_sem_t <a class="code" href="sockets_8c.html#a7">selectsem</a> = 0;
00069 
00070 <span class="keyword">static</span> <span class="keywordtype">void</span>
00071 <a class="code" href="sockets_8c.html#a9">event_callback</a>(<span class="keyword">struct</span> <a class="code" href="structnetconn.html">netconn</a> *conn, <span class="keyword">enum</span> netconn_evt evt, u16_t len);
00072 
<a name="l00073"></a><a class="code" href="sockets_8c.html#a8">00073</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="sockets_8c.html#a8">err_to_errno_table</a>[11] = {
00074     0,      <span class="comment">/* ERR_OK    0      No error, everything OK. */</span>
00075     ENOMEM,    <span class="comment">/* ERR_MEM  -1      Out of memory error.     */</span>
00076     ENOBUFS,    <span class="comment">/* ERR_BUF  -2      Buffer error.            */</span>
00077     ECONNABORTED,  <span class="comment">/* ERR_ABRT -3      Connection aborted.      */</span>
00078     ECONNRESET,    <span class="comment">/* ERR_RST  -4      Connection reset.        */</span>
00079     ESHUTDOWN,    <span class="comment">/* ERR_CLSD -5      Connection closed.       */</span>
00080     ENOTCONN,    <span class="comment">/* ERR_CONN -6      Not connected.           */</span>
00081     EINVAL,    <span class="comment">/* ERR_VAL  -7      Illegal value.           */</span>
00082     EIO,    <span class="comment">/* ERR_ARG  -8      Illegal argument.        */</span>
00083     EHOSTUNREACH,  <span class="comment">/* ERR_RTE  -9      Routing problem.         */</span>
00084     EADDRINUSE    <span class="comment">/* ERR_USE  -10     Address in use.          */</span>
00085 };
00086 
<a name="l00087"></a><a class="code" href="sockets_8c.html#a1">00087</a> <span class="preprocessor">#define err_to_errno(err) \</span>
00088 <span class="preprocessor">  ((err) &lt; (sizeof(err_to_errno_table)/sizeof(int))) ? \</span>
00089 <span class="preprocessor">    err_to_errno_table[-(err)] : EIO</span>
00090 <span class="preprocessor"></span>
00091 <span class="preprocessor">#ifdef ERRNO</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#define set_errno(err) errno = (err)</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00094"></a><a class="code" href="sockets_8c.html#a2">00094</a> <span class="preprocessor"></span><span class="preprocessor">#define set_errno(err)</span>
00095 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00096 <span class="preprocessor"></span>
<a name="l00097"></a><a class="code" href="sockets_8c.html#a3">00097</a> <span class="preprocessor">#define sock_set_errno(sk, e) do { \</span>
00098 <span class="preprocessor">      sk-&gt;err = (e); \</span>
00099 <span class="preprocessor">      set_errno(sk-&gt;err); \</span>
00100 <span class="preprocessor">} while (0)</span>
00101 <span class="preprocessor"></span>
00102 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00103 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlwip__socket.html">lwip_socket</a> *
<a name="l00104"></a><a class="code" href="sockets_8c.html#a10">00104</a> <a class="code" href="sockets_8c.html#a10">get_socket</a>(<span class="keywordtype">int</span> s)
00105 {
00106   <span class="keyword">struct </span><a class="code" href="structlwip__socket.html">lwip_socket</a> *sock;
00107 
00108   <span class="keywordflow">if</span> ((s &lt; 0) || (s &gt; <a class="code" href="sockets_8c.html#a0">NUM_SOCKETS</a>)) {
00109     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"get_socket(%d): invalid\n"</span>, s));
00110     <a class="code" href="sockets_8c.html#a2">set_errno</a>(EBADF);
00111     <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00112   }
00113 
00114   sock = &amp;<a class="code" href="sockets_8c.html#a4">sockets</a>[s];
00115 
00116   <span class="keywordflow">if</span> (!sock-&gt;conn) {
00117     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"get_socket(%d): not active\n"</span>, s));
00118     <a class="code" href="sockets_8c.html#a2">set_errno</a>(EBADF);
00119     <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00120   }
00121 
00122   <span class="keywordflow">return</span> sock;
00123 }
00124 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00125 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00126"></a><a class="code" href="sockets_8c.html#a11">00126</a> <a class="code" href="sockets_8c.html#a11">alloc_socket</a>(<span class="keyword">struct</span> <a class="code" href="structnetconn.html">netconn</a> *newconn)
00127 {
00128   <span class="keywordtype">int</span> i;
00129 
00130   <span class="keywordflow">if</span> (!<a class="code" href="sockets_8c.html#a6">socksem</a>)
00131       <a class="code" href="sockets_8c.html#a6">socksem</a> = <a class="code" href="sys_8h.html#a9">sys_sem_new</a>(1);
00132 
00133   <span class="comment">/* Protect socket array */</span>
00134   <a class="code" href="sys_8c.html#a1">sys_sem_wait</a>(<a class="code" href="sockets_8c.html#a6">socksem</a>);
00135 
00136   <span class="comment">/* allocate a new socket identifier */</span>
00137   <span class="keywordflow">for</span>(i = 0; i &lt; <a class="code" href="sockets_8c.html#a0">NUM_SOCKETS</a>; ++i) {
00138     <span class="keywordflow">if</span> (!<a class="code" href="sockets_8c.html#a4">sockets</a>[i].<a class="code" href="structlwip__socket.html#o0">conn</a>) {
00139       <a class="code" href="sockets_8c.html#a4">sockets</a>[i].<a class="code" href="structlwip__socket.html#o0">conn</a> = newconn;
00140       <a class="code" href="sockets_8c.html#a4">sockets</a>[i].<a class="code" href="structlwip__socket.html#o1">lastdata</a> = <a class="code" href="def_8h.html#a2">NULL</a>;
00141       <a class="code" href="sockets_8c.html#a4">sockets</a>[i].<a class="code" href="structlwip__socket.html#o2">lastoffset</a> = 0;
00142       <a class="code" href="sockets_8c.html#a4">sockets</a>[i].<a class="code" href="structlwip__socket.html#o3">rcvevent</a> = 0;
00143       <a class="code" href="sockets_8c.html#a4">sockets</a>[i].<a class="code" href="structlwip__socket.html#o4">sendevent</a> = 1; <span class="comment">/* TCP send buf is empty */</span>
00144       <a class="code" href="sockets_8c.html#a4">sockets</a>[i].<a class="code" href="structlwip__socket.html#o5">flags</a> = 0;
00145       <a class="code" href="sockets_8c.html#a4">sockets</a>[i].<a class="code" href="structlwip__socket.html#o6">err</a> = 0;
00146       <a class="code" href="sys_8h.html#a10">sys_sem_signal</a>(<a class="code" href="sockets_8c.html#a6">socksem</a>);
00147       <span class="keywordflow">return</span> i;
00148     }
00149   }
00150   <a class="code" href="sys_8h.html#a10">sys_sem_signal</a>(<a class="code" href="sockets_8c.html#a6">socksem</a>);
00151   <span class="keywordflow">return</span> -1;
00152 }
00153 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00154 <span class="keywordtype">int</span>
<a name="l00155"></a><a class="code" href="sockets_8c.html#a12">00155</a> <a class="code" href="sockets_8c.html#a12">lwip_accept</a>(<span class="keywordtype">int</span> s, <span class="keyword">struct</span> <a class="code" href="structsockaddr.html">sockaddr</a> *addr, socklen_t *addrlen)
00156 {
00157   <span class="keyword">struct </span><a class="code" href="structlwip__socket.html">lwip_socket</a> *sock;
00158   <span class="keyword">struct </span><a class="code" href="structnetconn.html">netconn</a> *newconn;
00159   <span class="keyword">struct </span><a class="code" href="structip__addr.html">ip_addr</a> naddr;
00160   u16_t port;
00161   <span class="keywordtype">int</span> newsock;
00162   <span class="keyword">struct </span><a class="code" href="structsockaddr__in.html">sockaddr_in</a> sin;
00163 
00164   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_accept(%d)...\n"</span>, s));
00165   sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(s);
00166   <span class="keywordflow">if</span> (!sock) {
00167     <span class="keywordflow">return</span> -1;
00168   }
00169 
00170   newconn = <a class="code" href="api__lib_8c.html#a24">netconn_accept</a>(sock-&gt;conn);
00171 
00172   <span class="comment">/* get the IP address and port of the remote host */</span>
00173   <a class="code" href="api__lib_8c.html#a18">netconn_peer</a>(newconn, &amp;naddr, &amp;port);
00174 
00175   memset(&amp;sin, 0, <span class="keyword">sizeof</span>(sin));
00176   sin.<a class="code" href="structsockaddr__in.html#o0">sin_len</a> = <span class="keyword">sizeof</span>(sin);
00177   sin.<a class="code" href="structsockaddr__in.html#o1">sin_family</a> = <a class="code" href="sockets_8h.html#a24">AF_INET</a>;
00178   sin.<a class="code" href="structsockaddr__in.html#o2">sin_port</a> = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(port);
00179   sin.<a class="code" href="structsockaddr__in.html#o3">sin_addr</a>.<a class="code" href="structin__addr.html#o0">s_addr</a> = naddr.<a class="code" href="structip__addr.html#o0">addr</a>;
00180 
00181   <span class="keywordflow">if</span> (*addrlen &gt; <span class="keyword">sizeof</span>(sin))
00182       *addrlen = <span class="keyword">sizeof</span>(sin);
00183 
00184   memcpy(addr, &amp;sin, *addrlen);
00185 
00186   newsock = <a class="code" href="sockets_8c.html#a11">alloc_socket</a>(newconn);
00187   <span class="keywordflow">if</span> (newsock == -1) {
00188     <a class="code" href="api__lib_8c.html#a16">netconn_delete</a>(newconn);
00189   <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, ENOBUFS);
00190   <span class="keywordflow">return</span> -1;
00191   }
00192   newconn-&gt;callback = <a class="code" href="sockets_8c.html#a9">event_callback</a>;
00193   sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(newsock);
00194 
00195   <a class="code" href="sys_8c.html#a1">sys_sem_wait</a>(<a class="code" href="sockets_8c.html#a6">socksem</a>);
00196   sock-&gt;rcvevent += -1 - newconn-&gt;socket;
00197   newconn-&gt;socket = newsock;
00198   <a class="code" href="sys_8h.html#a10">sys_sem_signal</a>(<a class="code" href="sockets_8c.html#a6">socksem</a>);
00199 
00200 <span class="preprocessor">#if SOCKETS_DEBUG</span>
00201 <span class="preprocessor"></span>  <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_accept(%d) returning new sock=%d addr="</span>, s, newsock));
00202   <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a33">ip_addr_debug_print</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, &amp;naddr);
00203   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">" port=%u\n"</span>, port));
00204 <span class="preprocessor">#endif</span>
00205 <span class="preprocessor"></span>
00206   <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, 0);
00207   <span class="keywordflow">return</span> newsock;
00208 }
00209 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00210 <span class="keywordtype">int</span>
<a name="l00211"></a><a class="code" href="sockets_8c.html#a13">00211</a> <a class="code" href="sockets_8c.html#a13">lwip_bind</a>(<span class="keywordtype">int</span> s, <span class="keyword">struct</span> <a class="code" href="structsockaddr.html">sockaddr</a> *name, socklen_t namelen)
00212 {
00213   <span class="keyword">struct </span><a class="code" href="structlwip__socket.html">lwip_socket</a> *sock;
00214   <span class="keyword">struct </span><a class="code" href="structip__addr.html">ip_addr</a> local_addr;
00215   u16_t local_port;
00216   <a class="code" href="err_8h.html#a13">err_t</a> err;
00217 
00218   sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(s);
00219   <span class="keywordflow">if</span> (!sock) {
00220     <span class="keywordflow">return</span> -1;
00221   }
00222 
00223   local_addr.<a class="code" href="structip__addr.html#o0">addr</a> = ((<span class="keyword">struct </span><a class="code" href="structsockaddr__in.html">sockaddr_in</a> *)name)-&gt;sin_addr.s_addr;
00224   local_port = ((<span class="keyword">struct </span><a class="code" href="structsockaddr__in.html">sockaddr_in</a> *)name)-&gt;sin_port;
00225 
00226 <span class="preprocessor">#if SOCKETS_DEBUG</span>
00227 <span class="preprocessor"></span>  <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_bind(%d, addr="</span>, s));
00228   <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a33">ip_addr_debug_print</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, &amp;local_addr);
00229   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">" port=%u)\n"</span>, <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(local_port)));
00230 <span class="preprocessor">#endif</span>
00231 <span class="preprocessor"></span>
00232   err = <a class="code" href="api__lib_8c.html#a20">netconn_bind</a>(sock-&gt;conn, &amp;local_addr, <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(local_port));
00233 
00234   <span class="keywordflow">if</span> (err != <a class="code" href="err_8h.html#a0">ERR_OK</a>) {
00235     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_bind(%d) failed, err=%d\n"</span>, s, err));
00236     <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, <a class="code" href="sockets_8c.html#a1">err_to_errno</a>(err));
00237     <span class="keywordflow">return</span> -1;
00238   }
00239 
00240   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_bind(%d) succeeded\n"</span>, s));
00241   <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, 0);
00242   <span class="keywordflow">return</span> 0;
00243 }
00244 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00245 <span class="keywordtype">int</span>
<a name="l00246"></a><a class="code" href="sockets_8c.html#a14">00246</a> <a class="code" href="sockets_8c.html#a14">lwip_close</a>(<span class="keywordtype">int</span> s)
00247 {
00248   <span class="keyword">struct </span><a class="code" href="structlwip__socket.html">lwip_socket</a> *sock;
00249 
00250   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_close(%d)\n"</span>, s));
00251   <span class="keywordflow">if</span> (!<a class="code" href="sockets_8c.html#a6">socksem</a>)
00252       <a class="code" href="sockets_8c.html#a6">socksem</a> = <a class="code" href="sys_8h.html#a9">sys_sem_new</a>(1);
00253 
00254   <span class="comment">/* We cannot allow multiple closes of the same socket. */</span>
00255   <a class="code" href="sys_8c.html#a1">sys_sem_wait</a>(<a class="code" href="sockets_8c.html#a6">socksem</a>);
00256 
00257   sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(s);
00258   <span class="keywordflow">if</span> (!sock) {
00259       <a class="code" href="sys_8h.html#a10">sys_sem_signal</a>(<a class="code" href="sockets_8c.html#a6">socksem</a>);
00260       <span class="keywordflow">return</span> -1;
00261   }
00262 
00263   <a class="code" href="api__lib_8c.html#a16">netconn_delete</a>(sock-&gt;conn);
00264   <span class="keywordflow">if</span> (sock-&gt;lastdata) {
00265     <a class="code" href="api__lib_8c.html#a1">netbuf_delete</a>(sock-&gt;lastdata);
00266   }
00267   sock-&gt;lastdata = <a class="code" href="def_8h.html#a2">NULL</a>;
00268   sock-&gt;lastoffset = 0;
00269   sock-&gt;conn = <a class="code" href="def_8h.html#a2">NULL</a>;
00270   <a class="code" href="sys_8h.html#a10">sys_sem_signal</a>(<a class="code" href="sockets_8c.html#a6">socksem</a>);
00271   <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, 0);
00272   <span class="keywordflow">return</span> 0;
00273 }
00274 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00275 <span class="keywordtype">int</span>
<a name="l00276"></a><a class="code" href="sockets_8c.html#a15">00276</a> <a class="code" href="sockets_8c.html#a15">lwip_connect</a>(<span class="keywordtype">int</span> s, <span class="keyword">struct</span> <a class="code" href="structsockaddr.html">sockaddr</a> *name, socklen_t namelen)
00277 {
00278   <span class="keyword">struct </span><a class="code" href="structlwip__socket.html">lwip_socket</a> *sock;
00279   <a class="code" href="err_8h.html#a13">err_t</a> err;
00280 
00281   sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(s);
00282   <span class="keywordflow">if</span> (!sock) {
00283     <span class="keywordflow">return</span> -1;
00284   }
00285 
00286   <span class="keywordflow">if</span> (((<span class="keyword">struct </span><a class="code" href="structsockaddr__in.html">sockaddr_in</a> *)name)-&gt;sin_family == <a class="code" href="sockets_8h.html#a23">AF_UNSPEC</a>) {
00287     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_connect(%d, AF_UNSPEC)\n"</span>, s));
00288     err = <a class="code" href="api__lib_8c.html#a22">netconn_disconnect</a>(sock-&gt;conn);
00289   } <span class="keywordflow">else</span> {
00290     <span class="keyword">struct </span><a class="code" href="structip__addr.html">ip_addr</a> remote_addr;
00291     u16_t remote_port;
00292 
00293     remote_addr.<a class="code" href="structip__addr.html#o0">addr</a> = ((<span class="keyword">struct </span><a class="code" href="structsockaddr__in.html">sockaddr_in</a> *)name)-&gt;sin_addr.s_addr;
00294     remote_port = ((<span class="keyword">struct </span><a class="code" href="structsockaddr__in.html">sockaddr_in</a> *)name)-&gt;sin_port;
00295 
00296 <span class="preprocessor">#if SOCKETS_DEBUG</span>
00297 <span class="preprocessor"></span>    <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_connect(%d, addr="</span>, s));
00298     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a33">ip_addr_debug_print</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, &amp;remote_addr);
00299     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">" port=%u)\n"</span>, <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(remote_port)));
00300 <span class="preprocessor">#endif</span>
00301 <span class="preprocessor"></span>
00302     err = <a class="code" href="api__lib_8c.html#a21">netconn_connect</a>(sock-&gt;conn, &amp;remote_addr, <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(remote_port));
00303    }
00304 
00305   <span class="keywordflow">if</span> (err != <a class="code" href="err_8h.html#a0">ERR_OK</a>) {
00306     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_connect(%d) failed, err=%d\n"</span>, s, err));
00307     <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, <a class="code" href="sockets_8c.html#a1">err_to_errno</a>(err));
00308     <span class="keywordflow">return</span> -1;
00309   }
00310 
00311   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_connect(%d) succeeded\n"</span>, s));
00312   <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, 0);
00313   <span class="keywordflow">return</span> 0;
00314 }
00315 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00316 <span class="keywordtype">int</span>
<a name="l00317"></a><a class="code" href="sockets_8c.html#a16">00317</a> <a class="code" href="sockets_8c.html#a16">lwip_listen</a>(<span class="keywordtype">int</span> s, <span class="keywordtype">int</span> backlog)
00318 {
00319   <span class="keyword">struct </span><a class="code" href="structlwip__socket.html">lwip_socket</a> *sock;
00320   <a class="code" href="err_8h.html#a13">err_t</a> err;
00321 
00322   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_listen(%d, backlog=%d)\n"</span>, s, backlog));
00323   sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(s);
00324   <span class="keywordflow">if</span> (!sock) {
00325     <span class="keywordflow">return</span> -1;
00326   }
00327 
00328   err = <a class="code" href="api__lib_8c.html#a23">netconn_listen</a>(sock-&gt;conn);
00329 
00330   <span class="keywordflow">if</span> (err != <a class="code" href="err_8h.html#a0">ERR_OK</a>) {
00331     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_listen(%d) failed, err=%d\n"</span>, s, err));
00332     <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, <a class="code" href="sockets_8c.html#a1">err_to_errno</a>(err));
00333     <span class="keywordflow">return</span> -1;
00334   }
00335 
00336   <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, 0);
00337   <span class="keywordflow">return</span> 0;
00338 }
00339 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00340 <span class="keywordtype">int</span>
<a name="l00341"></a><a class="code" href="sockets_8c.html#a17">00341</a> <a class="code" href="sockets_8c.html#a17">lwip_recvfrom</a>(<span class="keywordtype">int</span> s, <span class="keywordtype">void</span> *<a class="code" href="structmem.html">mem</a>, <span class="keywordtype">int</span> len, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags,
00342         <span class="keyword">struct</span> <a class="code" href="structsockaddr.html">sockaddr</a> *from, socklen_t *fromlen)
00343 {
00344   <span class="keyword">struct </span><a class="code" href="structlwip__socket.html">lwip_socket</a> *sock;
00345   <span class="keyword">struct </span><a class="code" href="structnetbuf.html">netbuf</a> *buf;
00346   u16_t buflen, copylen;
00347   <span class="keyword">struct </span><a class="code" href="structip__addr.html">ip_addr</a> *addr;
00348   u16_t port;
00349 
00350 
00351   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n"</span>, s, mem, len, flags));
00352   sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(s);
00353   <span class="keywordflow">if</span> (!sock) {
00354     <span class="keywordflow">return</span> -1;
00355   }
00356 
00357   <span class="comment">/* Check if there is data left from the last recv operation. */</span>
00358   <span class="keywordflow">if</span> (sock-&gt;lastdata) {
00359     buf = sock-&gt;lastdata;
00360   } <span class="keywordflow">else</span> {
00361     <span class="comment">/* If this is non-blocking call, then check first */</span>
00362     <span class="keywordflow">if</span> (((flags &amp; <a class="code" href="sockets_8h.html#a32">MSG_DONTWAIT</a>) || (sock-&gt;flags &amp; <a class="code" href="sockets_8h.html#a48">O_NONBLOCK</a>))
00363   &amp;&amp; !sock-&gt;rcvevent)
00364     {
00365       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_recvfrom(%d): returning EWOULDBLOCK\n"</span>, s));
00366       <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, EWOULDBLOCK);
00367       <span class="keywordflow">return</span> -1;
00368     }
00369 
00370     <span class="comment">/* No data was left from the previous operation, so we try to get</span>
00371 <span class="comment">       some from the network. */</span>
00372     buf = <a class="code" href="api__lib_8c.html#a25">netconn_recv</a>(sock-&gt;conn);
00373 
00374     <span class="keywordflow">if</span> (!buf) {
00375       <span class="comment">/* We should really do some error checking here. */</span>
00376       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_recvfrom(%d): buf == NULL!\n"</span>, s));
00377       <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, 0);
00378       <span class="keywordflow">return</span> 0;
00379     }
00380   }
00381 
00382   buflen = <a class="code" href="api__lib_8c.html#a6">netbuf_len</a>(buf);
00383 
00384   buflen -= sock-&gt;lastoffset;
00385 
00386   <span class="keywordflow">if</span> (len &gt; buflen) {
00387     copylen = buflen;
00388   } <span class="keywordflow">else</span> {
00389     copylen = len;
00390   }
00391 
00392   <span class="comment">/* copy the contents of the received buffer into</span>
00393 <span class="comment">     the supplied memory pointer mem */</span>
00394   <a class="code" href="api__lib_8c.html#a10">netbuf_copy_partial</a>(buf, mem, copylen, sock-&gt;lastoffset);
00395 
00396   <span class="comment">/* Check to see from where the data was. */</span>
00397   <span class="keywordflow">if</span> (from &amp;&amp; fromlen) {
00398     <span class="keyword">struct </span><a class="code" href="structsockaddr__in.html">sockaddr_in</a> sin;
00399 
00400     addr = <a class="code" href="api__lib_8c.html#a12">netbuf_fromaddr</a>(buf);
00401     port = <a class="code" href="api__lib_8c.html#a13">netbuf_fromport</a>(buf);
00402 
00403     memset(&amp;sin, 0, <span class="keyword">sizeof</span>(sin));
00404     sin.<a class="code" href="structsockaddr__in.html#o0">sin_len</a> = <span class="keyword">sizeof</span>(sin);
00405     sin.<a class="code" href="structsockaddr__in.html#o1">sin_family</a> = <a class="code" href="sockets_8h.html#a24">AF_INET</a>;
00406     sin.<a class="code" href="structsockaddr__in.html#o2">sin_port</a> = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(port);
00407     sin.<a class="code" href="structsockaddr__in.html#o3">sin_addr</a>.<a class="code" href="structin__addr.html#o0">s_addr</a> = addr-&gt;addr;
00408 
00409     <span class="keywordflow">if</span> (*fromlen &gt; <span class="keyword">sizeof</span>(sin))
00410       *fromlen = <span class="keyword">sizeof</span>(sin);
00411 
00412     memcpy(from, &amp;sin, *fromlen);
00413 
00414 <span class="preprocessor">#if SOCKETS_DEBUG</span>
00415 <span class="preprocessor"></span>    <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_recvfrom(%d): addr="</span>, s));
00416     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a33">ip_addr_debug_print</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, addr);
00417     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">" port=%u len=%u\n"</span>, port, copylen));
00418 <span class="preprocessor">#endif</span>
00419 <span class="preprocessor"></span>  } <span class="keywordflow">else</span> {
00420 <span class="preprocessor">#if SOCKETS_DEBUG &gt; 0</span>
00421 <span class="preprocessor"></span>    addr = <a class="code" href="api__lib_8c.html#a12">netbuf_fromaddr</a>(buf);
00422     port = <a class="code" href="api__lib_8c.html#a13">netbuf_fromport</a>(buf);
00423 
00424     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_recvfrom(%d): addr="</span>, s));
00425     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a33">ip_addr_debug_print</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, addr);
00426     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">" port=%u len=%u\n"</span>, port, copylen));
00427 <span class="preprocessor">#endif</span>
00428 <span class="preprocessor"></span>
00429   }
00430 
00431   <span class="comment">/* If this is a TCP socket, check if there is data left in the</span>
00432 <span class="comment">     buffer. If so, it should be saved in the sock structure for next</span>
00433 <span class="comment">     time around. */</span>
00434   <span class="keywordflow">if</span> (<a class="code" href="api_8h.html#a46">netconn_type</a>(sock-&gt;conn) == <a class="code" href="api_8h.html#a46a2">NETCONN_TCP</a> &amp;&amp; buflen - copylen &gt; 0) {
00435     sock-&gt;lastdata = buf;
00436     sock-&gt;lastoffset += copylen;
00437   } <span class="keywordflow">else</span> {
00438     sock-&gt;lastdata = <a class="code" href="def_8h.html#a2">NULL</a>;
00439     sock-&gt;lastoffset = 0;
00440     <a class="code" href="api__lib_8c.html#a1">netbuf_delete</a>(buf);
00441   }
00442 
00443 
00444   <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, 0);
00445   <span class="keywordflow">return</span> copylen;
00446 }
00447 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00448 <span class="keywordtype">int</span>
<a name="l00449"></a><a class="code" href="sockets_8c.html#a18">00449</a> <a class="code" href="sockets_8c.html#a18">lwip_read</a>(<span class="keywordtype">int</span> s, <span class="keywordtype">void</span> *<a class="code" href="structmem.html">mem</a>, <span class="keywordtype">int</span> len)
00450 {
00451   <span class="keywordflow">return</span> <a class="code" href="sockets_8c.html#a17">lwip_recvfrom</a>(s, mem, len, 0, <a class="code" href="def_8h.html#a2">NULL</a>, <a class="code" href="def_8h.html#a2">NULL</a>);
00452 }
00453 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00454 <span class="keywordtype">int</span>
<a name="l00455"></a><a class="code" href="sockets_8c.html#a19">00455</a> <a class="code" href="sockets_8c.html#a19">lwip_recv</a>(<span class="keywordtype">int</span> s, <span class="keywordtype">void</span> *<a class="code" href="structmem.html">mem</a>, <span class="keywordtype">int</span> len, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags)
00456 {
00457   <span class="keywordflow">return</span> <a class="code" href="sockets_8c.html#a17">lwip_recvfrom</a>(s, mem, len, flags, <a class="code" href="def_8h.html#a2">NULL</a>, <a class="code" href="def_8h.html#a2">NULL</a>);
00458 }
00459 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00460 <span class="keywordtype">int</span>
<a name="l00461"></a><a class="code" href="sockets_8c.html#a20">00461</a> <a class="code" href="sockets_8c.html#a20">lwip_send</a>(<span class="keywordtype">int</span> s, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> size, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags)
00462 {
00463   <span class="keyword">struct </span><a class="code" href="structlwip__socket.html">lwip_socket</a> *sock;
00464   <span class="keyword">struct </span><a class="code" href="structnetbuf.html">netbuf</a> *buf;
00465   <a class="code" href="err_8h.html#a13">err_t</a> err;
00466 
00467   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_send(%d, data=%p, size=%d, flags=0x%x)\n"</span>, s, data, size, flags));
00468 
00469   sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(s);
00470   <span class="keywordflow">if</span> (!sock) {
00471     <span class="keywordflow">return</span> -1;
00472   }
00473 
00474   <span class="keywordflow">switch</span> (<a class="code" href="api_8h.html#a46">netconn_type</a>(sock-&gt;conn)) {
00475   <span class="keywordflow">case</span> <a class="code" href="api_8h.html#a46a3">NETCONN_UDP</a>:
00476     <span class="comment">/* create a buffer */</span>
00477     buf = <a class="code" href="api__lib_8c.html#a0">netbuf_new</a>();
00478 
00479     <span class="keywordflow">if</span> (!buf) {
00480       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_send(%d) ENOBUFS\n"</span>, s));
00481       <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, ENOBUFS);
00482       <span class="keywordflow">return</span> -1;
00483     }
00484 
00485     <span class="comment">/* make the buffer point to the data that should</span>
00486 <span class="comment">       be sent */</span>
00487     <a class="code" href="api__lib_8c.html#a4">netbuf_ref</a>(buf, data, size);
00488 
00489     <span class="comment">/* send the data */</span>
00490     err = <a class="code" href="api__lib_8c.html#a26">netconn_send</a>(sock-&gt;conn, buf);
00491 
00492     <span class="comment">/* deallocated the buffer */</span>
00493     <a class="code" href="api__lib_8c.html#a1">netbuf_delete</a>(buf);
00494     <span class="keywordflow">break</span>;
00495   <span class="keywordflow">case</span> <a class="code" href="api_8h.html#a46a2">NETCONN_TCP</a>:
00496     err = <a class="code" href="api__lib_8c.html#a27">netconn_write</a>(sock-&gt;conn, data, size, <a class="code" href="api_8h.html#a1">NETCONN_COPY</a>);
00497     <span class="keywordflow">break</span>;
00498   <span class="keywordflow">default</span>:
00499     err = <a class="code" href="err_8h.html#a8">ERR_ARG</a>;
00500     <span class="keywordflow">break</span>;
00501   }
00502   <span class="keywordflow">if</span> (err != <a class="code" href="err_8h.html#a0">ERR_OK</a>) {
00503     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_send(%d) err=%d\n"</span>, s, err));
00504     <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, <a class="code" href="sockets_8c.html#a1">err_to_errno</a>(err));
00505     <span class="keywordflow">return</span> -1;
00506   }
00507 
00508   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_send(%d) ok size=%d\n"</span>, s, size));
00509   <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, 0);
00510   <span class="keywordflow">return</span> size;
00511 }
00512 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00513 <span class="keywordtype">int</span>
<a name="l00514"></a><a class="code" href="sockets_8c.html#a21">00514</a> <a class="code" href="sockets_8c.html#a21">lwip_sendto</a>(<span class="keywordtype">int</span> s, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> size, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags,
00515        <span class="keyword">struct</span> <a class="code" href="structsockaddr.html">sockaddr</a> *to, socklen_t tolen)
00516 {
00517   <span class="keyword">struct </span><a class="code" href="structlwip__socket.html">lwip_socket</a> *sock;
00518   <span class="keyword">struct </span><a class="code" href="structip__addr.html">ip_addr</a> remote_addr, addr;
00519   u16_t remote_port, port;
00520   <span class="keywordtype">int</span> ret,connected;
00521 
00522   sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(s);
00523   <span class="keywordflow">if</span> (!sock) {
00524     <span class="keywordflow">return</span> -1;
00525   }
00526 
00527   <span class="comment">/* get the peer if currently connected */</span>
00528   connected = (<a class="code" href="api__lib_8c.html#a18">netconn_peer</a>(sock-&gt;conn, &amp;addr, &amp;port) == <a class="code" href="err_8h.html#a0">ERR_OK</a>);
00529 
00530   remote_addr.<a class="code" href="structip__addr.html#o0">addr</a> = ((<span class="keyword">struct </span><a class="code" href="structsockaddr__in.html">sockaddr_in</a> *)to)-&gt;sin_addr.s_addr;
00531   remote_port = ((<span class="keyword">struct </span><a class="code" href="structsockaddr__in.html">sockaddr_in</a> *)to)-&gt;sin_port;
00532 
00533 <span class="preprocessor">#if SOCKETS_DEBUG</span>
00534 <span class="preprocessor"></span>  <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_sendto(%d, data=%p, size=%d, flags=0x%x to="</span>, s, data, size, flags));
00535   <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a33">ip_addr_debug_print</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, &amp;remote_addr);
00536   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">" port=%u\n"</span>, <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(remote_port)));
00537 <span class="preprocessor">#endif</span>
00538 <span class="preprocessor"></span>
00539   <a class="code" href="api__lib_8c.html#a21">netconn_connect</a>(sock-&gt;conn, &amp;remote_addr, <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(remote_port));
00540 
00541   ret = <a class="code" href="sockets_8c.html#a20">lwip_send</a>(s, data, size, flags);
00542 
00543   <span class="comment">/* reset the remote address and port number</span>
00544 <span class="comment">     of the connection */</span>
00545   <span class="keywordflow">if</span> (connected)
00546     <a class="code" href="api__lib_8c.html#a21">netconn_connect</a>(sock-&gt;conn, &amp;addr, port);
00547   <span class="keywordflow">else</span>
00548   <a class="code" href="api__lib_8c.html#a22">netconn_disconnect</a>(sock-&gt;conn);
00549   <span class="keywordflow">return</span> ret;
00550 }
00551 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00552 <span class="keywordtype">int</span>
<a name="l00553"></a><a class="code" href="sockets_8c.html#a22">00553</a> <a class="code" href="sockets_8c.html#a22">lwip_socket</a>(<span class="keywordtype">int</span> domain, <span class="keywordtype">int</span> type, <span class="keywordtype">int</span> protocol)
00554 {
00555   <span class="keyword">struct </span><a class="code" href="structnetconn.html">netconn</a> *conn;
00556   <span class="keywordtype">int</span> i;
00557 
00558   <span class="comment">/* create a netconn */</span>
00559   <span class="keywordflow">switch</span> (type) {
00560   <span class="keywordflow">case</span> <a class="code" href="sockets_8h.html#a2">SOCK_DGRAM</a>:
00561     conn = <a class="code" href="api__lib_8c.html#a15">netconn_new_with_callback</a>(<a class="code" href="api_8h.html#a46a3">NETCONN_UDP</a>, <a class="code" href="sockets_8c.html#a9">event_callback</a>);
00562     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_socket(%s, SOCK_DGRAM, %d) = "</span>, domain == <a class="code" href="sockets_8h.html#a25">PF_INET</a> ? <span class="stringliteral">"PF_INET"</span> : <span class="stringliteral">"UNKNOWN"</span>, protocol));
00563     <span class="keywordflow">break</span>;
00564   <span class="keywordflow">case</span> <a class="code" href="sockets_8h.html#a1">SOCK_STREAM</a>:
00565     conn = <a class="code" href="api__lib_8c.html#a15">netconn_new_with_callback</a>(<a class="code" href="api_8h.html#a46a2">NETCONN_TCP</a>, <a class="code" href="sockets_8c.html#a9">event_callback</a>);
00566     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_socket(%s, SOCK_STREAM, %d) = "</span>, domain == <a class="code" href="sockets_8h.html#a25">PF_INET</a> ? <span class="stringliteral">"PF_INET"</span> : <span class="stringliteral">"UNKNOWN"</span>, protocol));
00567     <span class="keywordflow">break</span>;
00568   <span class="keywordflow">default</span>:
00569     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_socket(%d, %d/UNKNOWN, %d) = -1\n"</span>, domain, type, protocol));
00570     <a class="code" href="sockets_8c.html#a2">set_errno</a>(EINVAL);
00571     <span class="keywordflow">return</span> -1;
00572   }
00573 
00574   <span class="keywordflow">if</span> (!conn) {
00575     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"-1 / ENOBUFS (could not create netconn)\n"</span>));
00576     <a class="code" href="sockets_8c.html#a2">set_errno</a>(ENOBUFS);
00577     <span class="keywordflow">return</span> -1;
00578   }
00579 
00580   i = <a class="code" href="sockets_8c.html#a11">alloc_socket</a>(conn);
00581 
00582   <span class="keywordflow">if</span> (i == -1) {
00583     <a class="code" href="api__lib_8c.html#a16">netconn_delete</a>(conn);
00584   <a class="code" href="sockets_8c.html#a2">set_errno</a>(ENOBUFS);
00585   <span class="keywordflow">return</span> -1;
00586   }
00587   conn-&gt;socket = i;
00588   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"%d\n"</span>, i));
00589   <a class="code" href="sockets_8c.html#a2">set_errno</a>(0);
00590   <span class="keywordflow">return</span> i;
00591 }
00592 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00593 <span class="keywordtype">int</span>
<a name="l00594"></a><a class="code" href="sockets_8c.html#a23">00594</a> <a class="code" href="sockets_8c.html#a23">lwip_write</a>(<span class="keywordtype">int</span> s, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> size)
00595 {
00596    <span class="keywordflow">return</span> <a class="code" href="sockets_8c.html#a20">lwip_send</a>(s, data, size, 0);
00597 }
00598 
00599 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00600 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00601"></a><a class="code" href="sockets_8c.html#a24">00601</a> <a class="code" href="sockets_8c.html#a24">lwip_selscan</a>(<span class="keywordtype">int</span> maxfdp1, <a class="code" href="structfd__set.html">fd_set</a> *readset, <a class="code" href="structfd__set.html">fd_set</a> *writeset, <a class="code" href="structfd__set.html">fd_set</a> *exceptset)
00602 {
00603     <span class="keywordtype">int</span> i, nready = 0;
00604     <a class="code" href="structfd__set.html">fd_set</a> lreadset, lwriteset, lexceptset;
00605     <span class="keyword">struct </span><a class="code" href="sockets_8c.html#a22">lwip_socket</a> *p_sock;
00606 
00607     <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(&amp;lreadset);
00608     <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(&amp;lwriteset);
00609     <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(&amp;lexceptset);
00610 
00611     <span class="comment">/* Go through each socket in each list to count number of sockets which</span>
00612 <span class="comment">       currently match */</span>
00613     <span class="keywordflow">for</span>(i = 0; i &lt; maxfdp1; i++)
00614     {
00615         <span class="keywordflow">if</span> (<a class="code" href="sockets_8h.html#a52">FD_ISSET</a>(i, readset))
00616         {
00617             <span class="comment">/* See if netconn of this socket is ready for read */</span>
00618             p_sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(i);
00619             <span class="keywordflow">if</span> (p_sock &amp;&amp; (p_sock-&gt;lastdata || p_sock-&gt;rcvevent))
00620             {
00621                 <a class="code" href="sockets_8h.html#a50">FD_SET</a>(i, &amp;lreadset);
00622                 <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_selscan: fd=%d ready for reading\n"</span>, i));
00623                 nready++;
00624             }
00625         }
00626         <span class="keywordflow">if</span> (<a class="code" href="sockets_8h.html#a52">FD_ISSET</a>(i, writeset))
00627         {
00628             <span class="comment">/* See if netconn of this socket is ready for write */</span>
00629             p_sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(i);
00630             <span class="keywordflow">if</span> (p_sock &amp;&amp; p_sock-&gt;sendevent)
00631             {
00632                 <a class="code" href="sockets_8h.html#a50">FD_SET</a>(i, &amp;lwriteset);
00633                 <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_selscan: fd=%d ready for writing\n"</span>, i));
00634                 nready++;
00635             }
00636         }
00637     }
00638     *readset = lreadset;
00639     *writeset = lwriteset;
00640     <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(exceptset);
00641 
00642     <span class="keywordflow">return</span> nready;
00643 }
00644 
00645 
00646 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00647 <span class="keywordtype">int</span>
<a name="l00648"></a><a class="code" href="sockets_8c.html#a25">00648</a> <a class="code" href="sockets_8c.html#a25">lwip_select</a>(<span class="keywordtype">int</span> maxfdp1, <a class="code" href="structfd__set.html">fd_set</a> *readset, <a class="code" href="structfd__set.html">fd_set</a> *writeset, <a class="code" href="structfd__set.html">fd_set</a> *exceptset,
00649                <span class="keyword">struct</span> <a class="code" href="structtimeval.html">timeval</a> *timeout)
00650 {
00651     <span class="keywordtype">int</span> i;
00652     <span class="keywordtype">int</span> nready;
00653     <a class="code" href="structfd__set.html">fd_set</a> lreadset, lwriteset, lexceptset;
00654     u32_t msectimeout;
00655     <span class="keyword">struct </span><a class="code" href="structlwip__select__cb.html">lwip_select_cb</a> select_cb;
00656     <span class="keyword">struct </span><a class="code" href="structlwip__select__cb.html">lwip_select_cb</a> *p_selcb;
00657 
00658     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n"</span>, maxfdp1, (<span class="keywordtype">void</span> *)readset, (<span class="keywordtype">void</span> *) writeset, (<span class="keywordtype">void</span> *) exceptset, timeout ? timeout-&gt;<a class="code" href="structtimeval.html#o0">tv_sec</a> : -1L, timeout ? timeout-&gt;<a class="code" href="structtimeval.html#o1">tv_usec</a> : -1L));
00659 
00660     select_cb.<a class="code" href="structlwip__select__cb.html#o0">next</a> = 0;
00661     select_cb.<a class="code" href="structlwip__select__cb.html#o1">readset</a> = readset;
00662     select_cb.<a class="code" href="structlwip__select__cb.html#o2">writeset</a> = writeset;
00663     select_cb.<a class="code" href="structlwip__select__cb.html#o3">exceptset</a> = exceptset;
00664     select_cb.<a class="code" href="structlwip__select__cb.html#o4">sem_signalled</a> = 0;
00665 
00666     <span class="comment">/* Protect ourselves searching through the list */</span>
00667     <span class="keywordflow">if</span> (!<a class="code" href="sockets_8c.html#a7">selectsem</a>)
00668         <a class="code" href="sockets_8c.html#a7">selectsem</a> = <a class="code" href="sys_8h.html#a9">sys_sem_new</a>(1);
00669     <a class="code" href="sys_8c.html#a1">sys_sem_wait</a>(<a class="code" href="sockets_8c.html#a7">selectsem</a>);
00670 
00671     <span class="keywordflow">if</span> (readset)
00672         lreadset = *readset;
00673     <span class="keywordflow">else</span>
00674         <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(&amp;lreadset);
00675     <span class="keywordflow">if</span> (writeset)
00676         lwriteset = *writeset;
00677     <span class="keywordflow">else</span>
00678         <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(&amp;lwriteset);
00679     <span class="keywordflow">if</span> (exceptset)
00680         lexceptset = *exceptset;
00681     <span class="keywordflow">else</span>
00682         <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(&amp;lexceptset);
00683 
00684     <span class="comment">/* Go through each socket in each list to count number of sockets which</span>
00685 <span class="comment">       currently match */</span>
00686     nready = <a class="code" href="sockets_8c.html#a24">lwip_selscan</a>(maxfdp1, &amp;lreadset, &amp;lwriteset, &amp;lexceptset);
00687 
00688     <span class="comment">/* If we don't have any current events, then suspend if we are supposed to */</span>
00689     <span class="keywordflow">if</span> (!nready)
00690     {
00691         <span class="keywordflow">if</span> (timeout &amp;&amp; timeout-&gt;<a class="code" href="structtimeval.html#o0">tv_sec</a> == 0 &amp;&amp; timeout-&gt;<a class="code" href="structtimeval.html#o1">tv_usec</a> == 0)
00692         {
00693             <a class="code" href="sys_8h.html#a10">sys_sem_signal</a>(<a class="code" href="sockets_8c.html#a7">selectsem</a>);
00694             <span class="keywordflow">if</span> (readset)
00695                 <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(readset);
00696             <span class="keywordflow">if</span> (writeset)
00697                 <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(writeset);
00698             <span class="keywordflow">if</span> (exceptset)
00699                 <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(exceptset);
00700 
00701             <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_select: no timeout, returning 0\n"</span>));
00702             <a class="code" href="sockets_8c.html#a2">set_errno</a>(0);
00703 
00704             <span class="keywordflow">return</span> 0;
00705         }
00706 
00707         <span class="comment">/* add our semaphore to list */</span>
00708         <span class="comment">/* We don't actually need any dynamic memory. Our entry on the</span>
00709 <span class="comment">         * list is only valid while we are in this function, so it's ok</span>
00710 <span class="comment">         * to use local variables */</span>
00711 
00712         select_cb.<a class="code" href="structlwip__select__cb.html#o5">sem</a> = <a class="code" href="sys_8h.html#a9">sys_sem_new</a>(0);
00713         <span class="comment">/* Note that we are still protected */</span>
00714         <span class="comment">/* Put this select_cb on top of list */</span>
00715         select_cb.<a class="code" href="structlwip__select__cb.html#o0">next</a> = <a class="code" href="sockets_8c.html#a5">select_cb_list</a>;
00716         <a class="code" href="sockets_8c.html#a5">select_cb_list</a> = &amp;select_cb;
00717 
00718         <span class="comment">/* Now we can safely unprotect */</span>
00719         <a class="code" href="sys_8h.html#a10">sys_sem_signal</a>(<a class="code" href="sockets_8c.html#a7">selectsem</a>);
00720 
00721         <span class="comment">/* Now just wait to be woken */</span>
00722         <span class="keywordflow">if</span> (timeout == 0)
00723             <span class="comment">/* Wait forever */</span>
00724             msectimeout = 0;
00725         <span class="keywordflow">else</span>
00726             msectimeout =  ((timeout-&gt;<a class="code" href="structtimeval.html#o0">tv_sec</a> * 1000) + (timeout-&gt;<a class="code" href="structtimeval.html#o1">tv_usec</a> /1000));
00727 
00728         i = <a class="code" href="sys_8c.html#a5">sys_sem_wait_timeout</a>(select_cb.sem, msectimeout);
00729 
00730         <span class="comment">/* Take us off the list */</span>
00731         <a class="code" href="sys_8c.html#a1">sys_sem_wait</a>(<a class="code" href="sockets_8c.html#a7">selectsem</a>);
00732         <span class="keywordflow">if</span> (<a class="code" href="sockets_8c.html#a5">select_cb_list</a> == &amp;select_cb)
00733             <a class="code" href="sockets_8c.html#a5">select_cb_list</a> = select_cb.<a class="code" href="structlwip__select__cb.html#o0">next</a>;
00734         <span class="keywordflow">else</span>
00735             <span class="keywordflow">for</span> (p_selcb = <a class="code" href="sockets_8c.html#a5">select_cb_list</a>; p_selcb; p_selcb = p_selcb-&gt;<a class="code" href="structlwip__select__cb.html#o0">next</a>)
00736                 <span class="keywordflow">if</span> (p_selcb-&gt;next == &amp;select_cb)
00737                 {
00738                     p_selcb-&gt;<a class="code" href="structlwip__select__cb.html#o0">next</a> = select_cb.<a class="code" href="structlwip__select__cb.html#o0">next</a>;
00739                     <span class="keywordflow">break</span>;
00740                 }
00741 
00742         <a class="code" href="sys_8h.html#a10">sys_sem_signal</a>(<a class="code" href="sockets_8c.html#a7">selectsem</a>);
00743 
00744         <a class="code" href="sys_8h.html#a12">sys_sem_free</a>(select_cb.sem);
00745         <span class="keywordflow">if</span> (i == 0)             <span class="comment">/* Timeout */</span>
00746         {
00747             <span class="keywordflow">if</span> (readset)
00748                 <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(readset);
00749             <span class="keywordflow">if</span> (writeset)
00750                 <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(writeset);
00751             <span class="keywordflow">if</span> (exceptset)
00752                 <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(exceptset);
00753 
00754             <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_select: timeout expired\n"</span>));
00755             <a class="code" href="sockets_8c.html#a2">set_errno</a>(0);
00756 
00757             <span class="keywordflow">return</span> 0;
00758         }
00759 
00760         <span class="keywordflow">if</span> (readset)
00761             lreadset = *readset;
00762         <span class="keywordflow">else</span>
00763             <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(&amp;lreadset);
00764         <span class="keywordflow">if</span> (writeset)
00765             lwriteset = *writeset;
00766         <span class="keywordflow">else</span>
00767             <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(&amp;lwriteset);
00768         <span class="keywordflow">if</span> (exceptset)
00769             lexceptset = *exceptset;
00770         <span class="keywordflow">else</span>
00771             <a class="code" href="sockets_8h.html#a53">FD_ZERO</a>(&amp;lexceptset);
00772 
00773         <span class="comment">/* See what's set */</span>
00774         nready = <a class="code" href="sockets_8c.html#a24">lwip_selscan</a>(maxfdp1, &amp;lreadset, &amp;lwriteset, &amp;lexceptset);
00775     }
00776     <span class="keywordflow">else</span>
00777         <a class="code" href="sys_8h.html#a10">sys_sem_signal</a>(<a class="code" href="sockets_8c.html#a7">selectsem</a>);
00778 
00779     <span class="keywordflow">if</span> (readset)
00780         *readset = lreadset;
00781     <span class="keywordflow">if</span> (writeset)
00782         *writeset = lwriteset;
00783     <span class="keywordflow">if</span> (exceptset)
00784         *exceptset = lexceptset;
00785 
00786     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_select: nready=%d\n"</span>, nready));
00787     <a class="code" href="sockets_8c.html#a2">set_errno</a>(0);
00788 
00789     <span class="keywordflow">return</span> nready;
00790 }
00791 
00792 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00793 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00794"></a><a class="code" href="sockets_8c.html#a9">00794</a> <a class="code" href="sockets_8c.html#a9">event_callback</a>(<span class="keyword">struct</span> <a class="code" href="structnetconn.html">netconn</a> *conn, <span class="keyword">enum</span> netconn_evt evt, u16_t len)
00795 {
00796     <span class="keywordtype">int</span> s;
00797     <span class="keyword">struct </span><a class="code" href="sockets_8c.html#a22">lwip_socket</a> *sock;
00798     <span class="keyword">struct </span><a class="code" href="structlwip__select__cb.html">lwip_select_cb</a> *scb;
00799 
00800     <span class="comment">/* Get socket */</span>
00801     <span class="keywordflow">if</span> (conn)
00802     {
00803         s = conn-&gt;<a class="code" href="structnetconn.html#o10">socket</a>;
00804         <span class="keywordflow">if</span> (s &lt; 0)
00805         {
00806             <span class="comment">/* Data comes in right away after an accept, even though</span>
00807 <span class="comment">             * the server task might not have created a new socket yet.</span>
00808 <span class="comment">             * Just count down (or up) if that's the case and we</span>
00809 <span class="comment">             * will use the data later. Note that only receive events</span>
00810 <span class="comment">             * can happen before the new socket is set up. */</span>
00811             <span class="keywordflow">if</span> (evt == <a class="code" href="api_8h.html#a48a12">NETCONN_EVT_RCVPLUS</a>)
00812                 conn-&gt;<a class="code" href="structnetconn.html#o10">socket</a>--;
00813             <span class="keywordflow">return</span>;
00814         }
00815 
00816         sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(s);
00817         <span class="keywordflow">if</span> (!sock)
00818             <span class="keywordflow">return</span>;
00819     }
00820     <span class="keywordflow">else</span>
00821         <span class="keywordflow">return</span>;
00822 
00823     <span class="keywordflow">if</span> (!<a class="code" href="sockets_8c.html#a7">selectsem</a>)
00824         <a class="code" href="sockets_8c.html#a7">selectsem</a> = <a class="code" href="sys_8h.html#a9">sys_sem_new</a>(1);
00825 
00826     <a class="code" href="sys_8c.html#a1">sys_sem_wait</a>(<a class="code" href="sockets_8c.html#a7">selectsem</a>);
00827     <span class="comment">/* Set event as required */</span>
00828     <span class="keywordflow">switch</span> (evt)
00829     {
00830       <span class="keywordflow">case</span> <a class="code" href="api_8h.html#a48a12">NETCONN_EVT_RCVPLUS</a>:
00831         sock-&gt;rcvevent++;
00832         <span class="keywordflow">break</span>;
00833       <span class="keywordflow">case</span> <a class="code" href="api_8h.html#a48a13">NETCONN_EVT_RCVMINUS</a>:
00834         sock-&gt;rcvevent--;
00835         <span class="keywordflow">break</span>;
00836       <span class="keywordflow">case</span> <a class="code" href="api_8h.html#a48a14">NETCONN_EVT_SENDPLUS</a>:
00837         sock-&gt;sendevent = 1;
00838         <span class="keywordflow">break</span>;
00839       <span class="keywordflow">case</span> <a class="code" href="api_8h.html#a48a15">NETCONN_EVT_SENDMINUS</a>:
00840         sock-&gt;sendevent = 0;
00841         <span class="keywordflow">break</span>;
00842     }
00843     <a class="code" href="sys_8h.html#a10">sys_sem_signal</a>(<a class="code" href="sockets_8c.html#a7">selectsem</a>);
00844 
00845     <span class="comment">/* Now decide if anyone is waiting for this socket */</span>
00846     <span class="comment">/* NOTE: This code is written this way to protect the select link list</span>
00847 <span class="comment">       but to avoid a deadlock situation by releasing socksem before</span>
00848 <span class="comment">       signalling for the select. This means we need to go through the list</span>
00849 <span class="comment">       multiple times ONLY IF a select was actually waiting. We go through</span>
00850 <span class="comment">       the list the number of waiting select calls + 1. This list is</span>
00851 <span class="comment">       expected to be small. */</span>
00852     <span class="keywordflow">while</span> (1)
00853     {
00854         <a class="code" href="sys_8c.html#a1">sys_sem_wait</a>(<a class="code" href="sockets_8c.html#a7">selectsem</a>);
00855         <span class="keywordflow">for</span> (scb = <a class="code" href="sockets_8c.html#a5">select_cb_list</a>; scb; scb = scb-&gt;<a class="code" href="structlwip__select__cb.html#o0">next</a>)
00856         {
00857             <span class="keywordflow">if</span> (scb-&gt;sem_signalled == 0)
00858             {
00859                 <span class="comment">/* Test this select call for our socket */</span>
00860                 <span class="keywordflow">if</span> (scb-&gt;readset &amp;&amp; <a class="code" href="sockets_8h.html#a52">FD_ISSET</a>(s, scb-&gt;readset))
00861                     <span class="keywordflow">if</span> (sock-&gt;rcvevent)
00862                         <span class="keywordflow">break</span>;
00863                 <span class="keywordflow">if</span> (scb-&gt;writeset &amp;&amp; <a class="code" href="sockets_8h.html#a52">FD_ISSET</a>(s, scb-&gt;writeset))
00864                     <span class="keywordflow">if</span> (sock-&gt;sendevent)
00865                         <span class="keywordflow">break</span>;
00866             }
00867         }
00868         <span class="keywordflow">if</span> (scb)
00869         {
00870             scb-&gt;sem_signalled = 1;
00871             <a class="code" href="sys_8h.html#a10">sys_sem_signal</a>(<a class="code" href="sockets_8c.html#a7">selectsem</a>);
00872             <a class="code" href="sys_8h.html#a10">sys_sem_signal</a>(scb-&gt;sem);
00873         } <span class="keywordflow">else</span> {
00874             <a class="code" href="sys_8h.html#a10">sys_sem_signal</a>(<a class="code" href="sockets_8c.html#a7">selectsem</a>);
00875             <span class="keywordflow">break</span>;
00876         }
00877     }
00878 
00879 }
00880 
00881 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00882 
00883 
<a name="l00884"></a><a class="code" href="sockets_8c.html#a26">00884</a> <span class="keywordtype">int</span> <a class="code" href="sockets_8c.html#a26">lwip_shutdown</a>(<span class="keywordtype">int</span> s, <span class="keywordtype">int</span> how)
00885 {
00886   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_shutdown(%d, how=%d)\n"</span>, s, how));
00887   <span class="keywordflow">return</span> <a class="code" href="sockets_8c.html#a14">lwip_close</a>(s); <span class="comment">/* XXX temporary hack until proper implementation */</span>
00888 }
00889 
<a name="l00890"></a><a class="code" href="sockets_8c.html#a27">00890</a> <span class="keywordtype">int</span> <a class="code" href="sockets_8c.html#a27">lwip_getpeername</a> (<span class="keywordtype">int</span> s, <span class="keyword">struct</span> <a class="code" href="structsockaddr.html">sockaddr</a> *name, socklen_t *namelen)
00891 {
00892   <span class="keyword">struct </span><a class="code" href="sockets_8c.html#a22">lwip_socket</a> *sock;
00893   <span class="keyword">struct </span><a class="code" href="structsockaddr__in.html">sockaddr_in</a> sin;
00894   <span class="keyword">struct </span><a class="code" href="structip__addr.html">ip_addr</a> naddr;
00895 
00896   sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(s);
00897   <span class="keywordflow">if</span> (!sock) {
00898     <span class="keywordflow">return</span> -1;
00899   }
00900 
00901   memset(&amp;sin, 0, <span class="keyword">sizeof</span>(sin));
00902   sin.<a class="code" href="structsockaddr__in.html#o0">sin_len</a> = <span class="keyword">sizeof</span>(sin);
00903   sin.<a class="code" href="structsockaddr__in.html#o1">sin_family</a> = <a class="code" href="sockets_8h.html#a24">AF_INET</a>;
00904 
00905   <span class="comment">/* get the IP address and port of the remote host */</span>
00906   <a class="code" href="api__lib_8c.html#a18">netconn_peer</a>(sock-&gt;conn, &amp;naddr, &amp;sin.<a class="code" href="structsockaddr__in.html#o2">sin_port</a>);
00907 
00908 <span class="preprocessor">#if SOCKETS_DEBUG</span>
00909 <span class="preprocessor"></span>  <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_getpeername(%d, addr="</span>, s));
00910   <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a33">ip_addr_debug_print</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, &amp;naddr);
00911   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">" port=%d)\n"</span>, sin.<a class="code" href="structsockaddr__in.html#o2">sin_port</a>));
00912 <span class="preprocessor">#endif</span>
00913 <span class="preprocessor"></span>
00914   sin.<a class="code" href="structsockaddr__in.html#o2">sin_port</a> = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(sin.<a class="code" href="structsockaddr__in.html#o2">sin_port</a>);
00915   sin.<a class="code" href="structsockaddr__in.html#o3">sin_addr</a>.<a class="code" href="structin__addr.html#o0">s_addr</a> = naddr.<a class="code" href="structip__addr.html#o0">addr</a>;
00916 
00917   <span class="keywordflow">if</span> (*namelen &gt; <span class="keyword">sizeof</span>(sin))
00918       *namelen = <span class="keyword">sizeof</span>(sin);
00919 
00920   memcpy(name, &amp;sin, *namelen);
00921   <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, 0);
00922   <span class="keywordflow">return</span> 0;
00923 }
00924 
<a name="l00925"></a><a class="code" href="sockets_8c.html#a28">00925</a> <span class="keywordtype">int</span> <a class="code" href="sockets_8c.html#a28">lwip_getsockname</a> (<span class="keywordtype">int</span> s, <span class="keyword">struct</span> <a class="code" href="structsockaddr.html">sockaddr</a> *name, socklen_t *namelen)
00926 {
00927   <span class="keyword">struct </span><a class="code" href="sockets_8c.html#a22">lwip_socket</a> *sock;
00928   <span class="keyword">struct </span><a class="code" href="structsockaddr__in.html">sockaddr_in</a> sin;
00929   <span class="keyword">struct </span><a class="code" href="structip__addr.html">ip_addr</a> *naddr;
00930 
00931   sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(s);
00932   <span class="keywordflow">if</span> (!sock) {
00933     <span class="keywordflow">return</span> -1;
00934   }
00935 
00936   memset(&amp;sin, 0, <span class="keyword">sizeof</span>(sin));
00937   sin.<a class="code" href="structsockaddr__in.html#o0">sin_len</a> = <span class="keyword">sizeof</span>(sin);
00938   sin.<a class="code" href="structsockaddr__in.html#o1">sin_family</a> = <a class="code" href="sockets_8h.html#a24">AF_INET</a>;
00939 
00940   <span class="comment">/* get the IP address and port of the remote host */</span>
00941   <a class="code" href="api__lib_8c.html#a19">netconn_addr</a>(sock-&gt;conn, &amp;naddr, &amp;sin.<a class="code" href="structsockaddr__in.html#o2">sin_port</a>);
00942 
00943 <span class="preprocessor">#if SOCKETS_DEBUG</span>
00944 <span class="preprocessor"></span>  <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_getsockname(%d, addr="</span>, s));
00945   <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a33">ip_addr_debug_print</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, naddr);
00946   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">" port=%d)\n"</span>, sin.<a class="code" href="structsockaddr__in.html#o2">sin_port</a>));
00947 <span class="preprocessor">#endif</span>
00948 <span class="preprocessor"></span>
00949   sin.<a class="code" href="structsockaddr__in.html#o2">sin_port</a> = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(sin.<a class="code" href="structsockaddr__in.html#o2">sin_port</a>);
00950   sin.<a class="code" href="structsockaddr__in.html#o3">sin_addr</a>.<a class="code" href="structin__addr.html#o0">s_addr</a> = naddr-&gt;addr;
00951 
00952   <span class="keywordflow">if</span> (*namelen &gt; <span class="keyword">sizeof</span>(sin))
00953       *namelen = <span class="keyword">sizeof</span>(sin);
00954 
00955   memcpy(name, &amp;sin, *namelen);
00956   <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, 0);
00957   <span class="keywordflow">return</span> 0;
00958 }
00959 
<a name="l00960"></a><a class="code" href="sockets_8c.html#a29">00960</a> <span class="keywordtype">int</span> <a class="code" href="sockets_8c.html#a29">lwip_getsockopt</a> (<span class="keywordtype">int</span> s, <span class="keywordtype">int</span> level, <span class="keywordtype">int</span> optname, <span class="keywordtype">void</span> *optval, socklen_t *optlen)
00961 {
00962   <span class="keywordtype">int</span> err = ENOSYS;
00963   <span class="keyword">struct </span><a class="code" href="sockets_8c.html#a22">lwip_socket</a> *sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(s);
00964 
00965   <span class="keywordflow">if</span> (!sock) {
00966     <span class="keywordflow">return</span> -1;
00967   }
00968 
00969   <span class="keywordflow">if</span> (level == <a class="code" href="sockets_8h.html#a22">SOL_SOCKET</a>) {
00970     <span class="keywordflow">switch</span> (optname) {
00971       <span class="keywordflow">case</span> <a class="code" href="sockets_8h.html#a20">SO_ERROR</a>:
00972         <span class="keywordflow">if</span> (!optval || !optlen || (*optlen != <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>))) {
00973           err = EINVAL;
00974           <span class="keywordflow">break</span>;
00975         }
00976         *(<span class="keywordtype">int</span> *)optval = sock-&gt;err;
00977         sock-&gt;err = 0;
00978         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n"</span>, s, *(<span class="keywordtype">int</span> *)optval));
00979         err = 0;
00980         <span class="keywordflow">break</span>;
00981       <span class="keywordflow">default</span>:
00982         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n"</span>, s, optname));
00983         <span class="keywordflow">break</span>;
00984     }
00985   } <span class="keywordflow">else</span> {
00986     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n"</span>, s, level, optname));
00987   }
00988   <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, err);
00989   <span class="keywordflow">return</span> err ? -1 : 0;
00990 }
00991 
<a name="l00992"></a><a class="code" href="sockets_8c.html#a30">00992</a> <span class="keywordtype">int</span> <a class="code" href="sockets_8c.html#a30">lwip_setsockopt</a> (<span class="keywordtype">int</span> s, <span class="keywordtype">int</span> level, <span class="keywordtype">int</span> optname, <span class="keyword">const</span> <span class="keywordtype">void</span> *optval, socklen_t optlen)
00993 {
00994   <span class="keyword">struct </span><a class="code" href="sockets_8c.html#a22">lwip_socket</a> *sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(s);
00995   <span class="keywordtype">int</span> err = ENOSYS;
00996 
00997   <span class="keywordflow">if</span> (!sock) {
00998     <span class="keywordflow">return</span> -1;
00999   }
01000 
01001   <span class="keywordflow">if</span> (level == <a class="code" href="sockets_8h.html#a22">SOL_SOCKET</a>) {
01002     <span class="keywordflow">switch</span> (optname) {
01003       <span class="keywordflow">case</span> <a class="code" href="sockets_8h.html#a6">SO_REUSEADDR</a>:
01004         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_setsockopt(%d, SOL_SOCKET, SO_REUSEADDR, ..)\n"</span>, s));
01005            <span class="comment">/* XXX just pretend we support this for now */</span>
01006           err = 0;
01007         <span class="keywordflow">break</span>;
01008       <span class="keywordflow">default</span>:
01009         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n"</span>, s, optname));
01010         <span class="keywordflow">break</span>;
01011     }
01012   } <span class="keywordflow">else</span> {
01013     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n"</span>, s, level, optname));
01014   }
01015 
01016   <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, err);
01017   <span class="keywordflow">return</span> err ? -1 : 0;
01018 }
01019 
<a name="l01020"></a><a class="code" href="sockets_8c.html#a31">01020</a> <span class="keywordtype">int</span> <a class="code" href="sockets_8c.html#a31">lwip_ioctl</a>(<span class="keywordtype">int</span> s, <span class="keywordtype">long</span> cmd, <span class="keywordtype">void</span> *argp)
01021 {
01022   <span class="keyword">struct </span><a class="code" href="sockets_8c.html#a22">lwip_socket</a> *sock = <a class="code" href="sockets_8c.html#a10">get_socket</a>(s);
01023 
01024   <span class="keywordflow">if</span> (!sock) {
01025     <span class="keywordflow">return</span> -1;
01026   }
01027 
01028   <span class="keywordflow">switch</span> (cmd) {
01029   <span class="keywordflow">case</span> <a class="code" href="sockets_8h.html#a41">FIONREAD</a>:
01030     <span class="keywordflow">if</span> (!argp) {
01031       <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, EINVAL);
01032       <span class="keywordflow">return</span> -1;
01033     }
01034 
01035     *((u16_t*)argp) = sock-&gt;conn-&gt;recv_avail;
01036 
01037     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_ioctl(%d, FIONREAD, %p) = %u\n"</span>, s, argp, *((u16_t*)argp)));
01038       <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, 0);
01039     <span class="keywordflow">return</span> 0;
01040 
01041   <span class="keywordflow">case</span> <a class="code" href="sockets_8h.html#a42">FIONBIO</a>:
01042     <span class="keywordflow">if</span> (argp &amp;&amp; *(u32_t*)argp)
01043       sock-&gt;flags |= <a class="code" href="sockets_8h.html#a48">O_NONBLOCK</a>;
01044     <span class="keywordflow">else</span>
01045       sock-&gt;flags &amp;= ~<a class="code" href="sockets_8h.html#a48">O_NONBLOCK</a>;
01046     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_ioctl(%d, FIONBIO, %d)\n"</span>, s, !!(sock-&gt;flags &amp; <a class="code" href="sockets_8h.html#a48">O_NONBLOCK</a>)));
01047       <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, 0);
01048     <span class="keywordflow">return</span> 0;
01049 
01050   <span class="keywordflow">default</span>:
01051     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a65">SOCKETS_DEBUG</a>, (<span class="stringliteral">"lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n"</span>, s, cmd, argp));
01052     <a class="code" href="sockets_8c.html#a3">sock_set_errno</a>(sock, ENOSYS); <span class="comment">/* not yet implemented */</span>
01053     <span class="keywordflow">return</span> -1;
01054   }
01055 }
01056 
</pre></div>	</td>
  </tr>
</table>
<hr>
<div align="center">Copyright (c) 2001-2003 Swedish Institute of Computer Science</div>
</html>
