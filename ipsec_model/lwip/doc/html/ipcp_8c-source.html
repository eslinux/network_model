
<html>
<head>
<title>lwIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="doxygen.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<table width="98%" border="0" align="center">
  <tr>
    <td>
      <h2>lwIP code documentation</h2>
<hr>

<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>ipcp.c</h1><a href="ipcp_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*****************************************************************************</span>
00002 <span class="comment">* ipcp.c - Network PPP IP Control Protocol program file.</span>
00003 <span class="comment">*</span>
00004 <span class="comment">* Copyright (c) 2003 by Marc Boucher, Services Informatiques (MBSI) inc.</span>
00005 <span class="comment">* portions Copyright (c) 1997 by Global Election Systems Inc.</span>
00006 <span class="comment">*</span>
00007 <span class="comment">* The authors hereby grant permission to use, copy, modify, distribute,</span>
00008 <span class="comment">* and license this software and its documentation for any purpose, provided</span>
00009 <span class="comment">* that existing copyright notices are retained in all copies and that this</span>
00010 <span class="comment">* notice and the following disclaimer are included verbatim in any </span>
00011 <span class="comment">* distributions. No written agreement, license, or royalty fee is required</span>
00012 <span class="comment">* for any of the authorized uses.</span>
00013 <span class="comment">*</span>
00014 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS *AS IS* AND ANY EXPRESS OR</span>
00015 <span class="comment">* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
00016 <span class="comment">* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. </span>
00017 <span class="comment">* IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
00018 <span class="comment">* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
00019 <span class="comment">* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
00020 <span class="comment">* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
00021 <span class="comment">* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
00022 <span class="comment">* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
00023 <span class="comment">* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00024 <span class="comment">*</span>
00025 <span class="comment">******************************************************************************</span>
00026 <span class="comment">* REVISION HISTORY</span>
00027 <span class="comment">*</span>
00028 <span class="comment">* 03-01-01 Marc Boucher &lt;marc@mbsi.ca&gt;</span>
00029 <span class="comment">*   Ported to lwIP.</span>
00030 <span class="comment">* 97-12-08 Guy Lancaster &lt;lancasterg@acm.org&gt;, Global Election Systems Inc.</span>
00031 <span class="comment">*       Original.</span>
00032 <span class="comment">*****************************************************************************/</span>
00033 <span class="comment">/*</span>
00034 <span class="comment"> * ipcp.c - PPP IP Control Protocol.</span>
00035 <span class="comment"> *</span>
00036 <span class="comment"> * Copyright (c) 1989 Carnegie Mellon University.</span>
00037 <span class="comment"> * All rights reserved.</span>
00038 <span class="comment"> *</span>
00039 <span class="comment"> * Redistribution and use in source and binary forms are permitted</span>
00040 <span class="comment"> * provided that the above copyright notice and this paragraph are</span>
00041 <span class="comment"> * duplicated in all such forms and that any documentation,</span>
00042 <span class="comment"> * advertising materials, and other materials related to such</span>
00043 <span class="comment"> * distribution and use acknowledge that the software was developed</span>
00044 <span class="comment"> * by Carnegie Mellon University.  The name of the</span>
00045 <span class="comment"> * University may not be used to endorse or promote products derived</span>
00046 <span class="comment"> * from this software without specific prior written permission.</span>
00047 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR</span>
00048 <span class="comment"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
00049 <span class="comment"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
00050 <span class="comment"> */</span>
00051 
00052 <span class="preprocessor">#include "<a class="code" href="ppp_8h.html">ppp.h</a>"</span>
00053 <span class="preprocessor">#if PPP_SUPPORT &gt; 0</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="auth_8h.html">auth.h</a>"</span>
00055 <span class="preprocessor">#include "<a class="code" href="fsm_8h.html">fsm.h</a>"</span>
00056 <span class="preprocessor">#include "<a class="code" href="vj_8h.html">vj.h</a>"</span>
00057 <span class="preprocessor">#include "<a class="code" href="ipcp_8h.html">ipcp.h</a>"</span>
00058 <span class="preprocessor">#include "<a class="code" href="pppdebug_8h.html">pppdebug.h</a>"</span>
00059 
00060 
00061 <span class="comment">/*************************/</span>
00062 <span class="comment">/*** LOCAL DEFINITIONS ***/</span>
00063 <span class="comment">/*************************/</span>
00064 <span class="comment">/* #define OLD_CI_ADDRS 1 */</span>    <span class="comment">/* Support deprecated address negotiation. */</span>
00065 
00066 <span class="comment">/*</span>
00067 <span class="comment"> * Lengths of configuration options.</span>
00068 <span class="comment"> */</span>
00069 <span class="preprocessor">#define CILEN_VOID      2</span>
00070 <span class="preprocessor"></span><span class="preprocessor">#define CILEN_COMPRESS  4       </span><span class="comment">/* min length for compression protocol opt. */</span>
00071 <span class="preprocessor">#define CILEN_VJ        6       </span><span class="comment">/* length for RFC1332 Van-Jacobson opt. */</span>
00072 <span class="preprocessor">#define CILEN_ADDR      6       </span><span class="comment">/* new-style single address option */</span>
00073 <span class="preprocessor">#define CILEN_ADDRS     10      </span><span class="comment">/* old-style dual address option */</span>
00074 
00075 
00076 
00077 <span class="comment">/***********************************/</span>
00078 <span class="comment">/*** LOCAL FUNCTION DECLARATIONS ***/</span>
00079 <span class="comment">/***********************************/</span>
00080 <span class="comment">/*</span>
00081 <span class="comment"> * Callbacks for fsm code.  (CI = Configuration Information)</span>
00082 <span class="comment"> */</span>
00083 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_resetci (<a class="code" href="structfsm.html">fsm</a> *);       <span class="comment">/* Reset our CI */</span>
00084 <span class="keyword">static</span> <span class="keywordtype">int</span>  ipcp_cilen (<a class="code" href="structfsm.html">fsm</a> *);         <span class="comment">/* Return length of our CI */</span>
00085 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_addci (<a class="code" href="structfsm.html">fsm</a> *, u_char *, <span class="keywordtype">int</span> *); <span class="comment">/* Add our CI */</span>
00086 <span class="keyword">static</span> <span class="keywordtype">int</span>  ipcp_ackci (<a class="code" href="structfsm.html">fsm</a> *, u_char *, <span class="keywordtype">int</span>);  <span class="comment">/* Peer ack'd our CI */</span>
00087 <span class="keyword">static</span> <span class="keywordtype">int</span>  ipcp_nakci (<a class="code" href="structfsm.html">fsm</a> *, u_char *, <span class="keywordtype">int</span>);  <span class="comment">/* Peer nak'd our CI */</span>
00088 <span class="keyword">static</span> <span class="keywordtype">int</span>  ipcp_rejci (<a class="code" href="structfsm.html">fsm</a> *, u_char *, <span class="keywordtype">int</span>);  <span class="comment">/* Peer rej'd our CI */</span>
00089 <span class="keyword">static</span> <span class="keywordtype">int</span>  ipcp_reqci (<a class="code" href="structfsm.html">fsm</a> *, u_char *, <span class="keywordtype">int</span> *, <span class="keywordtype">int</span>); <span class="comment">/* Rcv CI */</span>
00090 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_up (<a class="code" href="structfsm.html">fsm</a> *);            <span class="comment">/* We're UP */</span>
00091 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_down (<a class="code" href="structfsm.html">fsm</a> *);          <span class="comment">/* We're DOWN */</span>
00092 <span class="preprocessor">#if 0</span>
00093 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_script (<a class="code" href="structfsm.html">fsm</a> *, <span class="keywordtype">char</span> *); <span class="comment">/* Run an up/down script */</span>
00094 <span class="preprocessor">#endif</span>
00095 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_finished (<a class="code" href="structfsm.html">fsm</a> *);      <span class="comment">/* Don't need lower layer */</span>
00096 
00097 <span class="comment">/*</span>
00098 <span class="comment"> * Protocol entry points from main code.</span>
00099 <span class="comment"> */</span>
00100 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_init (<span class="keywordtype">int</span>);
00101 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_open (<span class="keywordtype">int</span>);
00102 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_close (<span class="keywordtype">int</span>, <span class="keywordtype">char</span> *);
00103 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_lowerup (<span class="keywordtype">int</span>);
00104 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_lowerdown (<span class="keywordtype">int</span>);
00105 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_input (<span class="keywordtype">int</span>, u_char *, <span class="keywordtype">int</span>);
00106 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_protrej (<span class="keywordtype">int</span>);
00107 
00108 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_clear_addrs (<span class="keywordtype">int</span>);
00109 
00110 <span class="preprocessor">#define CODENAME(x)     ((x) == CONFACK ? "ACK" : \</span>
00111 <span class="preprocessor">                         (x) == CONFNAK ? "NAK" : "REJ")</span>
00112 <span class="preprocessor"></span>
00113 
00114 
00115 <span class="comment">/******************************/</span>
00116 <span class="comment">/*** PUBLIC DATA STRUCTURES ***/</span>
00117 <span class="comment">/******************************/</span>
00118 <span class="comment">/* global vars */</span>
00119 <a class="code" href="structipcp__options.html">ipcp_options</a> <a class="code" href="ipcp_8h.html#a14">ipcp_wantoptions</a>[NUM_PPP]; <span class="comment">/* Options that we want to request */</span>
00120 <a class="code" href="structipcp__options.html">ipcp_options</a> <a class="code" href="ipcp_8h.html#a15">ipcp_gotoptions</a>[NUM_PPP];  <span class="comment">/* Options that peer ack'd */</span>
00121 <a class="code" href="structipcp__options.html">ipcp_options</a> <a class="code" href="ipcp_8h.html#a16">ipcp_allowoptions</a>[NUM_PPP];        <span class="comment">/* Options we allow peer to request */</span>
00122 <a class="code" href="structipcp__options.html">ipcp_options</a> <a class="code" href="ipcp_8h.html#a17">ipcp_hisoptions</a>[NUM_PPP];  <span class="comment">/* Options that we ack'd */</span>
00123 
00124 <a class="code" href="structfsm.html">fsm</a> <a class="code" href="ipcp_8h.html#a13">ipcp_fsm</a>[NUM_PPP];          <span class="comment">/* IPCP fsm structure */</span>
00125 
00126 <span class="keyword">struct </span>protent <a class="code" href="ipcp_8h.html#a18">ipcp_protent</a> = {
00127     PPP_IPCP,
00128     ipcp_init,
00129     ipcp_input,
00130     ipcp_protrej,
00131     ipcp_lowerup,
00132     ipcp_lowerdown,
00133     ipcp_open,
00134     ipcp_close,
00135 <span class="preprocessor">#if 0</span>
00136 <span class="preprocessor"></span>    ipcp_printpkt,
00137     <a class="code" href="def_8h.html#a2">NULL</a>,
00138 <span class="preprocessor">#endif</span>
00139 <span class="preprocessor"></span>    1,
00140     <span class="stringliteral">"IPCP"</span>,
00141 <span class="preprocessor">#if 0</span>
00142 <span class="preprocessor"></span>    ip_check_options,
00143     <a class="code" href="def_8h.html#a2">NULL</a>,
00144     ip_active_pkt
00145 <span class="preprocessor">#endif</span>
00146 <span class="preprocessor"></span>};
00147 
00148 
00149 
00150 <span class="comment">/*****************************/</span>
00151 <span class="comment">/*** LOCAL DATA STRUCTURES ***/</span>
00152 <span class="comment">/*****************************/</span>
00153 <span class="comment">/* local vars */</span>
00154 <span class="keyword">static</span> <span class="keywordtype">int</span> cis_received[NUM_PPP];               <span class="comment">/* # Conf-Reqs received */</span>
00155 <span class="keyword">static</span> <span class="keywordtype">int</span> default_route_set[NUM_PPP];  <span class="comment">/* Have set up a default route */</span>
00156 
00157 <span class="keyword">static</span> <a class="code" href="structfsm__callbacks.html">fsm_callbacks</a> ipcp_callbacks = { <span class="comment">/* IPCP callback routines */</span>
00158     ipcp_resetci,               <span class="comment">/* Reset our Configuration Information */</span>
00159     ipcp_cilen,                 <span class="comment">/* Length of our Configuration Information */</span>
00160     ipcp_addci,                 <span class="comment">/* Add our Configuration Information */</span>
00161     ipcp_ackci,                 <span class="comment">/* ACK our Configuration Information */</span>
00162     ipcp_nakci,                 <span class="comment">/* NAK our Configuration Information */</span>
00163     ipcp_rejci,                 <span class="comment">/* Reject our Configuration Information */</span>
00164     ipcp_reqci,                 <span class="comment">/* Request peer's Configuration Information */</span>
00165     ipcp_up,                    <span class="comment">/* Called when fsm reaches OPENED state */</span>
00166     ipcp_down,                  <span class="comment">/* Called when fsm leaves OPENED state */</span>
00167     <a class="code" href="def_8h.html#a2">NULL</a>,                               <span class="comment">/* Called when we want the lower layer up */</span>
00168     ipcp_finished,              <span class="comment">/* Called when we want the lower layer down */</span>
00169     <a class="code" href="def_8h.html#a2">NULL</a>,                               <span class="comment">/* Called when Protocol-Reject received */</span>
00170     <a class="code" href="def_8h.html#a2">NULL</a>,                               <span class="comment">/* Retransmission is necessary */</span>
00171     <a class="code" href="def_8h.html#a2">NULL</a>,                               <span class="comment">/* Called to handle protocol-specific codes */</span>
00172     <span class="stringliteral">"IPCP"</span>                              <span class="comment">/* String name of protocol */</span>
00173 };
00174 
00175 
00176 
00177 <span class="comment">/**********************************/</span>
00178 <span class="comment">/*** LOCAL FUNCTION DEFINITIONS ***/</span>
00179 <span class="comment">/**********************************/</span>
00180 
00181 <span class="comment">/*</span>
00182 <span class="comment"> * ipcp_init - Initialize IPCP.</span>
00183 <span class="comment"> */</span>
00184 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_init(<span class="keywordtype">int</span> unit)
00185 {
00186         <a class="code" href="structfsm.html">fsm</a> *f = &amp;<a class="code" href="ipcp_8h.html#a13">ipcp_fsm</a>[unit];
00187         <a class="code" href="structipcp__options.html">ipcp_options</a> *wo = &amp;<a class="code" href="ipcp_8h.html#a14">ipcp_wantoptions</a>[unit];
00188         <a class="code" href="structipcp__options.html">ipcp_options</a> *ao = &amp;<a class="code" href="ipcp_8h.html#a16">ipcp_allowoptions</a>[unit];
00189         
00190         f-&gt;<a class="code" href="structfsm.html#o0">unit</a> = unit;
00191         f-&gt;<a class="code" href="structfsm.html#o1">protocol</a> = PPP_IPCP;
00192         f-&gt;<a class="code" href="structfsm.html#o13">callbacks</a> = &amp;ipcp_callbacks;
00193         <a class="code" href="fsm_8h.html#a24">fsm_init</a>(&amp;ipcp_fsm[unit]);
00194         
00195         memset(wo, 0, <span class="keyword">sizeof</span>(*wo));
00196         memset(ao, 0, <span class="keyword">sizeof</span>(*ao));
00197         
00198         wo-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a> = 1;
00199         wo-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a> = 0;
00200 <span class="preprocessor">#if VJ_SUPPORT &gt; 0</span>
00201 <span class="preprocessor"></span>        wo-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a> = 1;
00202 <span class="preprocessor">#else</span>
00203 <span class="preprocessor"></span>        wo-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a> = 0;
00204 <span class="preprocessor">#endif</span>
00205 <span class="preprocessor"></span>        wo-&gt;<a class="code" href="structipcp__options.html#o11">vj_protocol</a> = <a class="code" href="ipcp_8h.html#a10">IPCP_VJ_COMP</a>;
00206         wo-&gt;<a class="code" href="structipcp__options.html#o12">maxslotindex</a> = <a class="code" href="vj_8h.html#a0">MAX_SLOTS</a> - 1;
00207         wo-&gt;<a class="code" href="structipcp__options.html#o13">cflag</a> = 0;
00208         
00209         wo-&gt;<a class="code" href="structipcp__options.html#o3">default_route</a> = 1;
00210         
00211         ao-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a> = 1;
00212 <span class="preprocessor">#if VJ_SUPPORT &gt; 0</span>
00213 <span class="preprocessor"></span>        ao-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a> = 1;
00214 <span class="preprocessor">#else</span>
00215 <span class="preprocessor"></span>        ao-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a> = 0;
00216 <span class="preprocessor">#endif</span>
00217 <span class="preprocessor"></span>        ao-&gt;<a class="code" href="structipcp__options.html#o12">maxslotindex</a> = <a class="code" href="vj_8h.html#a0">MAX_SLOTS</a> - 1;
00218         ao-&gt;<a class="code" href="structipcp__options.html#o13">cflag</a> = 1;
00219         
00220         ao-&gt;<a class="code" href="structipcp__options.html#o3">default_route</a> = 1;
00221 }
00222 
00223 
00224 <span class="comment">/*</span>
00225 <span class="comment"> * ipcp_open - IPCP is allowed to come up.</span>
00226 <span class="comment"> */</span>
00227 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_open(<span class="keywordtype">int</span> unit)
00228 {
00229         <a class="code" href="fsm_8h.html#a27">fsm_open</a>(&amp;ipcp_fsm[unit]);
00230 }
00231 
00232 
00233 <span class="comment">/*</span>
00234 <span class="comment"> * ipcp_close - Take IPCP down.</span>
00235 <span class="comment"> */</span>
00236 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_close(<span class="keywordtype">int</span> unit, <span class="keywordtype">char</span> *reason)
00237 {
00238         <a class="code" href="fsm_8h.html#a28">fsm_close</a>(&amp;ipcp_fsm[unit], reason);
00239 }
00240 
00241 
00242 <span class="comment">/*</span>
00243 <span class="comment"> * ipcp_lowerup - The lower layer is up.</span>
00244 <span class="comment"> */</span>
00245 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_lowerup(<span class="keywordtype">int</span> unit)
00246 {
00247         <a class="code" href="fsm_8h.html#a25">fsm_lowerup</a>(&amp;ipcp_fsm[unit]);
00248 }
00249 
00250 
00251 <span class="comment">/*</span>
00252 <span class="comment"> * ipcp_lowerdown - The lower layer is down.</span>
00253 <span class="comment"> */</span>
00254 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_lowerdown(<span class="keywordtype">int</span> unit)
00255 {
00256         <a class="code" href="fsm_8h.html#a26">fsm_lowerdown</a>(&amp;ipcp_fsm[unit]);
00257 }
00258 
00259 
00260 <span class="comment">/*</span>
00261 <span class="comment"> * ipcp_input - Input IPCP packet.</span>
00262 <span class="comment"> */</span>
00263 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_input(<span class="keywordtype">int</span> unit, u_char *p, <span class="keywordtype">int</span> len)
00264 {
00265         <a class="code" href="fsm_8h.html#a29">fsm_input</a>(&amp;ipcp_fsm[unit], p, len);
00266 }
00267 
00268 
00269 <span class="comment">/*</span>
00270 <span class="comment"> * ipcp_protrej - A Protocol-Reject was received for IPCP.</span>
00271 <span class="comment"> *</span>
00272 <span class="comment"> * Pretend the lower layer went down, so we shut up.</span>
00273 <span class="comment"> */</span>
00274 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_protrej(<span class="keywordtype">int</span> unit)
00275 {
00276         <a class="code" href="fsm_8h.html#a26">fsm_lowerdown</a>(&amp;ipcp_fsm[unit]);
00277 }
00278 
00279 
00280 <span class="comment">/*</span>
00281 <span class="comment"> * ipcp_resetci - Reset our CI.</span>
00282 <span class="comment"> */</span>
00283 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_resetci(<a class="code" href="structfsm.html">fsm</a> *f)
00284 {
00285         <a class="code" href="structipcp__options.html">ipcp_options</a> *wo = &amp;<a class="code" href="ipcp_8h.html#a14">ipcp_wantoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00286         
00287         wo-&gt;<a class="code" href="structipcp__options.html#o2">req_addr</a> = wo-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a> &amp;&amp; <a class="code" href="ipcp_8h.html#a16">ipcp_allowoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>].neg_addr;
00288         <span class="keywordflow">if</span> (wo-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a> == 0)
00289                 wo-&gt;<a class="code" href="structipcp__options.html#o7">accept_local</a> = 1;
00290         <span class="keywordflow">if</span> (wo-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a> == 0)
00291                 wo-&gt;<a class="code" href="structipcp__options.html#o8">accept_remote</a> = 1;
00292         <span class="comment">/* Request DNS addresses from the peer */</span>
00293         wo-&gt;<a class="code" href="structipcp__options.html#o9">req_dns1</a> = ppp_settings.usepeerdns;
00294         wo-&gt;<a class="code" href="structipcp__options.html#o10">req_dns2</a> = ppp_settings.usepeerdns;
00295         <a class="code" href="ipcp_8h.html#a15">ipcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>] = *wo;
00296         cis_received[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>] = 0;
00297 }
00298 
00299 
00300 <span class="comment">/*</span>
00301 <span class="comment"> * ipcp_cilen - Return length of our CI.</span>
00302 <span class="comment"> */</span>
00303 <span class="keyword">static</span> <span class="keywordtype">int</span> ipcp_cilen(<a class="code" href="structfsm.html">fsm</a> *f)
00304 {
00305         <a class="code" href="structipcp__options.html">ipcp_options</a> *go = &amp;<a class="code" href="ipcp_8h.html#a15">ipcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00306         <a class="code" href="structipcp__options.html">ipcp_options</a> *wo = &amp;<a class="code" href="ipcp_8h.html#a14">ipcp_wantoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00307         <a class="code" href="structipcp__options.html">ipcp_options</a> *ho = &amp;<a class="code" href="ipcp_8h.html#a17">ipcp_hisoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00308         
00309 <span class="preprocessor">#define LENCIVJ(neg, old)       (neg ? (old? CILEN_COMPRESS : CILEN_VJ) : 0)</span>
00310 <span class="preprocessor"></span><span class="preprocessor">#define LENCIADDR(neg, old)     (neg ? (old? CILEN_ADDRS : CILEN_ADDR) : 0)</span>
00311 <span class="preprocessor"></span><span class="preprocessor">#define LENCIDNS(neg)           (neg ? (CILEN_ADDR) : 0)</span>
00312 <span class="preprocessor"></span>        
00313         <span class="comment">/*</span>
00314 <span class="comment">         * First see if we want to change our options to the old</span>
00315 <span class="comment">         * forms because we have received old forms from the peer.</span>
00316 <span class="comment">         */</span>
00317         <span class="keywordflow">if</span> (wo-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a> &amp;&amp; !go-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a> &amp;&amp; !go-&gt;<a class="code" href="structipcp__options.html#o1">old_addrs</a>) {
00318                 <span class="comment">/* use the old style of address negotiation */</span>
00319                 go-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a> = 1;
00320                 go-&gt;<a class="code" href="structipcp__options.html#o1">old_addrs</a> = 1;
00321         }
00322         <span class="keywordflow">if</span> (wo-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a> &amp;&amp; !go-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a> &amp;&amp; !go-&gt;<a class="code" href="structipcp__options.html#o6">old_vj</a>) {
00323                 <span class="comment">/* try an older style of VJ negotiation */</span>
00324                 <span class="keywordflow">if</span> (cis_received[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>] == 0) {
00325                         <span class="comment">/* keep trying the new style until we see some CI from the peer */</span>
00326                         go-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a> = 1;
00327                 } <span class="keywordflow">else</span> {
00328                         <span class="comment">/* use the old style only if the peer did */</span>
00329                         <span class="keywordflow">if</span> (ho-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a> &amp;&amp; ho-&gt;<a class="code" href="structipcp__options.html#o6">old_vj</a>) {
00330                                 go-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a> = 1;
00331                                 go-&gt;<a class="code" href="structipcp__options.html#o6">old_vj</a> = 1;
00332                                 go-&gt;<a class="code" href="structipcp__options.html#o11">vj_protocol</a> = ho-&gt;<a class="code" href="structipcp__options.html#o11">vj_protocol</a>;
00333                         }
00334                 }
00335         }
00336         
00337         <span class="keywordflow">return</span> (LENCIADDR(go-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a>, go-&gt;<a class="code" href="structipcp__options.html#o1">old_addrs</a>)
00338                         + LENCIVJ(go-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a>, go-&gt;<a class="code" href="structipcp__options.html#o6">old_vj</a>) +
00339                         LENCIDNS(go-&gt;<a class="code" href="structipcp__options.html#o9">req_dns1</a>) +
00340                         LENCIDNS(go-&gt;<a class="code" href="structipcp__options.html#o10">req_dns2</a>));
00341 }
00342 
00343 
00344 <span class="comment">/*</span>
00345 <span class="comment"> * ipcp_addci - Add our desired CIs to a packet.</span>
00346 <span class="comment"> */</span>
00347 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_addci(<a class="code" href="structfsm.html">fsm</a> *f, u_char *ucp, <span class="keywordtype">int</span> *lenp)
00348 {
00349         <a class="code" href="structipcp__options.html">ipcp_options</a> *go = &amp;<a class="code" href="ipcp_8h.html#a15">ipcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00350         <span class="keywordtype">int</span> len = *lenp;
00351         
00352 <span class="preprocessor">#define ADDCIVJ(opt, neg, val, old, maxslotindex, cflag) \</span>
00353 <span class="preprocessor">        if (neg) { \</span>
00354 <span class="preprocessor">                int vjlen = old? CILEN_COMPRESS : CILEN_VJ; \</span>
00355 <span class="preprocessor">                if (len &gt;= vjlen) { \</span>
00356 <span class="preprocessor">                        PUTCHAR(opt, ucp); \</span>
00357 <span class="preprocessor">                        PUTCHAR(vjlen, ucp); \</span>
00358 <span class="preprocessor">                        PUTSHORT(val, ucp); \</span>
00359 <span class="preprocessor">                        if (!old) { \</span>
00360 <span class="preprocessor">                                PUTCHAR(maxslotindex, ucp); \</span>
00361 <span class="preprocessor">                                PUTCHAR(cflag, ucp); \</span>
00362 <span class="preprocessor">                        } \</span>
00363 <span class="preprocessor">                        len -= vjlen; \</span>
00364 <span class="preprocessor">                } else \</span>
00365 <span class="preprocessor">                        neg = 0; \</span>
00366 <span class="preprocessor">        }</span>
00367 <span class="preprocessor"></span>        
00368 <span class="preprocessor">#define ADDCIADDR(opt, neg, old, val1, val2) \</span>
00369 <span class="preprocessor">        if (neg) { \</span>
00370 <span class="preprocessor">                int addrlen = (old? CILEN_ADDRS: CILEN_ADDR); \</span>
00371 <span class="preprocessor">                if (len &gt;= addrlen) { \</span>
00372 <span class="preprocessor">                        u32_t l; \</span>
00373 <span class="preprocessor">                        PUTCHAR(opt, ucp); \</span>
00374 <span class="preprocessor">                        PUTCHAR(addrlen, ucp); \</span>
00375 <span class="preprocessor">                        l = ntohl(val1); \</span>
00376 <span class="preprocessor">                        PUTLONG(l, ucp); \</span>
00377 <span class="preprocessor">                        if (old) { \</span>
00378 <span class="preprocessor">                                l = ntohl(val2); \</span>
00379 <span class="preprocessor">                                PUTLONG(l, ucp); \</span>
00380 <span class="preprocessor">                        } \</span>
00381 <span class="preprocessor">                        len -= addrlen; \</span>
00382 <span class="preprocessor">                } else \</span>
00383 <span class="preprocessor">                        neg = 0; \</span>
00384 <span class="preprocessor">        }</span>
00385 <span class="preprocessor"></span>
00386 <span class="preprocessor">#define ADDCIDNS(opt, neg, addr) \</span>
00387 <span class="preprocessor">        if (neg) { \</span>
00388 <span class="preprocessor">                if (len &gt;= CILEN_ADDR) { \</span>
00389 <span class="preprocessor">                        u32_t l; \</span>
00390 <span class="preprocessor">                        PUTCHAR(opt, ucp); \</span>
00391 <span class="preprocessor">                        PUTCHAR(CILEN_ADDR, ucp); \</span>
00392 <span class="preprocessor">                        l = ntohl(addr); \</span>
00393 <span class="preprocessor">                        PUTLONG(l, ucp); \</span>
00394 <span class="preprocessor">                        len -= CILEN_ADDR; \</span>
00395 <span class="preprocessor">                } else \</span>
00396 <span class="preprocessor">                        neg = 0; \</span>
00397 <span class="preprocessor">        }</span>
00398 <span class="preprocessor"></span>        
00399         ADDCIADDR((go-&gt;<a class="code" href="structipcp__options.html#o1">old_addrs</a>? CI_ADDRS: CI_ADDR), go-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a>,
00400                           go-&gt;<a class="code" href="structipcp__options.html#o1">old_addrs</a>, go-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a>, go-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>);
00401         
00402         ADDCIVJ(CI_COMPRESSTYPE, go-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a>, go-&gt;<a class="code" href="structipcp__options.html#o11">vj_protocol</a>, go-&gt;<a class="code" href="structipcp__options.html#o6">old_vj</a>,
00403                         go-&gt;<a class="code" href="structipcp__options.html#o12">maxslotindex</a>, go-&gt;<a class="code" href="structipcp__options.html#o13">cflag</a>);
00404         
00405         ADDCIDNS(CI_MS_DNS1, go-&gt;<a class="code" href="structipcp__options.html#o9">req_dns1</a>, go-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[0]);
00406 
00407         ADDCIDNS(CI_MS_DNS2, go-&gt;<a class="code" href="structipcp__options.html#o10">req_dns2</a>, go-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[1]);
00408 
00409         *lenp -= len;
00410 }
00411 
00412 
00413 <span class="comment">/*</span>
00414 <span class="comment"> * ipcp_ackci - Ack our CIs.</span>
00415 <span class="comment"> *</span>
00416 <span class="comment"> * Returns:</span>
00417 <span class="comment"> *      0 - Ack was bad.</span>
00418 <span class="comment"> *      1 - Ack was good.</span>
00419 <span class="comment"> */</span>
00420 <span class="keyword">static</span> <span class="keywordtype">int</span> ipcp_ackci(<a class="code" href="structfsm.html">fsm</a> *f, u_char *p, <span class="keywordtype">int</span> len)
00421 {
00422         <a class="code" href="structipcp__options.html">ipcp_options</a> *go = &amp;<a class="code" href="ipcp_8h.html#a15">ipcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00423         u_short cilen, citype, cishort;
00424         u32_t cilong;
00425         u_char cimaxslotindex, cicflag;
00426         
00427         <span class="comment">/*</span>
00428 <span class="comment">         * CIs must be in exactly the same order that we sent...</span>
00429 <span class="comment">         * Check packet length and CI length at each step.</span>
00430 <span class="comment">         * If we find any deviations, then this packet is bad.</span>
00431 <span class="comment">         */</span>
00432         
00433 <span class="preprocessor">#define ACKCIVJ(opt, neg, val, old, maxslotindex, cflag) \</span>
00434 <span class="preprocessor">        if (neg) { \</span>
00435 <span class="preprocessor">                int vjlen = old? CILEN_COMPRESS : CILEN_VJ; \</span>
00436 <span class="preprocessor">                if ((len -= vjlen) &lt; 0) \</span>
00437 <span class="preprocessor">                        goto bad; \</span>
00438 <span class="preprocessor">                GETCHAR(citype, p); \</span>
00439 <span class="preprocessor">                GETCHAR(cilen, p); \</span>
00440 <span class="preprocessor">                if (cilen != vjlen || \</span>
00441 <span class="preprocessor">                                citype != opt)  \</span>
00442 <span class="preprocessor">                        goto bad; \</span>
00443 <span class="preprocessor">                GETSHORT(cishort, p); \</span>
00444 <span class="preprocessor">                if (cishort != val) \</span>
00445 <span class="preprocessor">                        goto bad; \</span>
00446 <span class="preprocessor">                if (!old) { \</span>
00447 <span class="preprocessor">                        GETCHAR(cimaxslotindex, p); \</span>
00448 <span class="preprocessor">                        if (cimaxslotindex != maxslotindex) \</span>
00449 <span class="preprocessor">                                goto bad; \</span>
00450 <span class="preprocessor">                        GETCHAR(cicflag, p); \</span>
00451 <span class="preprocessor">                        if (cicflag != cflag) \</span>
00452 <span class="preprocessor">                                goto bad; \</span>
00453 <span class="preprocessor">                } \</span>
00454 <span class="preprocessor">        }</span>
00455 <span class="preprocessor"></span>        
00456 <span class="preprocessor">#define ACKCIADDR(opt, neg, old, val1, val2) \</span>
00457 <span class="preprocessor">        if (neg) { \</span>
00458 <span class="preprocessor">                int addrlen = (old? CILEN_ADDRS: CILEN_ADDR); \</span>
00459 <span class="preprocessor">                u32_t l; \</span>
00460 <span class="preprocessor">                if ((len -= addrlen) &lt; 0) \</span>
00461 <span class="preprocessor">                        goto bad; \</span>
00462 <span class="preprocessor">                GETCHAR(citype, p); \</span>
00463 <span class="preprocessor">                GETCHAR(cilen, p); \</span>
00464 <span class="preprocessor">                if (cilen != addrlen || \</span>
00465 <span class="preprocessor">                                citype != opt) \</span>
00466 <span class="preprocessor">                        goto bad; \</span>
00467 <span class="preprocessor">                GETLONG(l, p); \</span>
00468 <span class="preprocessor">                cilong = htonl(l); \</span>
00469 <span class="preprocessor">                if (val1 != cilong) \</span>
00470 <span class="preprocessor">                        goto bad; \</span>
00471 <span class="preprocessor">                if (old) { \</span>
00472 <span class="preprocessor">                        GETLONG(l, p); \</span>
00473 <span class="preprocessor">                        cilong = htonl(l); \</span>
00474 <span class="preprocessor">                        if (val2 != cilong) \</span>
00475 <span class="preprocessor">                                goto bad; \</span>
00476 <span class="preprocessor">                } \</span>
00477 <span class="preprocessor">        }</span>
00478 <span class="preprocessor"></span>
00479 <span class="preprocessor">#define ACKCIDNS(opt, neg, addr) \</span>
00480 <span class="preprocessor">        if (neg) { \</span>
00481 <span class="preprocessor">                u32_t l; \</span>
00482 <span class="preprocessor">                if ((len -= CILEN_ADDR) &lt; 0) \</span>
00483 <span class="preprocessor">                        goto bad; \</span>
00484 <span class="preprocessor">                GETCHAR(citype, p); \</span>
00485 <span class="preprocessor">                GETCHAR(cilen, p); \</span>
00486 <span class="preprocessor">                if (cilen != CILEN_ADDR || \</span>
00487 <span class="preprocessor">                                citype != opt) \</span>
00488 <span class="preprocessor">                        goto bad; \</span>
00489 <span class="preprocessor">                GETLONG(l, p); \</span>
00490 <span class="preprocessor">                cilong = htonl(l); \</span>
00491 <span class="preprocessor">                if (addr != cilong) \</span>
00492 <span class="preprocessor">                        goto bad; \</span>
00493 <span class="preprocessor">        }</span>
00494 <span class="preprocessor"></span>        
00495         ACKCIADDR((go-&gt;<a class="code" href="structipcp__options.html#o1">old_addrs</a>? CI_ADDRS: CI_ADDR), go-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a>,
00496                           go-&gt;<a class="code" href="structipcp__options.html#o1">old_addrs</a>, go-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a>, go-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>);
00497         
00498         ACKCIVJ(CI_COMPRESSTYPE, go-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a>, go-&gt;<a class="code" href="structipcp__options.html#o11">vj_protocol</a>, go-&gt;<a class="code" href="structipcp__options.html#o6">old_vj</a>,
00499                         go-&gt;<a class="code" href="structipcp__options.html#o12">maxslotindex</a>, go-&gt;<a class="code" href="structipcp__options.html#o13">cflag</a>);
00500         
00501         ACKCIDNS(CI_MS_DNS1, go-&gt;<a class="code" href="structipcp__options.html#o9">req_dns1</a>, go-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[0]);
00502 
00503         ACKCIDNS(CI_MS_DNS2, go-&gt;<a class="code" href="structipcp__options.html#o10">req_dns2</a>, go-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[1]);
00504 
00505         <span class="comment">/*</span>
00506 <span class="comment">         * If there are any remaining CIs, then this packet is bad.</span>
00507 <span class="comment">         */</span>
00508         <span class="keywordflow">if</span> (len != 0)
00509                 <span class="keywordflow">goto</span> bad;
00510         <span class="keywordflow">return</span> (1);
00511         
00512 bad:
00513         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_ackci: received bad Ack!\n"</span>));
00514         <span class="keywordflow">return</span> (0);
00515 }
00516 
00517 <span class="comment">/*</span>
00518 <span class="comment"> * ipcp_nakci - Peer has sent a NAK for some of our CIs.</span>
00519 <span class="comment"> * This should not modify any state if the Nak is bad</span>
00520 <span class="comment"> * or if IPCP is in the OPENED state.</span>
00521 <span class="comment"> *</span>
00522 <span class="comment"> * Returns:</span>
00523 <span class="comment"> *      0 - Nak was bad.</span>
00524 <span class="comment"> *      1 - Nak was good.</span>
00525 <span class="comment"> */</span>
00526 <span class="keyword">static</span> <span class="keywordtype">int</span> ipcp_nakci(<a class="code" href="structfsm.html">fsm</a> *f, u_char *p, <span class="keywordtype">int</span> len)
00527 {
00528         <a class="code" href="structipcp__options.html">ipcp_options</a> *go = &amp;<a class="code" href="ipcp_8h.html#a15">ipcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00529         u_char cimaxslotindex, cicflag;
00530         u_char citype, cilen, *next;
00531         u_short cishort;
00532         u32_t ciaddr1, ciaddr2, l, cidnsaddr;
00533         <a class="code" href="structipcp__options.html">ipcp_options</a> no;                <span class="comment">/* options we've seen Naks for */</span>
00534         <a class="code" href="structipcp__options.html">ipcp_options</a> <span class="keywordflow">try</span>;               <span class="comment">/* options to request next time */</span>
00535         
00536         BZERO(&amp;no, <span class="keyword">sizeof</span>(no));
00537         <span class="keywordflow">try</span> = *go;
00538         
00539         <span class="comment">/*</span>
00540 <span class="comment">         * Any Nak'd CIs must be in exactly the same order that we sent.</span>
00541 <span class="comment">         * Check packet length and CI length at each step.</span>
00542 <span class="comment">         * If we find any deviations, then this packet is bad.</span>
00543 <span class="comment">         */</span>
00544 <span class="preprocessor">#define NAKCIADDR(opt, neg, old, code) \</span>
00545 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
00546 <span class="preprocessor">                        len &gt;= (cilen = (old? CILEN_ADDRS: CILEN_ADDR)) &amp;&amp; \</span>
00547 <span class="preprocessor">                        p[1] == cilen &amp;&amp; \</span>
00548 <span class="preprocessor">                        p[0] == opt) { \</span>
00549 <span class="preprocessor">                len -= cilen; \</span>
00550 <span class="preprocessor">                INCPTR(2, p); \</span>
00551 <span class="preprocessor">                GETLONG(l, p); \</span>
00552 <span class="preprocessor">                ciaddr1 = htonl(l); \</span>
00553 <span class="preprocessor">                if (old) { \</span>
00554 <span class="preprocessor">                        GETLONG(l, p); \</span>
00555 <span class="preprocessor">                        ciaddr2 = htonl(l); \</span>
00556 <span class="preprocessor">                        no.old_addrs = 1; \</span>
00557 <span class="preprocessor">                } else \</span>
00558 <span class="preprocessor">                        ciaddr2 = 0; \</span>
00559 <span class="preprocessor">                no.neg = 1; \</span>
00560 <span class="preprocessor">                code \</span>
00561 <span class="preprocessor">        }</span>
00562 <span class="preprocessor"></span>        
00563 <span class="preprocessor">#define NAKCIVJ(opt, neg, code) \</span>
00564 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
00565 <span class="preprocessor">                        ((cilen = p[1]) == CILEN_COMPRESS || cilen == CILEN_VJ) &amp;&amp; \</span>
00566 <span class="preprocessor">                        len &gt;= cilen &amp;&amp; \</span>
00567 <span class="preprocessor">                        p[0] == opt) { \</span>
00568 <span class="preprocessor">                len -= cilen; \</span>
00569 <span class="preprocessor">                INCPTR(2, p); \</span>
00570 <span class="preprocessor">                GETSHORT(cishort, p); \</span>
00571 <span class="preprocessor">                no.neg = 1; \</span>
00572 <span class="preprocessor">                code \</span>
00573 <span class="preprocessor">        }</span>
00574 <span class="preprocessor"></span>        
00575 <span class="preprocessor">#define NAKCIDNS(opt, neg, code) \</span>
00576 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
00577 <span class="preprocessor">                        ((cilen = p[1]) == CILEN_ADDR) &amp;&amp; \</span>
00578 <span class="preprocessor">                        len &gt;= cilen &amp;&amp; \</span>
00579 <span class="preprocessor">                        p[0] == opt) { \</span>
00580 <span class="preprocessor">                len -= cilen; \</span>
00581 <span class="preprocessor">                INCPTR(2, p); \</span>
00582 <span class="preprocessor">                GETLONG(l, p); \</span>
00583 <span class="preprocessor">                cidnsaddr = htonl(l); \</span>
00584 <span class="preprocessor">                no.neg = 1; \</span>
00585 <span class="preprocessor">                code \</span>
00586 <span class="preprocessor">        }</span>
00587 <span class="preprocessor"></span>        
00588         <span class="comment">/*</span>
00589 <span class="comment">         * Accept the peer's idea of {our,his} address, if different</span>
00590 <span class="comment">         * from our idea, only if the accept_{local,remote} flag is set.</span>
00591 <span class="comment">         */</span>
00592         NAKCIADDR((go-&gt;<a class="code" href="structipcp__options.html#o1">old_addrs</a>? CI_ADDRS: CI_ADDR), neg_addr, go-&gt;<a class="code" href="structipcp__options.html#o1">old_addrs</a>,
00593           if (go-&gt;<a class="code" href="structipcp__options.html#o7">accept_local</a> &amp;&amp; ciaddr1) { <span class="comment">/* Do we know our address? */</span>
00594                   <span class="keywordflow">try</span>.ouraddr = ciaddr1;
00595                   <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"local IP address %s\n"</span>,
00596                              <a class="code" href="inet_8c.html#a6">inet_ntoa</a>(ciaddr1)));
00597           }
00598           <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structipcp__options.html#o8">accept_remote</a> &amp;&amp; ciaddr2) { <span class="comment">/* Does he know his? */</span>
00599                   <span class="keywordflow">try</span>.hisaddr = ciaddr2;
00600                   <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"remote IP address %s\n"</span>,
00601                              <a class="code" href="inet_8c.html#a6">inet_ntoa</a>(ciaddr2)));
00602           }
00603         );
00604         
00605         <span class="comment">/*</span>
00606 <span class="comment">         * Accept the peer's value of maxslotindex provided that it</span>
00607 <span class="comment">         * is less than what we asked for.  Turn off slot-ID compression</span>
00608 <span class="comment">         * if the peer wants.  Send old-style compress-type option if</span>
00609 <span class="comment">         * the peer wants.</span>
00610 <span class="comment">         */</span>
00611         NAKCIVJ(CI_COMPRESSTYPE, neg_vj,
00612                 <span class="keywordflow">if</span> (cilen == CILEN_VJ) {
00613                         GETCHAR(cimaxslotindex, p);
00614                         GETCHAR(cicflag, p);
00615                         <span class="keywordflow">if</span> (cishort == IPCP_VJ_COMP) {
00616                                 <span class="keywordflow">try</span>.old_vj = 0;
00617                                 <span class="keywordflow">if</span> (cimaxslotindex &lt; go-&gt;maxslotindex)
00618                                         <span class="keywordflow">try</span>.maxslotindex = cimaxslotindex;
00619                                 <span class="keywordflow">if</span> (!cicflag)
00620                                         <span class="keywordflow">try</span>.cflag = 0;
00621                         } <span class="keywordflow">else</span> {
00622                                 <span class="keywordflow">try</span>.neg_vj = 0;
00623                         }
00624                 } <span class="keywordflow">else</span> {
00625                         <span class="keywordflow">if</span> (cishort == IPCP_VJ_COMP || cishort == IPCP_VJ_COMP_OLD) {
00626                                 <span class="keywordflow">try</span>.old_vj = 1;
00627                                 <span class="keywordflow">try</span>.vj_protocol = cishort;
00628                         } <span class="keywordflow">else</span> {
00629                                 <span class="keywordflow">try</span>.neg_vj = 0;
00630                         }
00631                 }
00632         );
00633         
00634         NAKCIDNS(CI_MS_DNS1, req_dns1,
00635                         <span class="keywordflow">try</span>.dnsaddr[0] = cidnsaddr;
00636                         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"primary DNS address %s\n"</span>, <a class="code" href="inet_8c.html#a6">inet_ntoa</a>(cidnsaddr)));
00637                         );
00638 
00639         NAKCIDNS(CI_MS_DNS2, req_dns2,
00640                         <span class="keywordflow">try</span>.dnsaddr[1] = cidnsaddr;
00641                         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"secondary DNS address %s\n"</span>, <a class="code" href="inet_8c.html#a6">inet_ntoa</a>(cidnsaddr)));
00642                         );
00643 
00644         <span class="comment">/*</span>
00645 <span class="comment">        * There may be remaining CIs, if the peer is requesting negotiation</span>
00646 <span class="comment">        * on an option that we didn't include in our request packet.</span>
00647 <span class="comment">        * If they want to negotiate about IP addresses, we comply.</span>
00648 <span class="comment">        * If they want us to ask for compression, we refuse.</span>
00649 <span class="comment">        */</span>
00650         <span class="keywordflow">while</span> (len &gt; CILEN_VOID) {
00651                 GETCHAR(citype, p);
00652                 GETCHAR(cilen, p);
00653                 <span class="keywordflow">if</span>( (len -= cilen) &lt; 0 )
00654                         <span class="keywordflow">goto</span> bad;
00655                 next = p + cilen - 2;
00656                 
00657                 <span class="keywordflow">switch</span> (citype) {
00658                 <span class="keywordflow">case</span> <a class="code" href="ipcp_8h.html#a1">CI_COMPRESSTYPE</a>:
00659                         <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a> || no.<a class="code" href="structipcp__options.html#o5">neg_vj</a> ||
00660                                         (cilen != CILEN_VJ &amp;&amp; cilen != CILEN_COMPRESS))
00661                                 <span class="keywordflow">goto</span> bad;
00662                         no.<a class="code" href="structipcp__options.html#o5">neg_vj</a> = 1;
00663                         <span class="keywordflow">break</span>;
00664                 <span class="keywordflow">case</span> <a class="code" href="ipcp_8h.html#a0">CI_ADDRS</a>:
00665                         <span class="keywordflow">if</span> ((go-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a> &amp;&amp; go-&gt;<a class="code" href="structipcp__options.html#o1">old_addrs</a>) || no.<a class="code" href="structipcp__options.html#o1">old_addrs</a>
00666                                         || cilen != CILEN_ADDRS)
00667                                 <span class="keywordflow">goto</span> bad;
00668                         <span class="keywordflow">try</span>.neg_addr = 1;
00669                         <span class="keywordflow">try</span>.old_addrs = 1;
00670                         GETLONG(l, p);
00671                         ciaddr1 = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(l);
00672                         <span class="keywordflow">if</span> (ciaddr1 &amp;&amp; go-&gt;<a class="code" href="structipcp__options.html#o7">accept_local</a>)
00673                                 <span class="keywordflow">try</span>.ouraddr = ciaddr1;
00674                         GETLONG(l, p);
00675                         ciaddr2 = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(l);
00676                         <span class="keywordflow">if</span> (ciaddr2 &amp;&amp; go-&gt;<a class="code" href="structipcp__options.html#o8">accept_remote</a>)
00677                                 <span class="keywordflow">try</span>.hisaddr = ciaddr2;
00678                         no.<a class="code" href="structipcp__options.html#o1">old_addrs</a> = 1;
00679                         <span class="keywordflow">break</span>;
00680                 <span class="keywordflow">case</span> <a class="code" href="ipcp_8h.html#a2">CI_ADDR</a>:
00681                         <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a> || no.<a class="code" href="structipcp__options.html#o0">neg_addr</a> || cilen != CILEN_ADDR)
00682                                 <span class="keywordflow">goto</span> bad;
00683                         <span class="keywordflow">try</span>.old_addrs = 0;
00684                         GETLONG(l, p);
00685                         ciaddr1 = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(l);
00686                         <span class="keywordflow">if</span> (ciaddr1 &amp;&amp; go-&gt;<a class="code" href="structipcp__options.html#o7">accept_local</a>)
00687                                 <span class="keywordflow">try</span>.ouraddr = ciaddr1;
00688                         <span class="keywordflow">if</span> (<span class="keywordflow">try</span>.ouraddr != 0)
00689                                 <span class="keywordflow">try</span>.neg_addr = 1;
00690                         no.<a class="code" href="structipcp__options.html#o0">neg_addr</a> = 1;
00691                         <span class="keywordflow">break</span>;
00692                 }
00693                 p = next;
00694         }
00695         
00696         <span class="comment">/* If there is still anything left, this packet is bad. */</span>
00697         <span class="keywordflow">if</span> (len != 0)
00698                 <span class="keywordflow">goto</span> bad;
00699         
00700         <span class="comment">/*</span>
00701 <span class="comment">         * OK, the Nak is good.  Now we can update state.</span>
00702 <span class="comment">         */</span>
00703         <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structfsm.html#o2">state</a> != <a class="code" href="fsm_8h.html#a17">OPENED</a>)
00704                 *go = <span class="keywordflow">try</span>;
00705         
00706         <span class="keywordflow">return</span> 1;
00707         
00708 bad:
00709         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_nakci: received bad Nak!\n"</span>));
00710         <span class="keywordflow">return</span> 0;
00711 }
00712 
00713 
00714 <span class="comment">/*</span>
00715 <span class="comment"> * ipcp_rejci - Reject some of our CIs.</span>
00716 <span class="comment"> */</span>
00717 <span class="keyword">static</span> <span class="keywordtype">int</span> ipcp_rejci(<a class="code" href="structfsm.html">fsm</a> *f, u_char *p, <span class="keywordtype">int</span> len)
00718 {
00719         <a class="code" href="structipcp__options.html">ipcp_options</a> *go = &amp;<a class="code" href="ipcp_8h.html#a15">ipcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00720         u_char cimaxslotindex, ciflag, cilen;
00721         u_short cishort;
00722         u32_t cilong;
00723         <a class="code" href="structipcp__options.html">ipcp_options</a> <span class="keywordflow">try</span>;               <span class="comment">/* options to request next time */</span>
00724         
00725         <span class="keywordflow">try</span> = *go;
00726         <span class="comment">/*</span>
00727 <span class="comment">         * Any Rejected CIs must be in exactly the same order that we sent.</span>
00728 <span class="comment">         * Check packet length and CI length at each step.</span>
00729 <span class="comment">         * If we find any deviations, then this packet is bad.</span>
00730 <span class="comment">         */</span>
00731 <span class="preprocessor">#define REJCIADDR(opt, neg, old, val1, val2) \</span>
00732 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
00733 <span class="preprocessor">                        len &gt;= (cilen = old? CILEN_ADDRS: CILEN_ADDR) &amp;&amp; \</span>
00734 <span class="preprocessor">                        p[1] == cilen &amp;&amp; \</span>
00735 <span class="preprocessor">                        p[0] == opt) { \</span>
00736 <span class="preprocessor">                u32_t l; \</span>
00737 <span class="preprocessor">                len -= cilen; \</span>
00738 <span class="preprocessor">                INCPTR(2, p); \</span>
00739 <span class="preprocessor">                GETLONG(l, p); \</span>
00740 <span class="preprocessor">                cilong = htonl(l); \</span>
00741 <span class="preprocessor">                </span><span class="comment">/* Check rejected value. */</span> \
00742                 if (cilong != val1) \
00743                         goto bad; \
00744                 if (old) { \
00745                         GETLONG(l, p); \
00746                         cilong = htonl(l); \
00747                         <span class="comment">/* Check rejected value. */</span> \
00748                         if (cilong != val2) \
00749                                 goto bad; \
00750                 } \
00751                 try.neg = 0; \
00752         }
00753         
00754 <span class="preprocessor">#define REJCIVJ(opt, neg, val, old, maxslot, cflag) \</span>
00755 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
00756 <span class="preprocessor">                        p[1] == (old? CILEN_COMPRESS : CILEN_VJ) &amp;&amp; \</span>
00757 <span class="preprocessor">                        len &gt;= p[1] &amp;&amp; \</span>
00758 <span class="preprocessor">                        p[0] == opt) { \</span>
00759 <span class="preprocessor">                len -= p[1]; \</span>
00760 <span class="preprocessor">                INCPTR(2, p); \</span>
00761 <span class="preprocessor">                GETSHORT(cishort, p); \</span>
00762 <span class="preprocessor">                </span><span class="comment">/* Check rejected value. */</span>  \
00763                 if (cishort != val) \
00764                         goto bad; \
00765                 if (!old) { \
00766                         GETCHAR(cimaxslotindex, p); \
00767                         if (cimaxslotindex != maxslot) \
00768                                 goto bad; \
00769                         GETCHAR(ciflag, p); \
00770                         if (ciflag != cflag) \
00771                                 goto bad; \
00772                 } \
00773                 try.neg = 0; \
00774         }
00775         
00776 <span class="preprocessor">#define REJCIDNS(opt, neg, dnsaddr) \</span>
00777 <span class="preprocessor">        if (go-&gt;neg &amp;&amp; \</span>
00778 <span class="preprocessor">                        ((cilen = p[1]) == CILEN_ADDR) &amp;&amp; \</span>
00779 <span class="preprocessor">                        len &gt;= cilen &amp;&amp; \</span>
00780 <span class="preprocessor">                        p[0] == opt) { \</span>
00781 <span class="preprocessor">                u32_t l; \</span>
00782 <span class="preprocessor">                len -= cilen; \</span>
00783 <span class="preprocessor">                INCPTR(2, p); \</span>
00784 <span class="preprocessor">                GETLONG(l, p); \</span>
00785 <span class="preprocessor">                cilong = htonl(l); \</span>
00786 <span class="preprocessor">                </span><span class="comment">/* Check rejected value. */</span> \
00787                 if (cilong != dnsaddr) \
00788                         goto bad; \
00789                 try.neg = 0; \
00790         }
00791 
00792         REJCIADDR((go-&gt;<a class="code" href="structipcp__options.html#o1">old_addrs</a>? CI_ADDRS: CI_ADDR), neg_addr,
00793                           go-&gt;<a class="code" href="structipcp__options.html#o1">old_addrs</a>, go-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a>, go-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>);
00794         
00795         REJCIVJ(CI_COMPRESSTYPE, neg_vj, go-&gt;<a class="code" href="structipcp__options.html#o11">vj_protocol</a>, go-&gt;<a class="code" href="structipcp__options.html#o6">old_vj</a>,
00796                         go-&gt;<a class="code" href="structipcp__options.html#o12">maxslotindex</a>, go-&gt;<a class="code" href="structipcp__options.html#o13">cflag</a>);
00797         
00798         REJCIDNS(CI_MS_DNS1, req_dns1, go-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[0]);
00799 
00800         REJCIDNS(CI_MS_DNS2, req_dns2, go-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[1]);
00801 
00802         <span class="comment">/*</span>
00803 <span class="comment">         * If there are any remaining CIs, then this packet is bad.</span>
00804 <span class="comment">         */</span>
00805         <span class="keywordflow">if</span> (len != 0)
00806                 <span class="keywordflow">goto</span> bad;
00807         <span class="comment">/*</span>
00808 <span class="comment">         * Now we can update state.</span>
00809 <span class="comment">         */</span>
00810         <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structfsm.html#o2">state</a> != <a class="code" href="fsm_8h.html#a17">OPENED</a>)
00811                 *go = <span class="keywordflow">try</span>;
00812         <span class="keywordflow">return</span> 1;
00813         
00814 bad:
00815         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_rejci: received bad Reject!\n"</span>));
00816         <span class="keywordflow">return</span> 0;
00817 }
00818 
00819 
00820 <span class="comment">/*</span>
00821 <span class="comment"> * ipcp_reqci - Check the peer's requested CIs and send appropriate response.</span>
00822 <span class="comment"> *</span>
00823 <span class="comment"> * Returns: CONFACK, CONFNAK or CONFREJ and input packet modified</span>
00824 <span class="comment"> * appropriately.  If reject_if_disagree is non-zero, doesn't return</span>
00825 <span class="comment"> * CONFNAK; returns CONFREJ if it can't return CONFACK.</span>
00826 <span class="comment"> */</span>
00827 <span class="keyword">static</span> <span class="keywordtype">int</span> ipcp_reqci(
00828         <a class="code" href="structfsm.html">fsm</a> *f,
00829         u_char *inp,            <span class="comment">/* Requested CIs */</span>
00830         <span class="keywordtype">int</span> *len,                       <span class="comment">/* Length of requested CIs */</span>
00831         <span class="keywordtype">int</span> reject_if_disagree
00832 )
00833 {
00834         <a class="code" href="structipcp__options.html">ipcp_options</a> *wo = &amp;<a class="code" href="ipcp_8h.html#a14">ipcp_wantoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00835         <a class="code" href="structipcp__options.html">ipcp_options</a> *ho = &amp;<a class="code" href="ipcp_8h.html#a17">ipcp_hisoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00836         <a class="code" href="structipcp__options.html">ipcp_options</a> *ao = &amp;<a class="code" href="ipcp_8h.html#a16">ipcp_allowoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00837 <span class="preprocessor">#ifdef OLD_CI_ADDRS</span>
00838 <span class="preprocessor"></span>        <a class="code" href="structipcp__options.html">ipcp_options</a> *go = &amp;<a class="code" href="ipcp_8h.html#a15">ipcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
00839 <span class="preprocessor">#endif</span>
00840 <span class="preprocessor"></span>        u_char *cip, *next;                             <span class="comment">/* Pointer to current and next CIs */</span>
00841         u_short cilen, citype;                  <span class="comment">/* Parsed len, type */</span>
00842         u_short cishort;                                <span class="comment">/* Parsed short value */</span>
00843         u32_t tl, ciaddr1;                      <span class="comment">/* Parsed address values */</span>
00844 <span class="preprocessor">#ifdef OLD_CI_ADDRS</span>
00845 <span class="preprocessor"></span>        u32_t ciaddr2;                          <span class="comment">/* Parsed address values */</span>
00846 <span class="preprocessor">#endif</span>
00847 <span class="preprocessor"></span>        <span class="keywordtype">int</span> rc = <a class="code" href="fsm_8h.html#a2">CONFACK</a>;                               <span class="comment">/* Final packet return code */</span>
00848         <span class="keywordtype">int</span> orc;                                                <span class="comment">/* Individual option return code */</span>
00849         u_char *p;                                              <span class="comment">/* Pointer to next char to parse */</span>
00850         u_char *ucp = inp;                              <span class="comment">/* Pointer to current output char */</span>
00851         <span class="keywordtype">int</span> l = *len;                                   <span class="comment">/* Length left */</span>
00852         u_char maxslotindex, cflag;
00853         <span class="keywordtype">int</span> d;
00854         
00855         cis_received[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>] = 1;
00856         
00857         <span class="comment">/*</span>
00858 <span class="comment">         * Reset all his options.</span>
00859 <span class="comment">         */</span>
00860         BZERO(ho, <span class="keyword">sizeof</span>(*ho));
00861         
00862         <span class="comment">/*</span>
00863 <span class="comment">         * Process all his options.</span>
00864 <span class="comment">         */</span>
00865         next = inp;
00866         <span class="keywordflow">while</span> (l) {
00867                 orc = <a class="code" href="fsm_8h.html#a2">CONFACK</a>;                          <span class="comment">/* Assume success */</span>
00868                 cip = p = next;                         <span class="comment">/* Remember begining of CI */</span>
00869                 <span class="keywordflow">if</span> (l &lt; 2 ||                            <span class="comment">/* Not enough data for CI header or */</span>
00870                                 p[1] &lt; 2 ||                     <span class="comment">/*  CI length too small or */</span>
00871                                 p[1] &gt; l) {                     <span class="comment">/*  CI length too big? */</span>
00872                         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: bad CI length!\n"</span>));
00873                         orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;                  <span class="comment">/* Reject bad CI */</span>
00874                         cilen = l;                              <span class="comment">/* Reject till end of packet */</span>
00875                         l = 0;                                  <span class="comment">/* Don't loop again */</span>
00876                         <span class="keywordflow">goto</span> endswitch;
00877                 }
00878                 GETCHAR(citype, p);                     <span class="comment">/* Parse CI type */</span>
00879                 GETCHAR(cilen, p);                      <span class="comment">/* Parse CI length */</span>
00880                 l -= cilen;                                     <span class="comment">/* Adjust remaining length */</span>
00881                 next += cilen;                          <span class="comment">/* Step to next CI */</span>
00882 
00883                 <span class="keywordflow">switch</span> (citype) {                       <span class="comment">/* Check CI type */</span>
00884 <span class="preprocessor">#ifdef OLD_CI_ADDRS </span><span class="comment">/* Need to save space... */</span>
00885                 <span class="keywordflow">case</span> <a class="code" href="ipcp_8h.html#a0">CI_ADDRS</a>:
00886                         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: received ADDRS\n"</span>));
00887                         <span class="keywordflow">if</span> (!ao-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a> ||
00888                                         cilen != CILEN_ADDRS) { <span class="comment">/* Check CI length */</span>
00889                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;          <span class="comment">/* Reject CI */</span>
00890                                 <span class="keywordflow">break</span>;
00891                         }
00892                         
00893                         <span class="comment">/*</span>
00894 <span class="comment">                         * If he has no address, or if we both have his address but</span>
00895 <span class="comment">                         * disagree about it, then NAK it with our idea.</span>
00896 <span class="comment">                         * In particular, if we don't know his address, but he does,</span>
00897 <span class="comment">                         * then accept it.</span>
00898 <span class="comment">                         */</span>
00899                         GETLONG(tl, p);         <span class="comment">/* Parse source address (his) */</span>
00900                         ciaddr1 = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(tl);
00901                         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"his addr %s\n"</span>, <a class="code" href="inet_8c.html#a6">inet_ntoa</a>(ciaddr1)));
00902                         <span class="keywordflow">if</span> (ciaddr1 != wo-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>
00903                                         &amp;&amp; (ciaddr1 == 0 || !wo-&gt;<a class="code" href="structipcp__options.html#o8">accept_remote</a>)) {
00904                                 orc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;
00905                                 <span class="keywordflow">if</span> (!reject_if_disagree) {
00906                                         DECPTR(<span class="keyword">sizeof</span>(u32_t), p);
00907                                         tl = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(wo-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>);
00908                                         PUTLONG(tl, p);
00909                                 }
00910                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ciaddr1 == 0 &amp;&amp; wo-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a> == 0) {
00911                                 <span class="comment">/*</span>
00912 <span class="comment">                                 * If neither we nor he knows his address, reject the option.</span>
00913 <span class="comment">                                 */</span>
00914                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
00915                                 wo-&gt;<a class="code" href="structipcp__options.html#o2">req_addr</a> = 0;       <span class="comment">/* don't NAK with 0.0.0.0 later */</span>
00916                                 <span class="keywordflow">break</span>;
00917                         }
00918                         
00919                         <span class="comment">/*</span>
00920 <span class="comment">                         * If he doesn't know our address, or if we both have our address</span>
00921 <span class="comment">                         * but disagree about it, then NAK it with our idea.</span>
00922 <span class="comment">                         */</span>
00923                         GETLONG(tl, p);         <span class="comment">/* Parse desination address (ours) */</span>
00924                         ciaddr2 = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(tl);
00925                         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"our addr %s\n"</span>, <a class="code" href="inet_8c.html#a6">inet_ntoa</a>(ciaddr2)));
00926                         <span class="keywordflow">if</span> (ciaddr2 != wo-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a>) {
00927                                 <span class="keywordflow">if</span> (ciaddr2 == 0 || !wo-&gt;<a class="code" href="structipcp__options.html#o7">accept_local</a>) {
00928                                         orc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;
00929                                         <span class="keywordflow">if</span> (!reject_if_disagree) {
00930                                                 DECPTR(<span class="keyword">sizeof</span>(u32_t), p);
00931                                                 tl = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(wo-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a>);
00932                                                 PUTLONG(tl, p);
00933                                         }
00934                                 } <span class="keywordflow">else</span> {
00935                                         go-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a> = ciaddr2;  <span class="comment">/* accept peer's idea */</span>
00936                                 }
00937                         }
00938                         
00939                         ho-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a> = 1;
00940                         ho-&gt;<a class="code" href="structipcp__options.html#o1">old_addrs</a> = 1;
00941                         ho-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a> = ciaddr1;
00942                         ho-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a> = ciaddr2;
00943                         <span class="keywordflow">break</span>;
00944 <span class="preprocessor">#endif</span>
00945 <span class="preprocessor"></span>                
00946                 <span class="keywordflow">case</span> <a class="code" href="ipcp_8h.html#a2">CI_ADDR</a>:
00947                         <span class="keywordflow">if</span> (!ao-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a>) {
00948                                 <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: Reject ADDR not allowed\n"</span>));
00949                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;                          <span class="comment">/* Reject CI */</span>
00950                                 <span class="keywordflow">break</span>;
00951                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cilen != CILEN_ADDR) {       <span class="comment">/* Check CI length */</span>
00952                                 <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: Reject ADDR bad len\n"</span>));
00953                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;                          <span class="comment">/* Reject CI */</span>
00954                                 <span class="keywordflow">break</span>;
00955                         }
00956                         
00957                         <span class="comment">/*</span>
00958 <span class="comment">                         * If he has no address, or if we both have his address but</span>
00959 <span class="comment">                         * disagree about it, then NAK it with our idea.</span>
00960 <span class="comment">                         * In particular, if we don't know his address, but he does,</span>
00961 <span class="comment">                         * then accept it.</span>
00962 <span class="comment">                         */</span>
00963                         GETLONG(tl, p); <span class="comment">/* Parse source address (his) */</span>
00964                         ciaddr1 = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(tl);
00965                         <span class="keywordflow">if</span> (ciaddr1 != wo-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>
00966                                         &amp;&amp; (ciaddr1 == 0 || !wo-&gt;<a class="code" href="structipcp__options.html#o8">accept_remote</a>)) {
00967                                 orc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;
00968                                 <span class="keywordflow">if</span> (!reject_if_disagree) {
00969                                         DECPTR(<span class="keyword">sizeof</span>(u32_t), p);
00970                                         tl = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(wo-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>);
00971                                         PUTLONG(tl, p);
00972                                 }
00973                                 <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: Nak ADDR %s\n"</span>, <a class="code" href="inet_8c.html#a6">inet_ntoa</a>(ciaddr1)));
00974                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ciaddr1 == 0 &amp;&amp; wo-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a> == 0) {
00975                                 <span class="comment">/*</span>
00976 <span class="comment">                                 * Don't ACK an address of 0.0.0.0 - reject it instead.</span>
00977 <span class="comment">                                 */</span>
00978                                 <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: Reject ADDR %s\n"</span>, <a class="code" href="inet_8c.html#a6">inet_ntoa</a>(ciaddr1)));
00979                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
00980                                 wo-&gt;<a class="code" href="structipcp__options.html#o2">req_addr</a> = 0;       <span class="comment">/* don't NAK with 0.0.0.0 later */</span>
00981                                 <span class="keywordflow">break</span>;
00982                         }
00983                         
00984                         ho-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a> = 1;
00985                         ho-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a> = ciaddr1;
00986                         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: ADDR %s\n"</span>, <a class="code" href="inet_8c.html#a6">inet_ntoa</a>(ciaddr1)));
00987                         <span class="keywordflow">break</span>;
00988                 
00989                 <span class="keywordflow">case</span> <a class="code" href="ipcp_8h.html#a4">CI_MS_DNS1</a>:
00990                 <span class="keywordflow">case</span> <a class="code" href="ipcp_8h.html#a6">CI_MS_DNS2</a>:
00991                         <span class="comment">/* Microsoft primary or secondary DNS request */</span>
00992                         d = citype == <a class="code" href="ipcp_8h.html#a6">CI_MS_DNS2</a>;
00993                         
00994                         <span class="comment">/* If we do not have a DNS address then we cannot send it */</span>
00995                         <span class="keywordflow">if</span> (ao-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[d] == 0 ||
00996                                         cilen != CILEN_ADDR) {  <span class="comment">/* Check CI length */</span>
00997                                 <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: Rejecting DNS%d Request\n"</span>, d+1));
00998                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;                          <span class="comment">/* Reject CI */</span>
00999                                 <span class="keywordflow">break</span>;
01000                         }
01001                         GETLONG(tl, p);
01002                         <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(tl) != ao-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[d]) {
01003                                 <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: Naking DNS%d Request %d\n"</span>,
01004                                                         d+1, <a class="code" href="inet_8c.html#a6">inet_ntoa</a>(tl)));
01005                                 DECPTR(<span class="keyword">sizeof</span>(u32_t), p);
01006                                 tl = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(ao-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[d]);
01007                                 PUTLONG(tl, p);
01008                                 orc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;
01009                         }
01010                         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: received DNS%d Request\n"</span>, d+1));
01011                         <span class="keywordflow">break</span>;
01012                 
01013                 <span class="keywordflow">case</span> <a class="code" href="ipcp_8h.html#a3">CI_MS_WINS1</a>:
01014                 <span class="keywordflow">case</span> <a class="code" href="ipcp_8h.html#a5">CI_MS_WINS2</a>:
01015                         <span class="comment">/* Microsoft primary or secondary WINS request */</span>
01016                         d = citype == <a class="code" href="ipcp_8h.html#a5">CI_MS_WINS2</a>;
01017                         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: received WINS%d Request\n"</span>, d+1));
01018                         
01019                         <span class="comment">/* If we do not have a DNS address then we cannot send it */</span>
01020                         <span class="keywordflow">if</span> (ao-&gt;<a class="code" href="structipcp__options.html#o17">winsaddr</a>[d] == 0 ||
01021                                 cilen != CILEN_ADDR) {  <span class="comment">/* Check CI length */</span>
01022                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;                  <span class="comment">/* Reject CI */</span>
01023                                 <span class="keywordflow">break</span>;
01024                         }
01025                         GETLONG(tl, p);
01026                         <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(tl) != ao-&gt;<a class="code" href="structipcp__options.html#o17">winsaddr</a>[d]) {
01027                                 DECPTR(<span class="keyword">sizeof</span>(u32_t), p);
01028                                 tl = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(ao-&gt;<a class="code" href="structipcp__options.html#o17">winsaddr</a>[d]);
01029                                 PUTLONG(tl, p);
01030                                 orc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;
01031                         }
01032                         <span class="keywordflow">break</span>;
01033                 
01034                 <span class="keywordflow">case</span> <a class="code" href="ipcp_8h.html#a1">CI_COMPRESSTYPE</a>:
01035                         <span class="keywordflow">if</span> (!ao-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a>) {
01036                                 <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: Rejecting COMPRESSTYPE not allowed\n"</span>));
01037                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01038                                 <span class="keywordflow">break</span>;
01039                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cilen != CILEN_VJ &amp;&amp; cilen != CILEN_COMPRESS) {
01040                                 <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: Rejecting COMPRESSTYPE len=%d\n"</span>, cilen));
01041                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01042                                 <span class="keywordflow">break</span>;
01043                         }
01044                         GETSHORT(cishort, p);
01045                         
01046                         <span class="keywordflow">if</span> (!(cishort == <a class="code" href="ipcp_8h.html#a10">IPCP_VJ_COMP</a> ||
01047                                         (cishort == <a class="code" href="ipcp_8h.html#a11">IPCP_VJ_COMP_OLD</a> &amp;&amp; cilen == CILEN_COMPRESS))) {
01048                                 <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: Rejecting COMPRESSTYPE %d\n"</span>, cishort));
01049                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01050                                 <span class="keywordflow">break</span>;
01051                         }
01052                         
01053                         ho-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a> = 1;
01054                         ho-&gt;<a class="code" href="structipcp__options.html#o11">vj_protocol</a> = cishort;
01055                         <span class="keywordflow">if</span> (cilen == CILEN_VJ) {
01056                                 GETCHAR(maxslotindex, p);
01057                                 <span class="keywordflow">if</span> (maxslotindex &gt; ao-&gt;<a class="code" href="structipcp__options.html#o12">maxslotindex</a>) { 
01058                                         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: Naking VJ max slot %d\n"</span>, maxslotindex));
01059                                         orc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;
01060                                         <span class="keywordflow">if</span> (!reject_if_disagree){
01061                                                 DECPTR(1, p);
01062                                                 PUTCHAR(ao-&gt;<a class="code" href="structipcp__options.html#o12">maxslotindex</a>, p);
01063                                         }
01064                                 }
01065                                 GETCHAR(cflag, p);
01066                                 <span class="keywordflow">if</span> (cflag &amp;&amp; !ao-&gt;<a class="code" href="structipcp__options.html#o13">cflag</a>) {
01067                                         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: Naking VJ cflag %d\n"</span>, cflag));
01068                                         orc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;
01069                                         <span class="keywordflow">if</span> (!reject_if_disagree){
01070                                                 DECPTR(1, p);
01071                                                 PUTCHAR(wo-&gt;<a class="code" href="structipcp__options.html#o13">cflag</a>, p);
01072                                         }
01073                                 }
01074                                 ho-&gt;<a class="code" href="structipcp__options.html#o12">maxslotindex</a> = maxslotindex;
01075                                 ho-&gt;<a class="code" href="structipcp__options.html#o13">cflag</a> = cflag;
01076                         } <span class="keywordflow">else</span> {
01077                                 ho-&gt;<a class="code" href="structipcp__options.html#o6">old_vj</a> = 1;
01078                                 ho-&gt;<a class="code" href="structipcp__options.html#o12">maxslotindex</a> = <a class="code" href="vj_8h.html#a0">MAX_SLOTS</a> - 1;
01079                                 ho-&gt;<a class="code" href="structipcp__options.html#o13">cflag</a> = 1;
01080                         }
01081                         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, 
01082                                                 <span class="stringliteral">"ipcp_reqci: received COMPRESSTYPE p=%d old=%d maxslot=%d cflag=%d\n"</span>,
01083                                                 ho-&gt;<a class="code" href="structipcp__options.html#o11">vj_protocol</a>, ho-&gt;<a class="code" href="structipcp__options.html#o6">old_vj</a>, ho-&gt;<a class="code" href="structipcp__options.html#o12">maxslotindex</a>, ho-&gt;<a class="code" href="structipcp__options.html#o13">cflag</a>));
01084                         <span class="keywordflow">break</span>;
01085                         
01086                 <span class="keywordflow">default</span>:
01087                         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: Rejecting unknown CI type %d\n"</span>, citype));
01088                         orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01089                         <span class="keywordflow">break</span>;
01090                 }
01091                 
01092 endswitch:
01093                 <span class="keywordflow">if</span> (orc == <a class="code" href="fsm_8h.html#a2">CONFACK</a> &amp;&amp;           <span class="comment">/* Good CI */</span>
01094                                 rc != <a class="code" href="fsm_8h.html#a2">CONFACK</a>)          <span class="comment">/*  but prior CI wasnt? */</span>
01095                         <span class="keywordflow">continue</span>;                               <span class="comment">/* Don't send this one */</span>
01096                 
01097                 <span class="keywordflow">if</span> (orc == <a class="code" href="fsm_8h.html#a3">CONFNAK</a>) {           <span class="comment">/* Nak this CI? */</span>
01098                         <span class="keywordflow">if</span> (reject_if_disagree) {       <span class="comment">/* Getting fed up with sending NAKs? */</span>
01099                                 <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: Rejecting too many naks\n"</span>));
01100                                 orc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;          <span class="comment">/* Get tough if so */</span>
01101                         } <span class="keywordflow">else</span> {
01102                                 <span class="keywordflow">if</span> (rc == <a class="code" href="fsm_8h.html#a4">CONFREJ</a>)      <span class="comment">/* Rejecting prior CI? */</span>
01103                                         <span class="keywordflow">continue</span>;               <span class="comment">/* Don't send this one */</span>
01104                                 <span class="keywordflow">if</span> (rc == <a class="code" href="fsm_8h.html#a2">CONFACK</a>) {    <span class="comment">/* Ack'd all prior CIs? */</span>
01105                                         rc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;   <span class="comment">/* Not anymore... */</span>
01106                                         ucp = inp;              <span class="comment">/* Backup */</span>
01107                                 }
01108                         }
01109                 }
01110                 
01111                 <span class="keywordflow">if</span> (orc == <a class="code" href="fsm_8h.html#a4">CONFREJ</a> &amp;&amp;           <span class="comment">/* Reject this CI */</span>
01112                                 rc != <a class="code" href="fsm_8h.html#a4">CONFREJ</a>) {        <span class="comment">/*  but no prior ones? */</span>
01113                         rc = <a class="code" href="fsm_8h.html#a4">CONFREJ</a>;
01114                         ucp = inp;                              <span class="comment">/* Backup */</span>
01115                 }
01116                 
01117                 <span class="comment">/* Need to move CI? */</span>
01118                 <span class="keywordflow">if</span> (ucp != cip)
01119                         BCOPY(cip, ucp, cilen); <span class="comment">/* Move it */</span>
01120                 
01121                 <span class="comment">/* Update output pointer */</span>
01122                 INCPTR(cilen, ucp);
01123         }
01124         
01125         <span class="comment">/*</span>
01126 <span class="comment">         * If we aren't rejecting this packet, and we want to negotiate</span>
01127 <span class="comment">         * their address, and they didn't send their address, then we</span>
01128 <span class="comment">         * send a NAK with a CI_ADDR option appended.  We assume the</span>
01129 <span class="comment">         * input buffer is long enough that we can append the extra</span>
01130 <span class="comment">         * option safely.</span>
01131 <span class="comment">         */</span>
01132         <span class="keywordflow">if</span> (rc != <a class="code" href="fsm_8h.html#a4">CONFREJ</a> &amp;&amp; !ho-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a> &amp;&amp;
01133                         wo-&gt;<a class="code" href="structipcp__options.html#o2">req_addr</a> &amp;&amp; !reject_if_disagree) {
01134                 <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: Requesting peer address\n"</span>));
01135                 <span class="keywordflow">if</span> (rc == <a class="code" href="fsm_8h.html#a2">CONFACK</a>) {
01136                         rc = <a class="code" href="fsm_8h.html#a3">CONFNAK</a>;
01137                         ucp = inp;                              <span class="comment">/* reset pointer */</span>
01138                         wo-&gt;<a class="code" href="structipcp__options.html#o2">req_addr</a> = 0;               <span class="comment">/* don't ask again */</span>
01139                 }
01140                 PUTCHAR(CI_ADDR, ucp);
01141                 PUTCHAR(CILEN_ADDR, ucp);
01142                 tl = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(wo-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>);
01143                 PUTLONG(tl, ucp);
01144         }
01145         
01146         *len = (<span class="keywordtype">int</span>)(ucp - inp);                <span class="comment">/* Compute output length */</span>
01147         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp_reqci: returning Configure-%s\n"</span>, CODENAME(rc)));
01148         <span class="keywordflow">return</span> (rc);                    <span class="comment">/* Return final code */</span>
01149 }
01150 
01151 
01152 <span class="preprocessor">#if 0</span>
01153 <span class="preprocessor"></span><span class="comment">/*</span>
01154 <span class="comment"> * ip_check_options - check that any IP-related options are OK,</span>
01155 <span class="comment"> * and assign appropriate defaults.</span>
01156 <span class="comment"> */</span>
01157 <span class="keyword">static</span> <span class="keywordtype">void</span> ip_check_options(u_long localAddr)
01158 {
01159         <a class="code" href="structipcp__options.html">ipcp_options</a> *wo = &amp;<a class="code" href="ipcp_8h.html#a14">ipcp_wantoptions</a>[0];
01160 
01161         <span class="comment">/*</span>
01162 <span class="comment">         * Load our default IP address but allow the remote host to give us</span>
01163 <span class="comment">         * a new address.</span>
01164 <span class="comment">         */</span>
01165         <span class="keywordflow">if</span> (wo-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a> == 0 &amp;&amp; !ppp_settings.disable_defaultip) {
01166                 wo-&gt;<a class="code" href="structipcp__options.html#o7">accept_local</a> = 1;   <span class="comment">/* don't insist on this default value */</span>
01167                 wo-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a> = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(localAddr);
01168         }
01169 }
01170 <span class="preprocessor">#endif</span>
01171 <span class="preprocessor"></span>
01172 
01173 <span class="comment">/*</span>
01174 <span class="comment"> * ipcp_up - IPCP has come UP.</span>
01175 <span class="comment"> *</span>
01176 <span class="comment"> * Configure the IP network interface appropriately and bring it up.</span>
01177 <span class="comment"> */</span>
01178 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_up(<a class="code" href="structfsm.html">fsm</a> *f)
01179 {
01180         u32_t mask;
01181         <a class="code" href="structipcp__options.html">ipcp_options</a> *ho = &amp;<a class="code" href="ipcp_8h.html#a17">ipcp_hisoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
01182         <a class="code" href="structipcp__options.html">ipcp_options</a> *go = &amp;<a class="code" href="ipcp_8h.html#a15">ipcp_gotoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
01183         <a class="code" href="structipcp__options.html">ipcp_options</a> *wo = &amp;<a class="code" href="ipcp_8h.html#a14">ipcp_wantoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>];
01184         
01185         <a class="code" href="auth_8h.html#a4">np_up</a>(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, PPP_IP);
01186         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp: up\n"</span>));
01187         
01188         <span class="comment">/*</span>
01189 <span class="comment">         * We must have a non-zero IP address for both ends of the link.</span>
01190 <span class="comment">         */</span>
01191         <span class="keywordflow">if</span> (!ho-&gt;<a class="code" href="structipcp__options.html#o0">neg_addr</a>)
01192                 ho-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a> = wo-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>;
01193         
01194         <span class="keywordflow">if</span> (ho-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a> == 0) {
01195                 <a class="code" href="pppdebug_8h.html#a15">ppp_trace</a>(LOG_ERR, <span class="stringliteral">"Could not determine remote IP address\n"</span>);
01196                 ipcp_close(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, <span class="stringliteral">"Could not determine remote IP address"</span>);
01197                 <span class="keywordflow">return</span>;
01198         }
01199         <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a> == 0) {
01200                 <a class="code" href="pppdebug_8h.html#a15">ppp_trace</a>(LOG_ERR, <span class="stringliteral">"Could not determine local IP address\n"</span>);
01201                 ipcp_close(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, <span class="stringliteral">"Could not determine local IP address"</span>);
01202                 <span class="keywordflow">return</span>;
01203         }
01204         
01205         <span class="keywordflow">if</span> (ppp_settings.usepeerdns &amp;&amp; (go-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[0] || go-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[1])) {
01206                 <span class="comment">/*pppGotDNSAddrs(go-&gt;dnsaddr[0], go-&gt;dnsaddr[1]);*/</span>
01207         }
01208 
01209         <span class="comment">/*</span>
01210 <span class="comment">         * Check that the peer is allowed to use the IP address it wants.</span>
01211 <span class="comment">         */</span>
01212         <span class="keywordflow">if</span> (!<a class="code" href="auth_8h.html#a15">auth_ip_addr</a>(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, ho-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>)) {
01213                 <a class="code" href="pppdebug_8h.html#a15">ppp_trace</a>(LOG_ERR, <span class="stringliteral">"Peer is not authorized to use remote address %s\n"</span>,
01214                                 <a class="code" href="inet_8c.html#a6">inet_ntoa</a>(ho-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>));
01215                 ipcp_close(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, <span class="stringliteral">"Unauthorized remote IP address"</span>);
01216                 <span class="keywordflow">return</span>;
01217         }
01218         
01219         <span class="comment">/* set tcp compression */</span>
01220         sifvjcomp(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, ho-&gt;<a class="code" href="structipcp__options.html#o5">neg_vj</a>, ho-&gt;<a class="code" href="structipcp__options.html#o13">cflag</a>, ho-&gt;<a class="code" href="structipcp__options.html#o12">maxslotindex</a>);
01221         
01222         <span class="comment">/*</span>
01223 <span class="comment">         * Set IP addresses and (if specified) netmask.</span>
01224 <span class="comment">         */</span>
01225         mask = GetMask(go-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a>);
01226         
01227         <span class="keywordflow">if</span> (!sifaddr(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, go-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a>, ho-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>, mask, go-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[0], go-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[1])) {
01228                 <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"sifaddr failed\n"</span>));
01229                 ipcp_close(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, <span class="stringliteral">"Interface configuration failed"</span>);
01230                 <span class="keywordflow">return</span>;
01231         }
01232         
01233         <span class="comment">/* bring the interface up for IP */</span>
01234         <span class="keywordflow">if</span> (!sifup(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>)) {
01235                 <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"sifup failed\n"</span>));
01236                 ipcp_close(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, <span class="stringliteral">"Interface configuration failed"</span>);
01237                 <span class="keywordflow">return</span>;
01238         }
01239         
01240         sifnpmode(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, PPP_IP, NPMODE_PASS);
01241         
01242         <span class="comment">/* assign a default route through the interface if required */</span>
01243         <span class="keywordflow">if</span> (<a class="code" href="ipcp_8h.html#a14">ipcp_wantoptions</a>[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>].default_route) 
01244                 <span class="keywordflow">if</span> (sifdefaultroute(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, go-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a>, ho-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>))
01245                         default_route_set[f-&gt;<a class="code" href="structfsm.html#o0">unit</a>] = 1;
01246         
01247         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_NOTICE, <span class="stringliteral">"local  IP address %s\n"</span>, <a class="code" href="inet_8c.html#a6">inet_ntoa</a>(go-&gt;<a class="code" href="structipcp__options.html#o14">ouraddr</a>)));
01248         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_NOTICE, <span class="stringliteral">"remote IP address %s\n"</span>, <a class="code" href="inet_8c.html#a6">inet_ntoa</a>(ho-&gt;<a class="code" href="structipcp__options.html#o15">hisaddr</a>)));
01249         <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[0]) {
01250                 <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_NOTICE, <span class="stringliteral">"primary   DNS address %s\n"</span>, <a class="code" href="inet_8c.html#a6">inet_ntoa</a>(go-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[0])));
01251         }
01252         <span class="keywordflow">if</span> (go-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[1]) {
01253                 <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_NOTICE, <span class="stringliteral">"secondary DNS address %s\n"</span>, <a class="code" href="inet_8c.html#a6">inet_ntoa</a>(go-&gt;<a class="code" href="structipcp__options.html#o16">dnsaddr</a>[1])));
01254         }
01255 }
01256 
01257 
01258 <span class="comment">/*</span>
01259 <span class="comment"> * ipcp_down - IPCP has gone DOWN.</span>
01260 <span class="comment"> *</span>
01261 <span class="comment"> * Take the IP network interface down, clear its addresses</span>
01262 <span class="comment"> * and delete routes through it.</span>
01263 <span class="comment"> */</span>
01264 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_down(<a class="code" href="structfsm.html">fsm</a> *f)
01265 {
01266         <a class="code" href="pppdebug_8h.html#a1">IPCPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ipcp: down\n"</span>));
01267         <a class="code" href="auth_8h.html#a5">np_down</a>(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, PPP_IP);
01268         sifvjcomp(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, 0, 0, 0);
01269         
01270         sifdown(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>);
01271         ipcp_clear_addrs(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>);
01272 }
01273 
01274 
01275 <span class="comment">/*</span>
01276 <span class="comment"> * ipcp_clear_addrs() - clear the interface addresses, routes, etc.</span>
01277 <span class="comment"> */</span>
01278 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_clear_addrs(<span class="keywordtype">int</span> unit)
01279 {
01280         u32_t ouraddr, hisaddr;
01281         
01282         ouraddr = <a class="code" href="ipcp_8h.html#a15">ipcp_gotoptions</a>[unit].<a class="code" href="structipcp__options.html#o14">ouraddr</a>;
01283         hisaddr = <a class="code" href="ipcp_8h.html#a17">ipcp_hisoptions</a>[unit].<a class="code" href="structipcp__options.html#o15">hisaddr</a>;
01284         <span class="keywordflow">if</span> (default_route_set[unit]) {
01285                 cifdefaultroute(unit, ouraddr, hisaddr);
01286                 default_route_set[unit] = 0;
01287         }
01288         cifaddr(unit, ouraddr, hisaddr);
01289 }
01290 
01291 
01292 <span class="comment">/*</span>
01293 <span class="comment"> * ipcp_finished - possibly shut down the lower layers.</span>
01294 <span class="comment"> */</span>
01295 <span class="keyword">static</span> <span class="keywordtype">void</span> ipcp_finished(<a class="code" href="structfsm.html">fsm</a> *f)
01296 {
01297         <a class="code" href="auth_8h.html#a6">np_finished</a>(f-&gt;<a class="code" href="structfsm.html#o0">unit</a>, PPP_IP);
01298 }
01299 
01300 <span class="preprocessor">#if 0</span>
01301 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ipcp_printpkt(
01302         u_char *p,
01303         <span class="keywordtype">int</span> plen,
01304         <span class="keywordtype">void</span> (*printer) (<span class="keywordtype">void</span> *, <span class="keywordtype">char</span> *, ...),
01305         <span class="keywordtype">void</span> *arg
01306 )
01307 {
01308         (<span class="keywordtype">void</span>)p;
01309         (<span class="keywordtype">void</span>)plen;
01310         (<span class="keywordtype">void</span>)printer;
01311         (<span class="keywordtype">void</span>)arg;
01312         <span class="keywordflow">return</span> 0;
01313 }
01314 
01315 <span class="comment">/*</span>
01316 <span class="comment"> * ip_active_pkt - see if this IP packet is worth bringing the link up for.</span>
01317 <span class="comment"> * We don't bring the link up for IP fragments or for TCP FIN packets</span>
01318 <span class="comment"> * with no data.</span>
01319 <span class="comment"> */</span>
01320 <span class="preprocessor">#define IP_HDRLEN       20      </span><span class="comment">/* bytes */</span>
01321 <span class="preprocessor">#define IP_OFFMASK      0x1fff</span>
01322 <span class="preprocessor"></span><span class="preprocessor">#define IPPROTO_TCP     6</span>
01323 <span class="preprocessor"></span><span class="preprocessor">#define TCP_HDRLEN      20</span>
01324 <span class="preprocessor"></span><span class="preprocessor">#define TH_FIN          0x01</span>
01325 <span class="preprocessor"></span>
01326 <span class="comment">/*</span>
01327 <span class="comment"> * We use these macros because the IP header may be at an odd address,</span>
01328 <span class="comment"> * and some compilers might use word loads to get th_off or ip_hl.</span>
01329 <span class="comment"> */</span>
01330 
01331 <span class="preprocessor">#define net_short(x)    (((x)[0] &lt;&lt; 8) + (x)[1])</span>
01332 <span class="preprocessor"></span><span class="preprocessor">#define get_iphl(x)     (((unsigned char *)(x))[0] &amp; 0xF)</span>
01333 <span class="preprocessor"></span><span class="preprocessor">#define get_ipoff(x)    net_short((unsigned char *)(x) + 6)</span>
01334 <span class="preprocessor"></span><span class="preprocessor">#define get_ipproto(x)  (((unsigned char *)(x))[9])</span>
01335 <span class="preprocessor"></span><span class="preprocessor">#define get_tcpoff(x)   (((unsigned char *)(x))[12] &gt;&gt; 4)</span>
01336 <span class="preprocessor"></span><span class="preprocessor">#define get_tcpflags(x) (((unsigned char *)(x))[13])</span>
01337 <span class="preprocessor"></span>
01338 <span class="keyword">static</span> <span class="keywordtype">int</span> ip_active_pkt(u_char *pkt, <span class="keywordtype">int</span> len)
01339 {
01340         u_char *tcp;
01341         <span class="keywordtype">int</span> hlen;
01342         
01343         len -= PPP_HDRLEN;
01344         pkt += PPP_HDRLEN;
01345         <span class="keywordflow">if</span> (len &lt; IP_HDRLEN)
01346                 <span class="keywordflow">return</span> 0;
01347         <span class="keywordflow">if</span> ((get_ipoff(pkt) &amp; <a class="code" href="ipv4_2lwip_2ip_8h.html#a9">IP_OFFMASK</a>) != 0)
01348                 <span class="keywordflow">return</span> 0;
01349         <span class="keywordflow">if</span> (get_ipproto(pkt) != <a class="code" href="sockets_8h.html#a28">IPPROTO_TCP</a>)
01350                 <span class="keywordflow">return</span> 1;
01351         hlen = get_iphl(pkt) * 4;
01352         <span class="keywordflow">if</span> (len &lt; hlen + TCP_HDRLEN)
01353                 <span class="keywordflow">return</span> 0;
01354         tcp = pkt + hlen;
01355         <span class="keywordflow">if</span> ((get_tcpflags(tcp) &amp; TH_FIN) != 0 &amp;&amp; len == hlen + get_tcpoff(tcp) * 4)
01356                 <span class="keywordflow">return</span> 0;
01357         <span class="keywordflow">return</span> 1;
01358 }
01359 <span class="preprocessor">#endif</span>
01360 <span class="preprocessor"></span>
01361 <span class="preprocessor">#endif </span><span class="comment">/* PPP_SUPPORT */</span>
</pre></div>	</td>
  </tr>
</table>
<hr>
<div align="center">Copyright (c) 2001-2003 Swedish Institute of Computer Science</div>
</html>
