
<html>
<head>
<title>lwIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="doxygen.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<table width="98%" border="0" align="center">
  <tr>
    <td>
      <h2>lwIP code documentation</h2>
<hr>

<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>sys.c</h1><a href="sys_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2001-2003 Swedish Institute of Computer Science.</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without modification,</span>
00006 <span class="comment"> * are permitted provided that the following conditions are met:</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span>
00009 <span class="comment"> *    this list of conditions and the following disclaimer.</span>
00010 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
00011 <span class="comment"> *    this list of conditions and the following disclaimer in the documentation</span>
00012 <span class="comment"> *    and/or other materials provided with the distribution.</span>
00013 <span class="comment"> * 3. The name of the author may not be used to endorse or promote products</span>
00014 <span class="comment"> *    derived from this software without specific prior written permission.</span>
00015 <span class="comment"> *</span>
00016 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED</span>
00017 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
00018 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT</span>
00019 <span class="comment"> * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
00020 <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT</span>
00021 <span class="comment"> * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
00022 <span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
00023 <span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
00024 <span class="comment"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY</span>
00025 <span class="comment"> * OF SUCH DAMAGE.</span>
00026 <span class="comment"> *</span>
00027 <span class="comment"> * This file is part of the lwIP TCP/IP stack.</span>
00028 <span class="comment"> *</span>
00029 <span class="comment"> * Author: Adam Dunkels &lt;adam@sics.se&gt;</span>
00030 <span class="comment"> *</span>
00031 <span class="comment"> */</span>
00032 
00033 <span class="preprocessor">#include "<a class="code" href="sys_8h.html">lwip/sys.h</a>"</span>
00034 <span class="preprocessor">#include "<a class="code" href="opt_8h.html">lwip/opt.h</a>"</span>
00035 <span class="preprocessor">#include "<a class="code" href="def_8h.html">lwip/def.h</a>"</span>
00036 <span class="preprocessor">#include "<a class="code" href="memp_8h.html">lwip/memp.h</a>"</span>
00037 
00038 <span class="preprocessor">#if (NO_SYS == 0)</span>
00039 <span class="preprocessor"></span>
<a name="l00040"></a><a class="code" href="structsswt__cb.html">00040</a> <span class="keyword">struct </span><a class="code" href="structsswt__cb.html">sswt_cb</a>
00041 {
<a name="l00042"></a><a class="code" href="structsswt__cb.html#o0">00042</a>     <span class="keywordtype">int</span> <a class="code" href="structsswt__cb.html#o0">timeflag</a>;
<a name="l00043"></a><a class="code" href="structsswt__cb.html#o1">00043</a>     sys_sem_t *<a class="code" href="structsswt__cb.html#o1">psem</a>;
00044 };
00045 
00046 
00047 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00048 <span class="keywordtype">void</span>
<a name="l00049"></a><a class="code" href="sys_8c.html#a0">00049</a> <a class="code" href="sys_8c.html#a0">sys_mbox_fetch</a>(sys_mbox_t mbox, <span class="keywordtype">void</span> **msg)
00050 {
00051   u32_t time;
00052   <span class="keyword">struct </span><a class="code" href="structsys__timeouts.html">sys_timeouts</a> *timeouts;
00053   <span class="keyword">struct </span><a class="code" href="structsys__timeout.html">sys_timeout</a> *tmptimeout;
00054   <a class="code" href="sys_8h.html#a4">sys_timeout_handler</a> h;
00055   <span class="keywordtype">void</span> *arg;
00056 
00057 
00058  again:
00059   timeouts = <a class="code" href="sys_8h.html#a8">sys_arch_timeouts</a>();
00060 
00061   <span class="keywordflow">if</span> (!timeouts || !timeouts-&gt;next) {
00062     <a class="code" href="sys_8h.html#a19">sys_arch_mbox_fetch</a>(mbox, msg, 0);
00063   } <span class="keywordflow">else</span> {
00064     <span class="keywordflow">if</span> (timeouts-&gt;next-&gt;time &gt; 0) {
00065       time = <a class="code" href="sys_8h.html#a19">sys_arch_mbox_fetch</a>(mbox, msg, timeouts-&gt;next-&gt;time);
00066     } <span class="keywordflow">else</span> {
00067       time = <a class="code" href="sys_8h.html#a0">SYS_ARCH_TIMEOUT</a>;
00068     }
00069 
00070     <span class="keywordflow">if</span> (time == <a class="code" href="sys_8h.html#a0">SYS_ARCH_TIMEOUT</a>) {
00071       <span class="comment">/* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message</span>
00072 <span class="comment">   could be fetched. We should now call the timeout handler and</span>
00073 <span class="comment">   deallocate the memory allocated for the timeout. */</span>
00074       tmptimeout = timeouts-&gt;next;
00075       timeouts-&gt;next = tmptimeout-&gt;next;
00076       h = tmptimeout-&gt;h;
00077       arg = tmptimeout-&gt;arg;
00078       <a class="code" href="memp_8c.html#a8">memp_free</a>(<a class="code" href="memp_8h.html#a17a9">MEMP_SYS_TIMEOUT</a>, tmptimeout);
00079       <span class="keywordflow">if</span> (h != <a class="code" href="def_8h.html#a2">NULL</a>) {
00080         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a72">SYS_DEBUG</a>, (<span class="stringliteral">"smf calling h=%p(%p)\n"</span>, (<span class="keywordtype">void</span> *)h, (<span class="keywordtype">void</span> *)arg));
00081         h(arg);
00082       }
00083 
00084       <span class="comment">/* We try again to fetch a message from the mbox. */</span>
00085       <span class="keywordflow">goto</span> again;
00086     } <span class="keywordflow">else</span> {
00087       <span class="comment">/* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout</span>
00088 <span class="comment">   occured. The time variable is set to the number of</span>
00089 <span class="comment">   milliseconds we waited for the message. */</span>
00090       <span class="keywordflow">if</span> (time &lt;= timeouts-&gt;next-&gt;time) {
00091   timeouts-&gt;next-&gt;time -= time;
00092       } <span class="keywordflow">else</span> {
00093   timeouts-&gt;next-&gt;time = 0;
00094       }
00095     }
00096 
00097   }
00098 }
00099 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00100 <span class="keywordtype">void</span>
<a name="l00101"></a><a class="code" href="sys_8c.html#a1">00101</a> <a class="code" href="sys_8c.html#a1">sys_sem_wait</a>(sys_sem_t sem)
00102 {
00103   u32_t time;
00104   <span class="keyword">struct </span><a class="code" href="structsys__timeouts.html">sys_timeouts</a> *timeouts;
00105   <span class="keyword">struct </span><a class="code" href="structsys__timeout.html">sys_timeout</a> *tmptimeout;
00106   <a class="code" href="sys_8h.html#a4">sys_timeout_handler</a> h;
00107   <span class="keywordtype">void</span> *arg;
00108 
00109   <span class="comment">/*  while (sys_arch_sem_wait(sem, 1000) == 0);</span>
00110 <span class="comment">      return;*/</span>
00111 
00112  again:
00113 
00114   timeouts = <a class="code" href="sys_8h.html#a8">sys_arch_timeouts</a>();
00115 
00116   <span class="keywordflow">if</span> (!timeouts || !timeouts-&gt;next) {
00117     <a class="code" href="sys_8h.html#a11">sys_arch_sem_wait</a>(sem, 0);
00118   } <span class="keywordflow">else</span> {
00119     <span class="keywordflow">if</span> (timeouts-&gt;next-&gt;time &gt; 0) {
00120       time = <a class="code" href="sys_8h.html#a11">sys_arch_sem_wait</a>(sem, timeouts-&gt;next-&gt;time);
00121     } <span class="keywordflow">else</span> {
00122       time = <a class="code" href="sys_8h.html#a0">SYS_ARCH_TIMEOUT</a>;
00123     }
00124 
00125     <span class="keywordflow">if</span> (time == <a class="code" href="sys_8h.html#a0">SYS_ARCH_TIMEOUT</a>) {
00126       <span class="comment">/* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message</span>
00127 <span class="comment">   could be fetched. We should now call the timeout handler and</span>
00128 <span class="comment">   deallocate the memory allocated for the timeout. */</span>
00129       tmptimeout = timeouts-&gt;next;
00130       timeouts-&gt;next = tmptimeout-&gt;next;
00131       h = tmptimeout-&gt;h;
00132       arg = tmptimeout-&gt;arg;
00133       <a class="code" href="memp_8c.html#a8">memp_free</a>(<a class="code" href="memp_8h.html#a17a9">MEMP_SYS_TIMEOUT</a>, tmptimeout);
00134       <span class="keywordflow">if</span> (h != <a class="code" href="def_8h.html#a2">NULL</a>) {
00135         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a72">SYS_DEBUG</a>, (<span class="stringliteral">"ssw h=%p(%p)\n"</span>, (<span class="keywordtype">void</span> *)h, (<span class="keywordtype">void</span> *)arg));
00136         h(arg);
00137       }
00138 
00139 
00140       <span class="comment">/* We try again to fetch a message from the mbox. */</span>
00141       <span class="keywordflow">goto</span> again;
00142     } <span class="keywordflow">else</span> {
00143       <span class="comment">/* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout</span>
00144 <span class="comment">   occured. The time variable is set to the number of</span>
00145 <span class="comment">   milliseconds we waited for the message. */</span>
00146       <span class="keywordflow">if</span> (time &lt;= timeouts-&gt;next-&gt;time) {
00147   timeouts-&gt;next-&gt;time -= time;
00148       } <span class="keywordflow">else</span> {
00149   timeouts-&gt;next-&gt;time = 0;
00150       }
00151     }
00152 
00153   }
00154 }
00155 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00156 <span class="keywordtype">void</span>
<a name="l00157"></a><a class="code" href="sys_8c.html#a2">00157</a> <a class="code" href="sys_8c.html#a2">sys_timeout</a>(u32_t msecs, <a class="code" href="sys_8h.html#a4">sys_timeout_handler</a> h, <span class="keywordtype">void</span> *arg)
00158 {
00159   <span class="keyword">struct </span><a class="code" href="structsys__timeouts.html">sys_timeouts</a> *timeouts;
00160   <span class="keyword">struct </span><a class="code" href="sys_8c.html#a2">sys_timeout</a> *timeout, *t;
00161 
00162   timeout = <a class="code" href="memp_8c.html#a6">memp_malloc</a>(<a class="code" href="memp_8h.html#a17a9">MEMP_SYS_TIMEOUT</a>);
00163   <span class="keywordflow">if</span> (timeout == <a class="code" href="def_8h.html#a2">NULL</a>) {
00164     <span class="keywordflow">return</span>;
00165   }
00166   timeout-&gt;next = <a class="code" href="def_8h.html#a2">NULL</a>;
00167   timeout-&gt;h = h;
00168   timeout-&gt;arg = arg;
00169   timeout-&gt;time = msecs;
00170 
00171   timeouts = <a class="code" href="sys_8h.html#a8">sys_arch_timeouts</a>();
00172 
00173   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a72">SYS_DEBUG</a>, (<span class="stringliteral">"sys_timeout: %p msecs=%lu h=%p arg=%p\n"</span>,
00174     (<span class="keywordtype">void</span> *)timeout, msecs, (<span class="keywordtype">void</span> *)h, (<span class="keywordtype">void</span> *)arg));
00175 
00176   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"sys_timeout: timeouts != NULL"</span>, timeouts != <a class="code" href="def_8h.html#a2">NULL</a>);
00177   <span class="keywordflow">if</span> (timeouts-&gt;next == <a class="code" href="def_8h.html#a2">NULL</a>) {
00178     timeouts-&gt;next = timeout;
00179     <span class="keywordflow">return</span>;
00180   }
00181 
00182   <span class="keywordflow">if</span> (timeouts-&gt;next-&gt;time &gt; msecs) {
00183     timeouts-&gt;next-&gt;time -= msecs;
00184     timeout-&gt;next = timeouts-&gt;next;
00185     timeouts-&gt;next = timeout;
00186   } <span class="keywordflow">else</span> {
00187     <span class="keywordflow">for</span>(t = timeouts-&gt;next; t != <a class="code" href="def_8h.html#a2">NULL</a>; t = t-&gt;next) {
00188       timeout-&gt;time -= t-&gt;time;
00189       <span class="keywordflow">if</span> (t-&gt;next == <a class="code" href="def_8h.html#a2">NULL</a> ||
00190    t-&gt;next-&gt;time &gt; timeout-&gt;time) {
00191   <span class="keywordflow">if</span> (t-&gt;next != <a class="code" href="def_8h.html#a2">NULL</a>) {
00192     t-&gt;next-&gt;time -= timeout-&gt;time;
00193   }
00194   timeout-&gt;next = t-&gt;next;
00195   t-&gt;next = timeout;
00196   <span class="keywordflow">break</span>;
00197       }
00198     }
00199   }
00200 
00201 }
00202 
00203 <span class="comment">/* Go through timeout list (for this task only) and remove the first matching entry,</span>
00204 <span class="comment">   even though the timeout has not triggered yet.</span>
00205 <span class="comment">*/</span>
00206 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00207 <span class="keywordtype">void</span>
<a name="l00208"></a><a class="code" href="sys_8c.html#a3">00208</a> <a class="code" href="sys_8c.html#a3">sys_untimeout</a>(<a class="code" href="sys_8h.html#a4">sys_timeout_handler</a> h, <span class="keywordtype">void</span> *arg)
00209 {
00210     <span class="keyword">struct </span><a class="code" href="structsys__timeouts.html">sys_timeouts</a> *timeouts;
00211     <span class="keyword">struct </span><a class="code" href="sys_8c.html#a2">sys_timeout</a> *prev_t, *t;
00212 
00213     timeouts = <a class="code" href="sys_8h.html#a8">sys_arch_timeouts</a>();
00214 
00215     <span class="keywordflow">if</span> (timeouts-&gt;next == <a class="code" href="def_8h.html#a2">NULL</a>)
00216         <span class="keywordflow">return</span>;
00217 
00218     <span class="keywordflow">for</span> (t = timeouts-&gt;next, prev_t = <a class="code" href="def_8h.html#a2">NULL</a>; t != <a class="code" href="def_8h.html#a2">NULL</a>; prev_t = t, t = t-&gt;next)
00219     {
00220         <span class="keywordflow">if</span> ((t-&gt;h == h) &amp;&amp; (t-&gt;arg == arg))
00221         {
00222             <span class="comment">/* We have a match */</span>
00223             <span class="comment">/* Unlink from previous in list */</span>
00224             <span class="keywordflow">if</span> (prev_t == <a class="code" href="def_8h.html#a2">NULL</a>)
00225                 timeouts-&gt;next = t-&gt;next;
00226             <span class="keywordflow">else</span>
00227                 prev_t-&gt;next = t-&gt;next;
00228             <span class="comment">/* If not the last one, add time of this one back to next */</span>
00229             <span class="keywordflow">if</span> (t-&gt;next != <a class="code" href="def_8h.html#a2">NULL</a>)
00230                 t-&gt;next-&gt;time += t-&gt;time;
00231             <a class="code" href="memp_8c.html#a8">memp_free</a>(<a class="code" href="memp_8h.html#a17a9">MEMP_SYS_TIMEOUT</a>, t);
00232             <span class="keywordflow">return</span>;
00233         }
00234     }
00235     <span class="keywordflow">return</span>;
00236 }
00237 
00238 
00239 
00240 
00241 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00242 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00243"></a><a class="code" href="sys_8c.html#a4">00243</a> <a class="code" href="sys_8c.html#a4">sswt_handler</a>(<span class="keywordtype">void</span> *arg)
00244 {
00245     <span class="keyword">struct </span><a class="code" href="structsswt__cb.html">sswt_cb</a> *<a class="code" href="structsswt__cb.html">sswt_cb</a> = (<span class="keyword">struct </span><a class="code" href="structsswt__cb.html">sswt_cb</a> *) arg;
00246 
00247     <span class="comment">/* Timeout. Set flag to TRUE and signal semaphore */</span>
00248     <a class="code" href="structsswt__cb.html">sswt_cb</a>-&gt;timeflag = 1;
00249     <a class="code" href="sys_8h.html#a10">sys_sem_signal</a>(*(<a class="code" href="structsswt__cb.html">sswt_cb</a>-&gt;psem));
00250 }
00251 
00252 <span class="comment">/* Wait for a semaphore with timeout (specified in ms) */</span>
00253 <span class="comment">/* timeout = 0: wait forever */</span>
00254 <span class="comment">/* Returns 0 on timeout. 1 otherwise */</span>
00255 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00256 <span class="keywordtype">int</span>
<a name="l00257"></a><a class="code" href="sys_8c.html#a5">00257</a> <a class="code" href="sys_8c.html#a5">sys_sem_wait_timeout</a>(sys_sem_t sem, u32_t timeout)
00258 {
00259     <span class="keyword">struct </span><a class="code" href="structsswt__cb.html">sswt_cb</a> sswt_cb;
00260 
00261     sswt_cb.<a class="code" href="structsswt__cb.html#o1">psem</a> = &amp;sem;
00262     sswt_cb.<a class="code" href="structsswt__cb.html#o0">timeflag</a> = 0;
00263 
00264     <span class="comment">/* If timeout is zero, then just wait forever */</span>
00265     <span class="keywordflow">if</span> (timeout &gt; 0)
00266         <span class="comment">/* Create a timer and pass it the address of our flag */</span>
00267         <a class="code" href="sys_8c.html#a2">sys_timeout</a>(timeout, <a class="code" href="sys_8c.html#a4">sswt_handler</a>, &amp;sswt_cb);
00268     <a class="code" href="sys_8c.html#a1">sys_sem_wait</a>(sem);
00269     <span class="comment">/* Was it a timeout? */</span>
00270     <span class="keywordflow">if</span> (sswt_cb.<a class="code" href="structsswt__cb.html#o0">timeflag</a>)
00271     {
00272         <span class="comment">/* timeout */</span>
00273         <span class="keywordflow">return</span> 0;
00274     } <span class="keywordflow">else</span> {
00275         <span class="comment">/* Not a timeout. Remove timeout entry */</span>
00276         <a class="code" href="sys_8c.html#a3">sys_untimeout</a>(<a class="code" href="sys_8c.html#a4">sswt_handler</a>, &amp;sswt_cb);
00277         <span class="keywordflow">return</span> 1;
00278     }
00279 
00280 }
00281 
00282 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00283 <span class="keywordtype">void</span>
<a name="l00284"></a><a class="code" href="sys_8c.html#a6">00284</a> <a class="code" href="sys_8c.html#a6">sys_msleep</a>(u32_t ms)
00285 {
00286   sys_sem_t delaysem = <a class="code" href="sys_8h.html#a9">sys_sem_new</a>(0);
00287 
00288   <a class="code" href="sys_8c.html#a5">sys_sem_wait_timeout</a>(delaysem, ms);
00289 
00290   <a class="code" href="sys_8h.html#a12">sys_sem_free</a>(delaysem);
00291 }
00292 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00293 
00294 <span class="preprocessor">#endif </span><span class="comment">/* NO_SYS */</span>
</pre></div>	</td>
  </tr>
</table>
<hr>
<div align="center">Copyright (c) 2001-2003 Swedish Institute of Computer Science</div>
</html>
