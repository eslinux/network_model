
<html>
<head>
<title>lwIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="doxygen.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<table width="98%" border="0" align="center">
  <tr>
    <td>
      <h2>lwIP code documentation</h2>
<hr>

<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>tcp.h</h1><a href="tcp_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2001-2003 Swedish Institute of Computer Science.</span>
00003 <span class="comment"> * All rights reserved. </span>
00004 <span class="comment"> * </span>
00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without modification, </span>
00006 <span class="comment"> * are permitted provided that the following conditions are met:</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span>
00009 <span class="comment"> *    this list of conditions and the following disclaimer.</span>
00010 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
00011 <span class="comment"> *    this list of conditions and the following disclaimer in the documentation</span>
00012 <span class="comment"> *    and/or other materials provided with the distribution.</span>
00013 <span class="comment"> * 3. The name of the author may not be used to endorse or promote products</span>
00014 <span class="comment"> *    derived from this software without specific prior written permission. </span>
00015 <span class="comment"> *</span>
00016 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED </span>
00017 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF </span>
00018 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT </span>
00019 <span class="comment"> * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, </span>
00020 <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT </span>
00021 <span class="comment"> * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS </span>
00022 <span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN </span>
00023 <span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING </span>
00024 <span class="comment"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY </span>
00025 <span class="comment"> * OF SUCH DAMAGE.</span>
00026 <span class="comment"> *</span>
00027 <span class="comment"> * This file is part of the lwIP TCP/IP stack.</span>
00028 <span class="comment"> * </span>
00029 <span class="comment"> * Author: Adam Dunkels &lt;adam@sics.se&gt;</span>
00030 <span class="comment"> *</span>
00031 <span class="comment"> */</span>
00032 <span class="preprocessor">#ifndef __LWIP_TCP_H__</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#define __LWIP_TCP_H__</span>
00034 <span class="preprocessor"></span>
00035 <span class="preprocessor">#include "<a class="code" href="sys_8h.html">lwip/sys.h</a>"</span>
00036 <span class="preprocessor">#include "<a class="code" href="mem_8h.html">lwip/mem.h</a>"</span>
00037 
00038 <span class="preprocessor">#include "<a class="code" href="pbuf_8h.html">lwip/pbuf.h</a>"</span>
00039 <span class="preprocessor">#include "<a class="code" href="opt_8h.html">lwip/opt.h</a>"</span>
00040 <span class="preprocessor">#include "lwip/ip.h"</span>
00041 <span class="preprocessor">#include "lwip/icmp.h"</span>
00042 
00043 <span class="preprocessor">#include "<a class="code" href="sys_8h.html">lwip/sys.h</a>"</span>
00044 
00045 <span class="preprocessor">#include "<a class="code" href="err_8h.html">lwip/err.h</a>"</span>
00046 
00047 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a>;
00048 
00049 <span class="comment">/* Functions for interfacing with TCP: */</span>
00050 
00051 <span class="comment">/* Lower layer interface to TCP: */</span>
00052 <span class="keywordtype">void</span>             <a class="code" href="tcp_8h.html#a64">tcp_init</a>    (<span class="keywordtype">void</span>);  <span class="comment">/* Must be called first to</span>
00053 <span class="comment">           initialize TCP. */</span>
00054 <span class="keywordtype">void</span>             <a class="code" href="tcp_8h.html#a65">tcp_tmr</a>     (<span class="keywordtype">void</span>);  <span class="comment">/* Must be called every</span>
00055 <span class="comment">           TCP_TMR_INTERVAL</span>
00056 <span class="comment">           ms. (Typically 100 ms). */</span>
00057 <span class="comment">/* Application program's interface: */</span>
00058 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> * <a class="code" href="tcp_8h.html#a66">tcp_new</a>     (<span class="keywordtype">void</span>);
00059 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> * <a class="code" href="tcp_8h.html#a67">tcp_alloc</a>   (u8_t prio);
00060 
00061 <span class="keywordtype">void</span>             <a class="code" href="tcp_8h.html#a68">tcp_arg</a>     (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keywordtype">void</span> *arg);
00062 <span class="keywordtype">void</span>             <a class="code" href="tcp_8h.html#a69">tcp_accept</a>  (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
00063             <a class="code" href="err_8h.html#a13">err_t</a> (* accept)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *newpcb,
00064                  <a class="code" href="err_8h.html#a13">err_t</a> err));
00065 <span class="keywordtype">void</span>             <a class="code" href="tcp_8h.html#a70">tcp_recv</a>    (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
00066             <a class="code" href="err_8h.html#a13">err_t</a> (* recv)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *tpcb,
00067           <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p, <a class="code" href="err_8h.html#a13">err_t</a> err));
00068 <span class="keywordtype">void</span>             <a class="code" href="tcp_8h.html#a71">tcp_sent</a>    (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
00069             <a class="code" href="err_8h.html#a13">err_t</a> (* sent)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *tpcb,
00070                u16_t len));
00071 <span class="keywordtype">void</span>             <a class="code" href="tcp_8h.html#a72">tcp_poll</a>    (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
00072             <a class="code" href="err_8h.html#a13">err_t</a> (* poll)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *tpcb),
00073             u8_t interval);
00074 <span class="keywordtype">void</span>             <a class="code" href="tcp_8h.html#a73">tcp_err</a>     (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
00075             <span class="keywordtype">void</span> (* err)(<span class="keywordtype">void</span> *arg, <a class="code" href="err_8h.html#a13">err_t</a> err));
00076 
<a name="l00077"></a><a class="code" href="tcp_8h.html#a0">00077</a> <span class="preprocessor">#define          tcp_mss(pcb)      ((pcb)-&gt;mss)</span>
<a name="l00078"></a><a class="code" href="tcp_8h.html#a1">00078</a> <span class="preprocessor"></span><span class="preprocessor">#define          tcp_sndbuf(pcb)   ((pcb)-&gt;snd_buf)</span>
00079 <span class="preprocessor"></span>
00080 <span class="keywordtype">void</span>             <a class="code" href="tcp_8h.html#a74">tcp_recved</a>  (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u16_t len);
00081 <a class="code" href="err_8h.html#a13">err_t</a>            <a class="code" href="tcp_8h.html#a75">tcp_bind</a>    (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *ipaddr,
00082             u16_t port);
00083 <a class="code" href="err_8h.html#a13">err_t</a>            <a class="code" href="tcp_8h.html#a76">tcp_connect</a> (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *ipaddr,
00084             u16_t port, <a class="code" href="err_8h.html#a13">err_t</a> (* connected)(<span class="keywordtype">void</span> *arg,
00085                     <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *tpcb,
00086                     <a class="code" href="err_8h.html#a13">err_t</a> err));
00087 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> * <a class="code" href="tcp_8h.html#a77">tcp_listen</a>  (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
00088 <span class="keywordtype">void</span>             <a class="code" href="tcp_8h.html#a78">tcp_abort</a>   (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
00089 <a class="code" href="err_8h.html#a13">err_t</a>            <a class="code" href="tcp_8h.html#a79">tcp_close</a>   (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
00090 <a class="code" href="err_8h.html#a13">err_t</a>            <a class="code" href="tcp_8h.html#a80">tcp_write</a>   (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">const</span> <span class="keywordtype">void</span> *dataptr, u16_t len,
00091             u8_t copy);
00092 
00093 <span class="keywordtype">void</span>             <a class="code" href="tcp_8h.html#a81">tcp_setprio</a> (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t prio);
00094 
<a name="l00095"></a><a class="code" href="tcp_8h.html#a2">00095</a> <span class="preprocessor">#define TCP_PRIO_MIN    1</span>
<a name="l00096"></a><a class="code" href="tcp_8h.html#a3">00096</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_PRIO_NORMAL 64</span>
<a name="l00097"></a><a class="code" href="tcp_8h.html#a4">00097</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_PRIO_MAX    127</span>
00098 <span class="preprocessor"></span>
00099 <span class="comment">/* It is also possible to call these two functions at the right</span>
00100 <span class="comment">   intervals (instead of calling tcp_tmr()). */</span>
00101 <span class="keywordtype">void</span>             <a class="code" href="tcp_8h.html#a82">tcp_slowtmr</a> (<span class="keywordtype">void</span>);
00102 <span class="keywordtype">void</span>             <a class="code" href="tcp_8h.html#a83">tcp_fasttmr</a> (<span class="keywordtype">void</span>);
00103 
00104 
00105 <span class="comment">/* Only used by IP to pass a TCP segment to TCP: */</span>
00106 <span class="keywordtype">void</span>             <a class="code" href="tcp_8h.html#a84">tcp_input</a>   (<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p, <span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *inp);
00107 <span class="comment">/* Used within the TCP code only: */</span>
00108 <a class="code" href="err_8h.html#a13">err_t</a>            <a class="code" href="tcp_8h.html#a85">tcp_output</a>  (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
00109 <span class="keywordtype">void</span>             <a class="code" href="tcp_8h.html#a86">tcp_rexmit</a>  (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
00110 
00111 
00112 
<a name="l00113"></a><a class="code" href="tcp_8h.html#a5">00113</a> <span class="preprocessor">#define TCP_SEQ_LT(a,b)     ((s32_t)((a)-(b)) &lt; 0)</span>
<a name="l00114"></a><a class="code" href="tcp_8h.html#a6">00114</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_SEQ_LEQ(a,b)    ((s32_t)((a)-(b)) &lt;= 0)</span>
<a name="l00115"></a><a class="code" href="tcp_8h.html#a7">00115</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_SEQ_GT(a,b)     ((s32_t)((a)-(b)) &gt; 0)</span>
<a name="l00116"></a><a class="code" href="tcp_8h.html#a8">00116</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_SEQ_GEQ(a,b)    ((s32_t)((a)-(b)) &gt;= 0)</span>
00117 <span class="preprocessor"></span>
<a name="l00118"></a><a class="code" href="tcp_8h.html#a9">00118</a> <span class="preprocessor">#define TCP_FIN 0x01</span>
<a name="l00119"></a><a class="code" href="tcp_8h.html#a10">00119</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_SYN 0x02</span>
<a name="l00120"></a><a class="code" href="tcp_8h.html#a11">00120</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_RST 0x04</span>
<a name="l00121"></a><a class="code" href="tcp_8h.html#a12">00121</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_PSH 0x08</span>
<a name="l00122"></a><a class="code" href="tcp_8h.html#a13">00122</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_ACK 0x10</span>
<a name="l00123"></a><a class="code" href="tcp_8h.html#a14">00123</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_URG 0x20</span>
00124 <span class="preprocessor"></span>
<a name="l00125"></a><a class="code" href="tcp_8h.html#a15">00125</a> <span class="preprocessor">#define TCP_FLAGS 0x3f</span>
00126 <span class="preprocessor"></span>
00127 <span class="comment">/* Length of the TCP header, excluding options. */</span>
<a name="l00128"></a><a class="code" href="tcp_8h.html#a16">00128</a> <span class="preprocessor">#define TCP_HLEN 20</span>
00129 <span class="preprocessor"></span>
00130 <span class="preprocessor">#ifndef TCP_TMR_INTERVAL</span>
<a name="l00131"></a><a class="code" href="tcp_8h.html#a17">00131</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_TMR_INTERVAL       100  </span><span class="comment">/* The TCP timer interval in</span>
00132 <span class="comment">                                       milliseconds. */</span>
00133 <span class="preprocessor">#endif </span><span class="comment">/* TCP_TMR_INTERVAL */</span>
00134 
00135 <span class="preprocessor">#ifndef TCP_FAST_INTERVAL</span>
<a name="l00136"></a><a class="code" href="tcp_8h.html#a18">00136</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_FAST_INTERVAL      200  </span><span class="comment">/* the fine grained timeout in</span>
00137 <span class="comment">                                       milliseconds */</span>
00138 <span class="preprocessor">#endif </span><span class="comment">/* TCP_FAST_INTERVAL */</span>
00139 
00140 <span class="preprocessor">#ifndef TCP_SLOW_INTERVAL</span>
<a name="l00141"></a><a class="code" href="tcp_8h.html#a19">00141</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_SLOW_INTERVAL      500  </span><span class="comment">/* the coarse grained timeout in</span>
00142 <span class="comment">                                       milliseconds */</span>
00143 <span class="preprocessor">#endif </span><span class="comment">/* TCP_SLOW_INTERVAL */</span>
00144 
<a name="l00145"></a><a class="code" href="tcp_8h.html#a20">00145</a> <span class="preprocessor">#define TCP_FIN_WAIT_TIMEOUT 20000 </span><span class="comment">/* milliseconds */</span>
<a name="l00146"></a><a class="code" href="tcp_8h.html#a21">00146</a> <span class="preprocessor">#define TCP_SYN_RCVD_TIMEOUT 20000 </span><span class="comment">/* milliseconds */</span>
00147 
<a name="l00148"></a><a class="code" href="tcp_8h.html#a22">00148</a> <span class="preprocessor">#define TCP_OOSEQ_TIMEOUT        6 </span><span class="comment">/* x RTO */</span>
00149 
<a name="l00150"></a><a class="code" href="tcp_8h.html#a23">00150</a> <span class="preprocessor">#define TCP_MSL 60000  </span><span class="comment">/* The maximum segment lifetime in microseconds */</span>
00151 
00152 <span class="preprocessor">#ifdef PACK_STRUCT_USE_INCLUDES</span>
00153 <span class="preprocessor"></span><span class="preprocessor">#  include "arch/bpstruct.h"</span>
00154 <span class="preprocessor">#endif</span>
00155 <span class="preprocessor"></span>PACK_STRUCT_BEGIN
<a name="l00156"></a><a class="code" href="structtcp__hdr.html">00156</a> <span class="keyword">struct </span><a class="code" href="structtcp__hdr.html">tcp_hdr</a> {
00157   <a class="code" href="structtcp__hdr.html#a0">PACK_STRUCT_FIELD</a>(u16_t src);
00158   <a class="code" href="structtcp__hdr.html#a0">PACK_STRUCT_FIELD</a>(u16_t dest);
00159   <a class="code" href="structtcp__hdr.html#a0">PACK_STRUCT_FIELD</a>(u32_t seqno);
00160   <a class="code" href="structtcp__hdr.html#a0">PACK_STRUCT_FIELD</a>(u32_t ackno);
00161   <a class="code" href="structtcp__hdr.html#a0">PACK_STRUCT_FIELD</a>(u16_t _offset_flags);
00162   <a class="code" href="structtcp__hdr.html#a0">PACK_STRUCT_FIELD</a>(u16_t wnd);
00163   <a class="code" href="structtcp__hdr.html#a0">PACK_STRUCT_FIELD</a>(u16_t chksum);
00164   <a class="code" href="structtcp__hdr.html#a0">PACK_STRUCT_FIELD</a>(u16_t urgp);
00165 } <a class="code" href="etharp_8h.html#a15">PACK_STRUCT_STRUCT</a>;
00166 PACK_STRUCT_END
00167 <span class="preprocessor">#ifdef PACK_STRUCT_USE_INCLUDES</span>
00168 <span class="preprocessor"></span><span class="preprocessor">#  include "arch/epstruct.h"</span>
00169 <span class="preprocessor">#endif</span>
00170 <span class="preprocessor"></span>
<a name="l00171"></a><a class="code" href="tcp_8h.html#a24">00171</a> <span class="preprocessor">#define TCPH_OFFSET(hdr) (ntohs((hdr)-&gt;_offset_flags) &gt;&gt; 8)</span>
<a name="l00172"></a><a class="code" href="tcp_8h.html#a25">00172</a> <span class="preprocessor"></span><span class="preprocessor">#define TCPH_FLAGS(hdr) (ntohs((hdr)-&gt;_offset_flags) &amp; 0xff)</span>
00173 <span class="preprocessor"></span>
<a name="l00174"></a><a class="code" href="tcp_8h.html#a26">00174</a> <span class="preprocessor">#define TCPH_OFFSET_SET(hdr, offset) (hdr)-&gt;_offset_flags = htons(((offset) &lt;&lt; 8) | TCPH_FLAGS(hdr))</span>
<a name="l00175"></a><a class="code" href="tcp_8h.html#a27">00175</a> <span class="preprocessor"></span><span class="preprocessor">#define TCPH_FLAGS_SET(hdr, flags) (hdr)-&gt;_offset_flags = htons((TCPH_OFFSET(hdr) &lt;&lt; 8) | (flags))</span>
00176 <span class="preprocessor"></span>
<a name="l00177"></a><a class="code" href="tcp_8h.html#a28">00177</a> <span class="preprocessor">#define TCP_TCPLEN(seg) ((seg)-&gt;len + ((TCPH_FLAGS((seg)-&gt;tcphdr) &amp; TCP_FIN || \</span>
00178 <span class="preprocessor">          TCPH_FLAGS((seg)-&gt;tcphdr) &amp; TCP_SYN)? 1: 0))</span>
00179 <span class="preprocessor"></span>
<a name="l00180"></a><a class="code" href="tcp_8h.html#a99">00180</a> <span class="keyword">enum</span> <a class="code" href="tcp_8h.html#a99">tcp_state</a> {
00181   <a class="code" href="fsm_8h.html#a10">CLOSED</a>      = 0,
00182   <a class="code" href="tcp_8h.html#a99a54">LISTEN</a>      = 1,
00183   <a class="code" href="tcp_8h.html#a99a55">SYN_SENT</a>    = 2,
00184   <a class="code" href="tcp_8h.html#a99a56">SYN_RCVD</a>    = 3,
00185   <a class="code" href="tcp_8h.html#a99a57">ESTABLISHED</a> = 4,
00186   <a class="code" href="tcp_8h.html#a99a58">FIN_WAIT_1</a>  = 5,
00187   <a class="code" href="tcp_8h.html#a99a59">FIN_WAIT_2</a>  = 6,
00188   <a class="code" href="tcp_8h.html#a99a60">CLOSE_WAIT</a>  = 7,
00189   <a class="code" href="fsm_8h.html#a12">CLOSING</a>     = 8,
00190   <a class="code" href="tcp_8h.html#a99a62">LAST_ACK</a>    = 9,
00191   <a class="code" href="tcp_8h.html#a99a63">TIME_WAIT</a>   = 10
00192 };
00193 
00194 
00195 <span class="comment">/* the TCP protocol control block */</span>
<a name="l00196"></a><a class="code" href="structtcp__pcb.html">00196</a> <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> {
<a name="l00197"></a><a class="code" href="structtcp__pcb.html#o0">00197</a>   <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *<a class="code" href="structtcp__pcb.html#o0">next</a>;   <span class="comment">/* for the linked list */</span>
<a name="l00198"></a><a class="code" href="structtcp__pcb.html#o1">00198</a>   u8_t <a class="code" href="structtcp__pcb.html#o1">prio</a>;
<a name="l00199"></a><a class="code" href="structtcp__pcb.html#o2">00199</a>   <span class="keywordtype">void</span> *<a class="code" href="structtcp__pcb.html#o2">callback_arg</a>;
00200 
<a name="l00201"></a><a class="code" href="structtcp__pcb.html#o3">00201</a>   <span class="keyword">struct </span><a class="code" href="structip__addr.html">ip_addr</a> local_ip;
<a name="l00202"></a><a class="code" href="structtcp__pcb.html#o4">00202</a>   u16_t <a class="code" href="structtcp__pcb.html#o4">local_port</a>;
<a name="l00203"></a><a class="code" href="structtcp__pcb.html#o5">00203</a>   <span class="keyword">enum</span> <a class="code" href="tcp_8h.html#a99">tcp_state</a> <a class="code" href="structtcp__pcb.html#o5">state</a>;   <span class="comment">/* TCP state */</span>
00204   
<a name="l00205"></a><a class="code" href="structtcp__pcb.html#o6">00205</a>   <span class="keyword">struct </span><a class="code" href="structip__addr.html">ip_addr</a> remote_ip;
<a name="l00206"></a><a class="code" href="structtcp__pcb.html#o7">00206</a>   u16_t <a class="code" href="structtcp__pcb.html#o7">remote_port</a>;
00207   
00208   <span class="comment">/* receiver varables */</span>
<a name="l00209"></a><a class="code" href="structtcp__pcb.html#o8">00209</a>   u32_t <a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>;   <span class="comment">/* next seqno expected */</span>
<a name="l00210"></a><a class="code" href="structtcp__pcb.html#o9">00210</a>   u16_t <a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a>;   <span class="comment">/* receiver window */</span>
00211   
00212   <span class="comment">/* Timers */</span>
<a name="l00213"></a><a class="code" href="structtcp__pcb.html#o10">00213</a>   u32_t <a class="code" href="structtcp__pcb.html#o10">tmr</a>;
<a name="l00214"></a><a class="code" href="structtcp__pcb.html#o11">00214</a>   u8_t <a class="code" href="structtcp__pcb.html#o11">polltmr</a>, <a class="code" href="structtcp__pcb.html#o12">pollinterval</a>;
00215   
00216   <span class="comment">/* Retransmission timer. */</span>
<a name="l00217"></a><a class="code" href="structtcp__pcb.html#o13">00217</a>   u16_t <a class="code" href="structtcp__pcb.html#o13">rtime</a>;
00218   
<a name="l00219"></a><a class="code" href="structtcp__pcb.html#o14">00219</a>   u16_t <a class="code" href="structtcp__pcb.html#o14">mss</a>;   <span class="comment">/* maximum segment size */</span>
00220 
<a name="l00221"></a><a class="code" href="structtcp__pcb.html#o15">00221</a>   u8_t <a class="code" href="structtcp__pcb.html#o15">flags</a>;
<a name="l00222"></a><a class="code" href="tcp_8h.html#a29">00222</a> <span class="preprocessor">#define TF_ACK_DELAY 0x01U   </span><span class="comment">/* Delayed ACK. */</span>
<a name="l00223"></a><a class="code" href="tcp_8h.html#a30">00223</a> <span class="preprocessor">#define TF_ACK_NOW   0x02U   </span><span class="comment">/* Immediate ACK. */</span>
<a name="l00224"></a><a class="code" href="tcp_8h.html#a31">00224</a> <span class="preprocessor">#define TF_INFR      0x04U   </span><span class="comment">/* In fast recovery. */</span>
<a name="l00225"></a><a class="code" href="tcp_8h.html#a32">00225</a> <span class="preprocessor">#define TF_RESET     0x08U   </span><span class="comment">/* Connection was reset. */</span>
<a name="l00226"></a><a class="code" href="tcp_8h.html#a33">00226</a> <span class="preprocessor">#define TF_CLOSED    0x10U   </span><span class="comment">/* Connection was sucessfully closed. */</span>
<a name="l00227"></a><a class="code" href="tcp_8h.html#a34">00227</a> <span class="preprocessor">#define TF_GOT_FIN   0x20U   </span><span class="comment">/* Connection was closed by the remote end. */</span>
00228   
00229   <span class="comment">/* RTT estimation variables. */</span>
<a name="l00230"></a><a class="code" href="structtcp__pcb.html#o16">00230</a>   u16_t <a class="code" href="structtcp__pcb.html#o16">rttest</a>; <span class="comment">/* RTT estimate in 500ms ticks */</span>
<a name="l00231"></a><a class="code" href="structtcp__pcb.html#o17">00231</a>   u32_t <a class="code" href="structtcp__pcb.html#o17">rtseq</a>;  <span class="comment">/* sequence number being timed */</span>
<a name="l00232"></a><a class="code" href="structtcp__pcb.html#o19">00232</a>   s16_t <a class="code" href="structtcp__pcb.html#o18">sa</a>, <a class="code" href="structtcp__pcb.html#o19">sv</a>;
00233 
<a name="l00234"></a><a class="code" href="structtcp__pcb.html#o20">00234</a>   u16_t <a class="code" href="structtcp__pcb.html#o20">rto</a>;    <span class="comment">/* retransmission time-out */</span>
<a name="l00235"></a><a class="code" href="structtcp__pcb.html#o21">00235</a>   u8_t <a class="code" href="structtcp__pcb.html#o21">nrtx</a>;    <span class="comment">/* number of retransmissions */</span>
00236 
00237   <span class="comment">/* fast retransmit/recovery */</span>
<a name="l00238"></a><a class="code" href="structtcp__pcb.html#o22">00238</a>   u32_t <a class="code" href="structtcp__pcb.html#o22">lastack</a>; <span class="comment">/* Highest acknowledged seqno. */</span>
<a name="l00239"></a><a class="code" href="structtcp__pcb.html#o23">00239</a>   u8_t <a class="code" href="structtcp__pcb.html#o23">dupacks</a>;
00240   
00241   <span class="comment">/* congestion avoidance/control variables */</span>
<a name="l00242"></a><a class="code" href="structtcp__pcb.html#o24">00242</a>   u16_t <a class="code" href="structtcp__pcb.html#o24">cwnd</a>;  
<a name="l00243"></a><a class="code" href="structtcp__pcb.html#o25">00243</a>   u16_t <a class="code" href="structtcp__pcb.html#o25">ssthresh</a>;
00244 
00245   <span class="comment">/* sender variables */</span>
<a name="l00246"></a><a class="code" href="structtcp__pcb.html#o28">00246</a>   u32_t <a class="code" href="structtcp__pcb.html#o26">snd_nxt</a>,       <span class="comment">/* next seqno to be sent */</span>
00247     <a class="code" href="structtcp__pcb.html#o27">snd_max</a>,       <span class="comment">/* Highest seqno sent. */</span>
00248     <a class="code" href="structtcp__pcb.html#o28">snd_wnd</a>,       <span class="comment">/* sender window */</span>
00249     <a class="code" href="structtcp__pcb.html#o29">snd_wl1</a>, <a class="code" href="structtcp__pcb.html#o30">snd_wl2</a>, <span class="comment">/* Sequence and acknowledgement numbers of last</span>
00250 <span class="comment">       window update. */</span>
00251     <a class="code" href="structtcp__pcb.html#o31">snd_lbb</a>;       <span class="comment">/* Sequence number of next byte to be buffered. */</span>
00252 
<a name="l00253"></a><a class="code" href="structtcp__pcb.html#o32">00253</a>   u16_t <a class="code" href="structtcp__pcb.html#o32">acked</a>;
00254   
<a name="l00255"></a><a class="code" href="structtcp__pcb.html#o33">00255</a>   u16_t <a class="code" href="structtcp__pcb.html#o33">snd_buf</a>;   <span class="comment">/* Available buffer space for sending (in bytes). */</span>
<a name="l00256"></a><a class="code" href="structtcp__pcb.html#o34">00256</a>   u8_t <a class="code" href="structtcp__pcb.html#o34">snd_queuelen</a>; <span class="comment">/* Available buffer space for sending (in tcp_segs). */</span>
00257   
00258   
00259   <span class="comment">/* These are ordered by sequence number: */</span>
<a name="l00260"></a><a class="code" href="structtcp__pcb.html#o35">00260</a>   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *<a class="code" href="structtcp__pcb.html#o35">unsent</a>;   <span class="comment">/* Unsent (queued) segments. */</span>
<a name="l00261"></a><a class="code" href="structtcp__pcb.html#o36">00261</a>   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *<a class="code" href="structtcp__pcb.html#o36">unacked</a>;  <span class="comment">/* Sent but unacknowledged segments. */</span>
00262 <span class="preprocessor">#if TCP_QUEUE_OOSEQ  </span>
00263 <span class="preprocessor"></span>  <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *ooseq;    <span class="comment">/* Received out of sequence segments. */</span>
00264 <span class="preprocessor">#endif </span><span class="comment">/* TCP_QUEUE_OOSEQ */</span>
00265 
00266 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
00267 <span class="preprocessor"></span>  <span class="comment">/* Function to be called when more send buffer space is available. */</span>
00268   <a class="code" href="err_8h.html#a13">err_t</a> (* sent)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u16_t space);
00269   
00270   <span class="comment">/* Function to be called when (in-sequence) data has arrived. */</span>
00271   <a class="code" href="err_8h.html#a13">err_t</a> (* recv)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p, <a class="code" href="err_8h.html#a13">err_t</a> err);
00272 
00273   <span class="comment">/* Function to be called when a connection has been set up. */</span>
00274   <a class="code" href="err_8h.html#a13">err_t</a> (* connected)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="code" href="err_8h.html#a13">err_t</a> err);
00275 
00276   <span class="comment">/* Function to call when a listener has been connected. */</span>
00277   <a class="code" href="err_8h.html#a13">err_t</a> (* accept)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *newpcb, <a class="code" href="err_8h.html#a13">err_t</a> err);
00278 
00279   <span class="comment">/* Function which is called periodically. */</span>
00280   <a class="code" href="err_8h.html#a13">err_t</a> (* poll)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
00281 
00282   <span class="comment">/* Function to be called whenever a fatal error occurs. */</span>
00283   void (* errf)(<span class="keywordtype">void</span> *arg, <a class="code" href="err_8h.html#a13">err_t</a> err);
00284 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>
00285 };
00286 
<a name="l00287"></a><a class="code" href="structtcp__pcb__listen.html">00287</a> <span class="keyword">struct </span><a class="code" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> {  
<a name="l00288"></a><a class="code" href="structtcp__pcb__listen.html#o0">00288</a>   <span class="keyword">struct </span><a class="code" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *<a class="code" href="structtcp__pcb__listen.html#o0">next</a>;   <span class="comment">/* for the linked list */</span>
<a name="l00289"></a><a class="code" href="structtcp__pcb__listen.html#o1">00289</a>   u8_t <a class="code" href="structtcp__pcb__listen.html#o1">prio</a>;
<a name="l00290"></a><a class="code" href="structtcp__pcb__listen.html#o2">00290</a>   <span class="keywordtype">void</span> *<a class="code" href="structtcp__pcb__listen.html#o2">callback_arg</a>;
00291   
<a name="l00292"></a><a class="code" href="structtcp__pcb__listen.html#o3">00292</a>   <span class="keyword">struct </span><a class="code" href="structip__addr.html">ip_addr</a> local_ip;
<a name="l00293"></a><a class="code" href="structtcp__pcb__listen.html#o4">00293</a>   u16_t <a class="code" href="structtcp__pcb__listen.html#o4">local_port</a>; 
00294   <span class="comment">/* Even if state is obviously LISTEN this is here for</span>
00295 <span class="comment">   * field compatibility with tpc_pcb to which it is cast sometimes</span>
00296 <span class="comment">   * Until a cleaner solution emerges this is here.FIXME</span>
00297 <span class="comment">   */</span> 
<a name="l00298"></a><a class="code" href="structtcp__pcb__listen.html#o5">00298</a>   <span class="keyword">enum</span> <a class="code" href="tcp_8h.html#a99">tcp_state</a> <a class="code" href="structtcp__pcb__listen.html#o5">state</a>;   <span class="comment">/* TCP state */</span>
00299 
00300 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
00301 <span class="preprocessor"></span>  <span class="comment">/* Function to call when a listener has been connected. */</span>
00302   <a class="code" href="err_8h.html#a13">err_t</a> (* accept)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *newpcb, <a class="code" href="err_8h.html#a13">err_t</a> err);
00303 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>
00304 };
00305 
00306 <span class="preprocessor">#if LWIP_EVENT_API</span>
00307 <span class="preprocessor"></span>
00308 <span class="keyword">enum</span> lwip_event {
00309   LWIP_EVENT_ACCEPT,
00310   LWIP_EVENT_SENT,
00311   LWIP_EVENT_RECV,
00312   LWIP_EVENT_CONNECTED,
00313   LWIP_EVENT_POLL,
00314   LWIP_EVENT_ERR
00315 };
00316 
00317 <a class="code" href="err_8h.html#a13">err_t</a> lwip_tcp_event(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
00318          <span class="keyword">enum</span> lwip_event,
00319          <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p,
00320          u16_t size,
00321          <a class="code" href="err_8h.html#a13">err_t</a> err);
00322 
00323 <span class="preprocessor">#define TCP_EVENT_ACCEPT(pcb,err,ret)    ret = lwip_tcp_event((pcb)-&gt;callback_arg, (pcb),\</span>
00324 <span class="preprocessor">                LWIP_EVENT_ACCEPT, NULL, 0, err)</span>
00325 <span class="preprocessor"></span><span class="preprocessor">#define TCP_EVENT_SENT(pcb,space,ret) ret = lwip_tcp_event((pcb)-&gt;callback_arg, (pcb),\</span>
00326 <span class="preprocessor">                   LWIP_EVENT_SENT, NULL, space, ERR_OK)</span>
00327 <span class="preprocessor"></span><span class="preprocessor">#define TCP_EVENT_RECV(pcb,p,err,ret) ret = lwip_tcp_event((pcb)-&gt;callback_arg, (pcb),\</span>
00328 <span class="preprocessor">                LWIP_EVENT_RECV, (p), 0, (err))</span>
00329 <span class="preprocessor"></span><span class="preprocessor">#define TCP_EVENT_CONNECTED(pcb,err,ret) ret = lwip_tcp_event((pcb)-&gt;callback_arg, (pcb),\</span>
00330 <span class="preprocessor">                LWIP_EVENT_CONNECTED, NULL, 0, (err))</span>
00331 <span class="preprocessor"></span><span class="preprocessor">#define TCP_EVENT_POLL(pcb,ret)       ret = lwip_tcp_event((pcb)-&gt;callback_arg, (pcb),\</span>
00332 <span class="preprocessor">                LWIP_EVENT_POLL, NULL, 0, ERR_OK)</span>
00333 <span class="preprocessor"></span><span class="preprocessor">#define TCP_EVENT_ERR(errf,arg,err)  lwip_tcp_event((arg), NULL, \</span>
00334 <span class="preprocessor">                LWIP_EVENT_ERR, NULL, 0, (err))</span>
00335 <span class="preprocessor"></span><span class="preprocessor">#else </span><span class="comment">/* LWIP_EVENT_API */</span>
<a name="l00336"></a><a class="code" href="tcp_8h.html#a35">00336</a> <span class="preprocessor">#define TCP_EVENT_ACCEPT(pcb,err,ret)     \</span>
00337 <span class="preprocessor">                        if((pcb)-&gt;accept != NULL) \</span>
00338 <span class="preprocessor">                        (ret = (pcb)-&gt;accept((pcb)-&gt;callback_arg,(pcb),(err)))</span>
<a name="l00339"></a><a class="code" href="tcp_8h.html#a36">00339</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_EVENT_SENT(pcb,space,ret) \</span>
00340 <span class="preprocessor">                        if((pcb)-&gt;sent != NULL) \</span>
00341 <span class="preprocessor">                        (ret = (pcb)-&gt;sent((pcb)-&gt;callback_arg,(pcb),(space)))</span>
<a name="l00342"></a><a class="code" href="tcp_8h.html#a37">00342</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_EVENT_RECV(pcb,p,err,ret) \</span>
00343 <span class="preprocessor">                        if((pcb)-&gt;recv != NULL) \</span>
00344 <span class="preprocessor">                        { ret = (pcb)-&gt;recv((pcb)-&gt;callback_arg,(pcb),(p),(err)); } else { \</span>
00345 <span class="preprocessor">            pbuf_free(p); }</span>
<a name="l00346"></a><a class="code" href="tcp_8h.html#a38">00346</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_EVENT_CONNECTED(pcb,err,ret) \</span>
00347 <span class="preprocessor">                        if((pcb)-&gt;connected != NULL) \</span>
00348 <span class="preprocessor">                        (ret = (pcb)-&gt;connected((pcb)-&gt;callback_arg,(pcb),(err)))</span>
<a name="l00349"></a><a class="code" href="tcp_8h.html#a39">00349</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_EVENT_POLL(pcb,ret) \</span>
00350 <span class="preprocessor">                        if((pcb)-&gt;poll != NULL) \</span>
00351 <span class="preprocessor">                        (ret = (pcb)-&gt;poll((pcb)-&gt;callback_arg,(pcb)))</span>
<a name="l00352"></a><a class="code" href="tcp_8h.html#a40">00352</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_EVENT_ERR(errf,arg,err) \</span>
00353 <span class="preprocessor">                        if((errf) != NULL) \</span>
00354 <span class="preprocessor">                        (errf)((arg),(err))</span>
00355 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* LWIP_EVENT_API */</span>
00356 
00357 <span class="comment">/* This structure is used to repressent TCP segments when queued. */</span>
<a name="l00358"></a><a class="code" href="structtcp__seg.html">00358</a> <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> {
<a name="l00359"></a><a class="code" href="structtcp__seg.html#o0">00359</a>   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *<a class="code" href="structtcp__seg.html#o0">next</a>;    <span class="comment">/* used when putting segements on a queue */</span>
<a name="l00360"></a><a class="code" href="structtcp__seg.html#o1">00360</a>   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *<a class="code" href="structtcp__seg.html#o1">p</a>;          <span class="comment">/* buffer containing data + TCP header */</span>
<a name="l00361"></a><a class="code" href="structtcp__seg.html#o2">00361</a>   <span class="keywordtype">void</span> *<a class="code" href="structtcp__seg.html#o2">dataptr</a>;           <span class="comment">/* pointer to the TCP data in the pbuf */</span>
<a name="l00362"></a><a class="code" href="structtcp__seg.html#o3">00362</a>   u16_t <a class="code" href="structtcp__seg.html#o3">len</a>;               <span class="comment">/* the TCP length of this segment */</span>
<a name="l00363"></a><a class="code" href="structtcp__seg.html#o4">00363</a>   <span class="keyword">struct </span><a class="code" href="structtcp__hdr.html">tcp_hdr</a> *<a class="code" href="structtcphdr.html">tcphdr</a>;  <span class="comment">/* the TCP header */</span>
00364 };
00365 
00366 <span class="comment">/* Internal functions and global variables: */</span>
00367 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *<a class="code" href="tcp_8h.html#a87">tcp_pcb_copy</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
00368 <span class="keywordtype">void</span> <a class="code" href="tcp_8h.html#a88">tcp_pcb_purge</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
00369 <span class="keywordtype">void</span> <a class="code" href="tcp_8h.html#a89">tcp_pcb_remove</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> **pcblist, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
00370 
00371 u8_t <a class="code" href="tcp_8h.html#a90">tcp_segs_free</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a> *seg);
00372 u8_t <a class="code" href="tcp_8h.html#a91">tcp_seg_free</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a> *seg);
00373 <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *<a class="code" href="tcp_8h.html#a92">tcp_seg_copy</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a> *seg);
00374 
<a name="l00375"></a><a class="code" href="tcp_8h.html#a41">00375</a> <span class="preprocessor">#define tcp_ack(pcb)     if((pcb)-&gt;flags &amp; TF_ACK_DELAY) { \</span>
00376 <span class="preprocessor">                            (pcb)-&gt;flags &amp;= ~TF_ACK_DELAY; \</span>
00377 <span class="preprocessor">                            (pcb)-&gt;flags |= TF_ACK_NOW; \</span>
00378 <span class="preprocessor">                            tcp_output(pcb); \</span>
00379 <span class="preprocessor">                         } else { \</span>
00380 <span class="preprocessor">                            (pcb)-&gt;flags |= TF_ACK_DELAY; \</span>
00381 <span class="preprocessor">                         }</span>
00382 <span class="preprocessor"></span>
<a name="l00383"></a><a class="code" href="tcp_8h.html#a42">00383</a> <span class="preprocessor">#define tcp_ack_now(pcb) (pcb)-&gt;flags |= TF_ACK_NOW; \</span>
00384 <span class="preprocessor">                         tcp_output(pcb)</span>
00385 <span class="preprocessor"></span>
00386 <a class="code" href="err_8h.html#a13">err_t</a> <a class="code" href="tcp_8h.html#a93">tcp_send_ctrl</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t flags);
00387 <a class="code" href="err_8h.html#a13">err_t</a> <a class="code" href="tcp_8h.html#a94">tcp_enqueue</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keywordtype">void</span> *dataptr, u16_t len,
00388     u8_t flags, u8_t copy,
00389                 u8_t *optdata, u8_t optlen);
00390 
00391 <span class="keywordtype">void</span> <a class="code" href="tcp_8h.html#a95">tcp_rexmit_seg</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a> *seg);
00392 
00393 <span class="keywordtype">void</span> <a class="code" href="tcp_8h.html#a96">tcp_rst</a>(u32_t seqno, u32_t ackno,
00394        <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *local_ip, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *remote_ip,
00395        u16_t local_port, u16_t remote_port);
00396 
00397 u32_t <a class="code" href="tcp_8h.html#a97">tcp_next_iss</a>(<span class="keywordtype">void</span>);
00398 
<a name="l00399"></a><a class="code" href="tcp_8h.html#a47">00399</a> <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *<a class="code" href="tcp_8h.html#a47">tcp_input_pcb</a>;
<a name="l00400"></a><a class="code" href="tcp_8h.html#a48">00400</a> <span class="keyword">extern</span> u32_t <a class="code" href="tcp_8h.html#a48">tcp_ticks</a>;
00401 
00402 <span class="preprocessor">#if TCP_DEBUG || TCP_INPUT_DEBUG || TCP_OUTPUT_DEBUG</span>
00403 <span class="preprocessor"></span><span class="keywordtype">void</span> tcp_debug_print(<span class="keyword">struct</span> <a class="code" href="structtcp__hdr.html">tcp_hdr</a> *<a class="code" href="structtcphdr.html">tcphdr</a>);
00404 <span class="keywordtype">void</span> tcp_debug_print_flags(u8_t flags);
00405 <span class="keywordtype">void</span> tcp_debug_print_state(<span class="keyword">enum</span> tcp_state s);
00406 <span class="keywordtype">void</span> tcp_debug_print_pcbs(<span class="keywordtype">void</span>);
00407 <span class="keywordtype">int</span> <a class="code" href="tcp_8h.html#a43">tcp_pcbs_sane</a>(<span class="keywordtype">void</span>);
00408 <span class="preprocessor">#else</span>
<a name="l00409"></a><a class="code" href="tcp_8h.html#a43">00409</a> <span class="preprocessor"></span><span class="preprocessor">#define tcp_pcbs_sane() 1</span>
00410 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* TCP_DEBUG */</span>
00411 
00412 <span class="preprocessor">#if NO_SYS</span>
00413 <span class="preprocessor"></span><span class="preprocessor">#define tcp_timer_needed()</span>
00414 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00415 <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="tcp_8h.html#a98">tcp_timer_needed</a>(<span class="keywordtype">void</span>);
00416 <span class="preprocessor">#endif</span>
00417 <span class="preprocessor"></span>
00418 <span class="comment">/* The TCP PCB lists. */</span>
<a name="l00419"></a><a class="code" href="tcp_8h.html#a49">00419</a> <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *<a class="code" href="tcp_8h.html#a49">tcp_listen_pcbs</a>;  <span class="comment">/* List of all TCP PCBs in LISTEN state. */</span>
<a name="l00420"></a><a class="code" href="tcp_8h.html#a50">00420</a> <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *<a class="code" href="tcp_8h.html#a50">tcp_active_pcbs</a>;  <span class="comment">/* List of all TCP PCBs that are in a</span>
00421 <span class="comment">              state in which they accept or send</span>
00422 <span class="comment">              data. */</span>
<a name="l00423"></a><a class="code" href="tcp_8h.html#a51">00423</a> <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *<a class="code" href="tcp_8h.html#a51">tcp_tw_pcbs</a>;      <span class="comment">/* List of all TCP PCBs in TIME-WAIT. */</span>
00424 
<a name="l00425"></a><a class="code" href="tcp_8h.html#a52">00425</a> <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *<a class="code" href="tcp_8h.html#a52">tcp_tmp_pcb</a>;      <span class="comment">/* Only used for temporary storage. */</span>
00426 
00427 <span class="comment">/* Axioms about the above lists:   </span>
00428 <span class="comment">   1) Every TCP PCB that is not CLOSED is in one of the lists.</span>
00429 <span class="comment">   2) A PCB is only in one of the lists.</span>
00430 <span class="comment">   3) All PCBs in the tcp_listen_pcbs list is in LISTEN state.</span>
00431 <span class="comment">   4) All PCBs in the tcp_tw_pcbs list is in TIME-WAIT state.</span>
00432 <span class="comment">*/</span>
00433 
00434 <span class="comment">/* Define two macros, TCP_REG and TCP_RMV that registers a TCP PCB</span>
00435 <span class="comment">   with a PCB list or removes a PCB from a list, respectively. */</span>
00436 <span class="preprocessor">#if 0</span>
00437 <span class="preprocessor"></span><span class="preprocessor">#define TCP_REG(pcbs, npcb) do {\</span>
00438 <span class="preprocessor">                            LWIP_DEBUGF(TCP_DEBUG, ("TCP_REG %p local port %d\n", npcb, npcb-&gt;local_port)); \</span>
00439 <span class="preprocessor">                            for(tcp_tmp_pcb = *pcbs; \</span>
00440 <span class="preprocessor">          tcp_tmp_pcb != NULL; \</span>
00441 <span class="preprocessor">        tcp_tmp_pcb = tcp_tmp_pcb-&gt;next) { \</span>
00442 <span class="preprocessor">                                LWIP_ASSERT("TCP_REG: already registered\n", tcp_tmp_pcb != npcb); \</span>
00443 <span class="preprocessor">                            } \</span>
00444 <span class="preprocessor">                            LWIP_ASSERT("TCP_REG: pcb-&gt;state != CLOSED", npcb-&gt;state != CLOSED); \</span>
00445 <span class="preprocessor">                            npcb-&gt;next = *pcbs; \</span>
00446 <span class="preprocessor">                            LWIP_ASSERT("TCP_REG: npcb-&gt;next != npcb", npcb-&gt;next != npcb); \</span>
00447 <span class="preprocessor">                            *(pcbs) = npcb; \</span>
00448 <span class="preprocessor">                            LWIP_ASSERT("TCP_RMV: tcp_pcbs sane", tcp_pcbs_sane()); \</span>
00449 <span class="preprocessor">              tcp_timer_needed(); \</span>
00450 <span class="preprocessor">                            } while(0)</span>
00451 <span class="preprocessor"></span><span class="preprocessor">#define TCP_RMV(pcbs, npcb) do { \</span>
00452 <span class="preprocessor">                            LWIP_ASSERT("TCP_RMV: pcbs != NULL", *pcbs != NULL); \</span>
00453 <span class="preprocessor">                            LWIP_DEBUGF(TCP_DEBUG, ("TCP_RMV: removing %p from %p\n", npcb, *pcbs)); \</span>
00454 <span class="preprocessor">                            if(*pcbs == npcb) { \</span>
00455 <span class="preprocessor">                               *pcbs = (*pcbs)-&gt;next; \</span>
00456 <span class="preprocessor">                            } else for(tcp_tmp_pcb = *pcbs; tcp_tmp_pcb != NULL; tcp_tmp_pcb = tcp_tmp_pcb-&gt;next) { \</span>
00457 <span class="preprocessor">                               if(tcp_tmp_pcb-&gt;next != NULL &amp;&amp; tcp_tmp_pcb-&gt;next == npcb) { \</span>
00458 <span class="preprocessor">                                  tcp_tmp_pcb-&gt;next = npcb-&gt;next; \</span>
00459 <span class="preprocessor">                                  break; \</span>
00460 <span class="preprocessor">                               } \</span>
00461 <span class="preprocessor">                            } \</span>
00462 <span class="preprocessor">                            npcb-&gt;next = NULL; \</span>
00463 <span class="preprocessor">                            LWIP_ASSERT("TCP_RMV: tcp_pcbs sane", tcp_pcbs_sane()); \</span>
00464 <span class="preprocessor">                            LWIP_DEBUGF(TCP_DEBUG, ("TCP_RMV: removed %p from %p\n", npcb, *pcbs)); \</span>
00465 <span class="preprocessor">                            } while(0)</span>
00466 <span class="preprocessor"></span>
00467 <span class="preprocessor">#else </span><span class="comment">/* LWIP_DEBUG */</span>
<a name="l00468"></a><a class="code" href="tcp_8h.html#a44">00468</a> <span class="preprocessor">#define TCP_REG(pcbs, npcb) do { \</span>
00469 <span class="preprocessor">                            npcb-&gt;next = *pcbs; \</span>
00470 <span class="preprocessor">                            *(pcbs) = npcb; \</span>
00471 <span class="preprocessor">              tcp_timer_needed(); \</span>
00472 <span class="preprocessor">                            } while(0)</span>
<a name="l00473"></a><a class="code" href="tcp_8h.html#a45">00473</a> <span class="preprocessor"></span><span class="preprocessor">#define TCP_RMV(pcbs, npcb) do { \</span>
00474 <span class="preprocessor">                            if(*(pcbs) == npcb) { \</span>
00475 <span class="preprocessor">                               (*(pcbs)) = (*pcbs)-&gt;next; \</span>
00476 <span class="preprocessor">                            } else for(tcp_tmp_pcb = *pcbs; tcp_tmp_pcb != NULL; tcp_tmp_pcb = tcp_tmp_pcb-&gt;next) { \</span>
00477 <span class="preprocessor">                               if(tcp_tmp_pcb-&gt;next != NULL &amp;&amp; tcp_tmp_pcb-&gt;next == npcb) { \</span>
00478 <span class="preprocessor">                                  tcp_tmp_pcb-&gt;next = npcb-&gt;next; \</span>
00479 <span class="preprocessor">                                  break; \</span>
00480 <span class="preprocessor">                               } \</span>
00481 <span class="preprocessor">                            } \</span>
00482 <span class="preprocessor">                            npcb-&gt;next = NULL; \</span>
00483 <span class="preprocessor">                            } while(0)</span>
00484 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* LWIP_DEBUG */</span>
00485 <span class="preprocessor">#endif </span><span class="comment">/* __LWIP_TCP_H__ */</span>
00486 
00487 
00488 
</pre></div>	</td>
  </tr>
</table>
<hr>
<div align="center">Copyright (c) 2001-2003 Swedish Institute of Computer Science</div>
</html>
