
<html>
<head>
<title>lwIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="doxygen.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<table width="98%" border="0" align="center">
  <tr>
    <td>
      <h2>lwIP code documentation</h2>
<hr>

<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>vj.c</h1><a href="vj_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Routines to compress and uncompess tcp packets (for transmission</span>
00003 <span class="comment"> * over low speed serial lines.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * Copyright (c) 1989 Regents of the University of California.</span>
00006 <span class="comment"> * All rights reserved.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * Redistribution and use in source and binary forms are permitted</span>
00009 <span class="comment"> * provided that the above copyright notice and this paragraph are</span>
00010 <span class="comment"> * duplicated in all such forms and that any documentation,</span>
00011 <span class="comment"> * advertising materials, and other materials related to such</span>
00012 <span class="comment"> * distribution and use acknowledge that the software was developed</span>
00013 <span class="comment"> * by the University of California, Berkeley.  The name of the</span>
00014 <span class="comment"> * University may not be used to endorse or promote products derived</span>
00015 <span class="comment"> * from this software without specific prior written permission.</span>
00016 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR</span>
00017 <span class="comment"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
00018 <span class="comment"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
00019 <span class="comment"> *</span>
00020 <span class="comment"> *      Van Jacobson (van@helios.ee.lbl.gov), Dec 31, 1989:</span>
00021 <span class="comment"> *      - Initial distribution.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * Modified June 1993 by Paul Mackerras, paulus@cs.anu.edu.au,</span>
00024 <span class="comment"> * so that the entire packet being decompressed doesn't have</span>
00025 <span class="comment"> * to be in contiguous memory (just the compressed header).</span>
00026 <span class="comment"> *</span>
00027 <span class="comment"> * Modified March 1998 by Guy Lancaster, glanca@gesn.com,</span>
00028 <span class="comment"> * for a 16 bit processor.</span>
00029 <span class="comment"> */</span>
00030 
00031 <span class="preprocessor">#include "<a class="code" href="ppp_8h.html">ppp.h</a>"</span>
00032 <span class="preprocessor">#include "<a class="code" href="vj_8h.html">vj.h</a>"</span>
00033 <span class="preprocessor">#include "<a class="code" href="pppdebug_8h.html">pppdebug.h</a>"</span>
00034 
00035 
00036 <span class="preprocessor">#if VJ_SUPPORT &gt; 0</span>
00037 <span class="preprocessor"></span>
00038 <span class="preprocessor">#ifdef LINK_STATS</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define INCR(counter) ++comp-&gt;stats.counter</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define INCR(counter)</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00043 <span class="preprocessor"></span>
00044 <span class="preprocessor">#if defined(NO_CHAR_BITFIELDS)</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#define getip_hl(base)  ((base).ip_hl_v&amp;0xf)</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define getth_off(base) (((base).th_x2_off&amp;0xf0)&gt;&gt;4)</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#define getip_hl(base)  ((base).ip_hl)</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#define getth_off(base) ((base).th_off)</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00051 <span class="preprocessor"></span>
00052 <span class="keywordtype">void</span> <a class="code" href="vj_8h.html#a19">vj_compress_init</a>(<span class="keyword">struct</span> <a class="code" href="structvjcompress.html">vjcompress</a> *comp)
00053 {
00054         <span class="keyword">register</span> u_int i;
00055         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structcstate.html">cstate</a> *tstate = comp-&gt;<a class="code" href="structvjcompress.html#o6">tstate</a>;
00056         
00057 <span class="preprocessor">#if MAX_SLOTS == 0</span>
00058 <span class="preprocessor"></span>        memset((<span class="keywordtype">char</span> *)comp, 0, <span class="keyword">sizeof</span>(*comp));
00059 <span class="preprocessor">#endif</span>
00060 <span class="preprocessor"></span>        comp-&gt;maxSlotIndex = <a class="code" href="vj_8h.html#a0">MAX_SLOTS</a> - 1;
00061         comp-&gt;compressSlot = 0;         <span class="comment">/* Disable slot ID compression by default. */</span>
00062         <span class="keywordflow">for</span> (i = <a class="code" href="vj_8h.html#a0">MAX_SLOTS</a> - 1; i &gt; 0; --i) {
00063                 tstate[i].cs_id = i;
00064                 tstate[i].cs_next = &amp;tstate[i - 1];
00065         }
00066         tstate[0].cs_next = &amp;tstate[<a class="code" href="vj_8h.html#a0">MAX_SLOTS</a> - 1];
00067         tstate[0].cs_id = 0;
00068         comp-&gt;last_cs = &amp;tstate[0];
00069         comp-&gt;last_recv = 255;
00070         comp-&gt;last_xmit = 255;
00071         comp-&gt;flags = <a class="code" href="vj_8h.html#a18">VJF_TOSS</a>;
00072 }
00073 
00074 
00075 <span class="comment">/* ENCODE encodes a number that is known to be non-zero.  ENCODEZ</span>
00076 <span class="comment"> * checks for zero (since zero has to be encoded in the long, 3 byte</span>
00077 <span class="comment"> * form).</span>
00078 <span class="comment"> */</span>
00079 <span class="preprocessor">#define ENCODE(n) { \</span>
00080 <span class="preprocessor">        if ((u_short)(n) &gt;= 256) { \</span>
00081 <span class="preprocessor">                *cp++ = 0; \</span>
00082 <span class="preprocessor">                cp[1] = (n); \</span>
00083 <span class="preprocessor">                cp[0] = (n) &gt;&gt; 8; \</span>
00084 <span class="preprocessor">                cp += 2; \</span>
00085 <span class="preprocessor">        } else { \</span>
00086 <span class="preprocessor">                *cp++ = (n); \</span>
00087 <span class="preprocessor">        } \</span>
00088 <span class="preprocessor">}</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#define ENCODEZ(n) { \</span>
00090 <span class="preprocessor">        if ((u_short)(n) &gt;= 256 || (u_short)(n) == 0) { \</span>
00091 <span class="preprocessor">                *cp++ = 0; \</span>
00092 <span class="preprocessor">                cp[1] = (n); \</span>
00093 <span class="preprocessor">                cp[0] = (n) &gt;&gt; 8; \</span>
00094 <span class="preprocessor">                cp += 2; \</span>
00095 <span class="preprocessor">        } else { \</span>
00096 <span class="preprocessor">                *cp++ = (n); \</span>
00097 <span class="preprocessor">        } \</span>
00098 <span class="preprocessor">}</span>
00099 <span class="preprocessor"></span>
00100 <span class="preprocessor">#define DECODEL(f) { \</span>
00101 <span class="preprocessor">        if (*cp == 0) {\</span>
00102 <span class="preprocessor">                u32_t tmp = ntohl(f) + ((cp[1] &lt;&lt; 8) | cp[2]); \</span>
00103 <span class="preprocessor">                (f) = htonl(tmp); \</span>
00104 <span class="preprocessor">                cp += 3; \</span>
00105 <span class="preprocessor">        } else { \</span>
00106 <span class="preprocessor">                u32_t tmp = ntohl(f) + (u32_t)*cp++; \</span>
00107 <span class="preprocessor">                (f) = htonl(tmp); \</span>
00108 <span class="preprocessor">        } \</span>
00109 <span class="preprocessor">}</span>
00110 <span class="preprocessor"></span>
00111 <span class="preprocessor">#define DECODES(f) { \</span>
00112 <span class="preprocessor">        if (*cp == 0) {\</span>
00113 <span class="preprocessor">                u_short tmp = ntohs(f) + (((u_short)cp[1] &lt;&lt; 8) | cp[2]); \</span>
00114 <span class="preprocessor">                (f) = htons(tmp); \</span>
00115 <span class="preprocessor">                cp += 3; \</span>
00116 <span class="preprocessor">        } else { \</span>
00117 <span class="preprocessor">                u_short tmp = ntohs(f) + (u_short)*cp++; \</span>
00118 <span class="preprocessor">                (f) = htons(tmp); \</span>
00119 <span class="preprocessor">        } \</span>
00120 <span class="preprocessor">}</span>
00121 <span class="preprocessor"></span>
00122 <span class="preprocessor">#define DECODEU(f) { \</span>
00123 <span class="preprocessor">        if (*cp == 0) {\</span>
00124 <span class="preprocessor">                (f) = htons(((u_short)cp[1] &lt;&lt; 8) | cp[2]); \</span>
00125 <span class="preprocessor">                cp += 3; \</span>
00126 <span class="preprocessor">        } else { \</span>
00127 <span class="preprocessor">                (f) = htons((u_short)*cp++); \</span>
00128 <span class="preprocessor">        } \</span>
00129 <span class="preprocessor">}</span>
00130 <span class="preprocessor"></span>
00131 <span class="comment">/*</span>
00132 <span class="comment"> * vj_compress_tcp - Attempt to do Van Jacobsen header compression on a</span>
00133 <span class="comment"> * packet.  This assumes that nb and comp are not null and that the first</span>
00134 <span class="comment"> * buffer of the chain contains a valid IP header.</span>
00135 <span class="comment"> * Return the VJ type code indicating whether or not the packet was</span>
00136 <span class="comment"> * compressed.</span>
00137 <span class="comment"> */</span>
00138 u_int <a class="code" href="vj_8h.html#a20">vj_compress_tcp</a>(
00139         <span class="keyword">struct</span> <a class="code" href="structvjcompress.html">vjcompress</a> *comp,
00140         <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *pb
00141 )
00142 {
00143         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structip.html">ip</a> *<a class="code" href="structip.html">ip</a> = (<span class="keyword">struct </span><a class="code" href="structip.html">ip</a> *)pb-&gt;<a class="code" href="structpbuf.html#o1">payload</a>;
00144         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structcstate.html">cstate</a> *cs = comp-&gt;<a class="code" href="structvjcompress.html#o0">last_cs</a>-&gt;<a class="code" href="structcstate.html#o0">cs_next</a>;
00145         <span class="keyword">register</span> u_short hlen = getip_hl(*<a class="code" href="structip.html">ip</a>);
00146         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structtcphdr.html">tcphdr</a> *oth;
00147         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structtcphdr.html">tcphdr</a> *th;
00148         <span class="keyword">register</span> u_short deltaS, deltaA;
00149         <span class="keyword">register</span> u_long deltaL;
00150         <span class="keyword">register</span> u_int changes = 0;
00151         u_char new_seq[16];
00152         <span class="keyword">register</span> u_char *cp = new_seq;
00153 
00154         <span class="comment">/*      </span>
00155 <span class="comment">         * Check that the packet is IP proto TCP.</span>
00156 <span class="comment">         */</span>
00157         <span class="keywordflow">if</span> (<a class="code" href="structip.html">ip</a>-&gt;ip_p != <a class="code" href="sockets_8h.html#a28">IPPROTO_TCP</a>)
00158                 <span class="keywordflow">return</span> (<a class="code" href="vj_8h.html#a2">TYPE_IP</a>);
00159                 
00160         <span class="comment">/*</span>
00161 <span class="comment">         * Bail if this is an IP fragment or if the TCP packet isn't</span>
00162 <span class="comment">         * `compressible' (i.e., ACK isn't set or some other control bit is</span>
00163 <span class="comment">         * set).  </span>
00164 <span class="comment">         */</span>
00165         <span class="keywordflow">if</span> ((<a class="code" href="structip.html">ip</a>-&gt;ip_off &amp; <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(0x3fff)) || pb-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a> &lt; 40)
00166                 <span class="keywordflow">return</span> (<a class="code" href="vj_8h.html#a2">TYPE_IP</a>);
00167         th = (<span class="keyword">struct </span><a class="code" href="structtcphdr.html">tcphdr</a> *)&amp;((<span class="keywordtype">long</span> *)<a class="code" href="structip.html">ip</a>)[hlen];
00168         <span class="keywordflow">if</span> ((th-&gt;th_flags &amp; (<a class="code" href="tcp_8h.html#a10">TCP_SYN</a>|<a class="code" href="tcp_8h.html#a9">TCP_FIN</a>|<a class="code" href="tcp_8h.html#a11">TCP_RST</a>|<a class="code" href="tcp_8h.html#a13">TCP_ACK</a>)) != <a class="code" href="tcp_8h.html#a13">TCP_ACK</a>)
00169                 <span class="keywordflow">return</span> (<a class="code" href="vj_8h.html#a2">TYPE_IP</a>);
00170                 
00171         <span class="comment">/*</span>
00172 <span class="comment">         * Packet is compressible -- we're going to send either a</span>
00173 <span class="comment">         * COMPRESSED_TCP or UNCOMPRESSED_TCP packet.  Either way we need</span>
00174 <span class="comment">         * to locate (or create) the connection state.  Special case the</span>
00175 <span class="comment">         * most recently used connection since it's most likely to be used</span>
00176 <span class="comment">         * again &amp; we don't have to do any reordering if it's used.</span>
00177 <span class="comment">         */</span>
00178         INCR(vjs_packets);
00179         <span class="keywordflow">if</span> (<a class="code" href="structip.html">ip</a>-&gt;ip_src.s_addr != cs-&gt;cs_ip.ip_src.s_addr 
00180                         || <a class="code" href="structip.html">ip</a>-&gt;ip_dst.s_addr != cs-&gt;cs_ip.ip_dst.s_addr 
00181                         || *(<span class="keywordtype">long</span> *)th != ((<span class="keywordtype">long</span> *)&amp;cs-&gt;cs_ip)[getip_hl(cs-&gt;cs_ip)]) {
00182                 <span class="comment">/*</span>
00183 <span class="comment">                 * Wasn't the first -- search for it.</span>
00184 <span class="comment">                 *</span>
00185 <span class="comment">                 * States are kept in a circularly linked list with</span>
00186 <span class="comment">                 * last_cs pointing to the end of the list.  The</span>
00187 <span class="comment">                 * list is kept in lru order by moving a state to the</span>
00188 <span class="comment">                 * head of the list whenever it is referenced.  Since</span>
00189 <span class="comment">                 * the list is short and, empirically, the connection</span>
00190 <span class="comment">                 * we want is almost always near the front, we locate</span>
00191 <span class="comment">                 * states via linear search.  If we don't find a state</span>
00192 <span class="comment">                 * for the datagram, the oldest state is (re-)used.</span>
00193 <span class="comment">                 */</span>
00194                 <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structcstate.html">cstate</a> *lcs;
00195                 <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structcstate.html">cstate</a> *lastcs = comp-&gt;<a class="code" href="structvjcompress.html#o0">last_cs</a>;
00196                 
00197                 <span class="keywordflow">do</span> {
00198                         lcs = cs; cs = cs-&gt;<a class="code" href="structcstate.html#o0">cs_next</a>;
00199                         INCR(vjs_searches);
00200                         <span class="keywordflow">if</span> (<a class="code" href="structip.html">ip</a>-&gt;ip_src.s_addr == cs-&gt;cs_ip.ip_src.s_addr
00201                                         &amp;&amp; <a class="code" href="structip.html">ip</a>-&gt;ip_dst.s_addr == cs-&gt;cs_ip.ip_dst.s_addr
00202                                         &amp;&amp; *(<span class="keywordtype">long</span> *)th == ((<span class="keywordtype">long</span> *)&amp;cs-&gt;cs_ip)[getip_hl(cs-&gt;cs_ip)])
00203                                 <span class="keywordflow">goto</span> found;
00204                 } <span class="keywordflow">while</span> (cs != lastcs);
00205                 
00206                 <span class="comment">/*</span>
00207 <span class="comment">                 * Didn't find it -- re-use oldest cstate.  Send an</span>
00208 <span class="comment">                 * uncompressed packet that tells the other side what</span>
00209 <span class="comment">                 * connection number we're using for this conversation.</span>
00210 <span class="comment">                 * Note that since the state list is circular, the oldest</span>
00211 <span class="comment">                 * state points to the newest and we only need to set</span>
00212 <span class="comment">                 * last_cs to update the lru linkage.</span>
00213 <span class="comment">                 */</span>
00214                 INCR(vjs_misses);
00215                 comp-&gt;<a class="code" href="structvjcompress.html#o0">last_cs</a> = lcs;
00216                 hlen += getth_off(*th);
00217                 hlen &lt;&lt;= 2;
00218                 <span class="comment">/* Check that the IP/TCP headers are contained in the first buffer. */</span>
00219                 <span class="keywordflow">if</span> (hlen &gt; pb-&gt;<a class="code" href="structpbuf.html#o3">len</a>)
00220                         <span class="keywordflow">return</span> (<a class="code" href="vj_8h.html#a2">TYPE_IP</a>);
00221                 <span class="keywordflow">goto</span> uncompressed;
00222                 
00223                 found:
00224                 <span class="comment">/*</span>
00225 <span class="comment">                 * Found it -- move to the front on the connection list.</span>
00226 <span class="comment">                 */</span>
00227                 <span class="keywordflow">if</span> (cs == lastcs)
00228                         comp-&gt;<a class="code" href="structvjcompress.html#o0">last_cs</a> = lcs;
00229                 <span class="keywordflow">else</span> {
00230                         lcs-&gt;<a class="code" href="structcstate.html#o0">cs_next</a> = cs-&gt;<a class="code" href="structcstate.html#o0">cs_next</a>;
00231                         cs-&gt;<a class="code" href="structcstate.html#o0">cs_next</a> = lastcs-&gt;<a class="code" href="structcstate.html#o0">cs_next</a>;
00232                         lastcs-&gt;<a class="code" href="structcstate.html#o0">cs_next</a> = cs;
00233                 }
00234         }
00235         
00236         oth = (<span class="keyword">struct </span><a class="code" href="structtcphdr.html">tcphdr</a> *)&amp;((<span class="keywordtype">long</span> *)&amp;cs-&gt;cs_ip)[hlen];
00237         deltaS = hlen;
00238         hlen += getth_off(*th);
00239         hlen &lt;&lt;= 2;
00240         <span class="comment">/* Check that the IP/TCP headers are contained in the first buffer. */</span>
00241         <span class="keywordflow">if</span> (hlen &gt; pb-&gt;<a class="code" href="structpbuf.html#o3">len</a>) {
00242                 <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"vj_compress_tcp: header len %d spans buffers\n"</span>, 
00243                                         hlen));
00244                 <span class="keywordflow">return</span> (<a class="code" href="vj_8h.html#a2">TYPE_IP</a>);
00245         }
00246         
00247         <span class="comment">/*</span>
00248 <span class="comment">         * Make sure that only what we expect to change changed. The first</span>
00249 <span class="comment">         * line of the `if' checks the IP protocol version, header length &amp;</span>
00250 <span class="comment">         * type of service.  The 2nd line checks the "Don't fragment" bit.</span>
00251 <span class="comment">         * The 3rd line checks the time-to-live and protocol (the protocol</span>
00252 <span class="comment">         * check is unnecessary but costless).  The 4th line checks the TCP</span>
00253 <span class="comment">         * header length.  The 5th line checks IP options, if any.  The 6th</span>
00254 <span class="comment">         * line checks TCP options, if any.  If any of these things are</span>
00255 <span class="comment">         * different between the previous &amp; current datagram, we send the</span>
00256 <span class="comment">         * current datagram `uncompressed'.</span>
00257 <span class="comment">         */</span>
00258         <span class="keywordflow">if</span> (((u_short *)<a class="code" href="structip.html">ip</a>)[0] != ((u_short *)&amp;cs-&gt;cs_ip)[0] 
00259                         || ((u_short *)<a class="code" href="structip.html">ip</a>)[3] != ((u_short *)&amp;cs-&gt;cs_ip)[3] 
00260                         || ((u_short *)<a class="code" href="structip.html">ip</a>)[4] != ((u_short *)&amp;cs-&gt;cs_ip)[4] 
00261                         || getth_off(*th) != getth_off(*oth) 
00262                         || (deltaS &gt; 5 &amp;&amp; BCMP(<a class="code" href="structip.html">ip</a> + 1, &amp;cs-&gt;cs_ip + 1, (deltaS - 5) &lt;&lt; 2)) 
00263                         || (getth_off(*th) &gt; 5 &amp;&amp; BCMP(th + 1, oth + 1, (getth_off(*th) - 5) &lt;&lt; 2)))
00264                 <span class="keywordflow">goto</span> uncompressed;
00265         
00266         <span class="comment">/*</span>
00267 <span class="comment">         * Figure out which of the changing fields changed.  The</span>
00268 <span class="comment">         * receiver expects changes in the order: urgent, window,</span>
00269 <span class="comment">         * ack, seq (the order minimizes the number of temporaries</span>
00270 <span class="comment">         * needed in this section of code).</span>
00271 <span class="comment">         */</span>
00272         <span class="keywordflow">if</span> (th-&gt;th_flags &amp; <a class="code" href="tcp_8h.html#a14">TCP_URG</a>) {
00273                 deltaS = <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(th-&gt;th_urp);
00274                 ENCODEZ(deltaS);
00275                 changes |= <a class="code" href="vj_8h.html#a11">NEW_U</a>;
00276         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (th-&gt;th_urp != oth-&gt;th_urp)
00277                 <span class="comment">/* argh! URG not set but urp changed -- a sensible</span>
00278 <span class="comment">                 * implementation should never do this but RFC793</span>
00279 <span class="comment">                 * doesn't prohibit the change so we have to deal</span>
00280 <span class="comment">                 * with it. */</span>
00281                 <span class="keywordflow">goto</span> uncompressed;
00282         
00283         <span class="keywordflow">if</span> ((deltaS = (u_short)(<a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(th-&gt;th_win) - <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(oth-&gt;th_win))) != 0) {
00284                 ENCODE(deltaS);
00285                 changes |= <a class="code" href="vj_8h.html#a10">NEW_W</a>;
00286         }
00287         
00288         <span class="keywordflow">if</span> ((deltaL = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(th-&gt;th_ack) - <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(oth-&gt;th_ack)) != 0) {
00289                 <span class="keywordflow">if</span> (deltaL &gt; 0xffff)
00290                         <span class="keywordflow">goto</span> uncompressed;
00291                 deltaA = (u_short)deltaL;
00292                 ENCODE(deltaA);
00293                 changes |= <a class="code" href="vj_8h.html#a9">NEW_A</a>;
00294         }
00295         
00296         <span class="keywordflow">if</span> ((deltaL = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(th-&gt;th_seq) - <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(oth-&gt;th_seq)) != 0) {
00297                 <span class="keywordflow">if</span> (deltaL &gt; 0xffff)
00298                         <span class="keywordflow">goto</span> uncompressed;
00299                 deltaS = (u_short)deltaL;
00300                 ENCODE(deltaS);
00301                 changes |= <a class="code" href="vj_8h.html#a8">NEW_S</a>;
00302         }
00303         
00304         <span class="keywordflow">switch</span>(changes) {
00305         
00306         <span class="keywordflow">case</span> 0:
00307                 <span class="comment">/*</span>
00308 <span class="comment">                 * Nothing changed. If this packet contains data and the</span>
00309 <span class="comment">                 * last one didn't, this is probably a data packet following</span>
00310 <span class="comment">                 * an ack (normal on an interactive connection) and we send</span>
00311 <span class="comment">                 * it compressed.  Otherwise it's probably a retransmit,</span>
00312 <span class="comment">                 * retransmitted ack or window probe.  Send it uncompressed</span>
00313 <span class="comment">                 * in case the other side missed the compressed version.</span>
00314 <span class="comment">                 */</span>
00315                 <span class="keywordflow">if</span> (<a class="code" href="structip.html">ip</a>-&gt;ip_len != cs-&gt;cs_ip.ip_len &amp;&amp;
00316                         <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(cs-&gt;cs_ip.ip_len) == hlen)
00317                 <span class="keywordflow">break</span>;
00318         
00319         <span class="comment">/* (fall through) */</span>
00320         
00321         <span class="keywordflow">case</span> <a class="code" href="vj_8h.html#a12">SPECIAL_I</a>:
00322         <span class="keywordflow">case</span> <a class="code" href="vj_8h.html#a13">SPECIAL_D</a>:
00323                 <span class="comment">/*</span>
00324 <span class="comment">                 * actual changes match one of our special case encodings --</span>
00325 <span class="comment">                 * send packet uncompressed.</span>
00326 <span class="comment">                 */</span>
00327                 <span class="keywordflow">goto</span> uncompressed;
00328         
00329         <span class="keywordflow">case</span> <a class="code" href="vj_8h.html#a8">NEW_S</a>|<a class="code" href="vj_8h.html#a9">NEW_A</a>:
00330                 <span class="keywordflow">if</span> (deltaS == deltaA &amp;&amp; deltaS == <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(cs-&gt;cs_ip.ip_len) - hlen) {
00331                         <span class="comment">/* special case for echoed terminal traffic */</span>
00332                         changes = <a class="code" href="vj_8h.html#a12">SPECIAL_I</a>;
00333                         cp = new_seq;
00334                 }
00335                 <span class="keywordflow">break</span>;
00336         
00337         <span class="keywordflow">case</span> <a class="code" href="vj_8h.html#a8">NEW_S</a>:
00338                 <span class="keywordflow">if</span> (deltaS == <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(cs-&gt;cs_ip.ip_len) - hlen) {
00339                         <span class="comment">/* special case for data xfer */</span>
00340                         changes = <a class="code" href="vj_8h.html#a13">SPECIAL_D</a>;
00341                         cp = new_seq;
00342                 }
00343                 <span class="keywordflow">break</span>;
00344         }
00345         
00346         deltaS = (u_short)(<a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(<a class="code" href="structip.html">ip</a>-&gt;ip_id) - <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(cs-&gt;cs_ip.ip_id));
00347         <span class="keywordflow">if</span> (deltaS != 1) {
00348                 ENCODEZ(deltaS);
00349                 changes |= <a class="code" href="vj_8h.html#a7">NEW_I</a>;
00350         }
00351         <span class="keywordflow">if</span> (th-&gt;th_flags &amp; <a class="code" href="tcp_8h.html#a12">TCP_PSH</a>)
00352         changes |= <a class="code" href="vj_8h.html#a15">TCP_PUSH_BIT</a>;
00353         <span class="comment">/*</span>
00354 <span class="comment">         * Grab the cksum before we overwrite it below.  Then update our</span>
00355 <span class="comment">         * state with this packet's header.</span>
00356 <span class="comment">         */</span>
00357         deltaA = <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(th-&gt;th_sum);
00358         BCOPY(<a class="code" href="structip.html">ip</a>, &amp;cs-&gt;cs_ip, hlen);
00359         
00360         <span class="comment">/*</span>
00361 <span class="comment">         * We want to use the original packet as our compressed packet.</span>
00362 <span class="comment">         * (cp - new_seq) is the number of bytes we need for compressed</span>
00363 <span class="comment">         * sequence numbers.  In addition we need one byte for the change</span>
00364 <span class="comment">         * mask, one for the connection id and two for the tcp checksum.</span>
00365 <span class="comment">         * So, (cp - new_seq) + 4 bytes of header are needed.  hlen is how</span>
00366 <span class="comment">         * many bytes of the original packet to toss so subtract the two to</span>
00367 <span class="comment">         * get the new packet size.</span>
00368 <span class="comment">         */</span>
00369         deltaS = (u_short)(cp - new_seq);
00370         <span class="keywordflow">if</span> (!comp-&gt;<a class="code" href="structvjcompress.html#o5">compressSlot</a> || comp-&gt;<a class="code" href="structvjcompress.html#o2">last_xmit</a> != cs-&gt;cs_id) {
00371                 comp-&gt;<a class="code" href="structvjcompress.html#o2">last_xmit</a> = cs-&gt;cs_id;
00372                 hlen -= deltaS + 4;
00373                 <a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(pb, -hlen);
00374                 cp = (u_char *)pb-&gt;<a class="code" href="structpbuf.html#o1">payload</a>;
00375                 *cp++ = changes | <a class="code" href="vj_8h.html#a6">NEW_C</a>;
00376                 *cp++ = cs-&gt;cs_id;
00377         } <span class="keywordflow">else</span> {
00378                 hlen -= deltaS + 3;
00379                 <a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(pb, -hlen);
00380                 cp = (u_char *)pb-&gt;<a class="code" href="structpbuf.html#o1">payload</a>;
00381                 *cp++ = changes;
00382         }
00383         *cp++ = deltaA &gt;&gt; 8;
00384         *cp++ = deltaA;
00385         BCOPY(new_seq, cp, deltaS);
00386         INCR(vjs_compressed);
00387         <span class="keywordflow">return</span> (<a class="code" href="vj_8h.html#a4">TYPE_COMPRESSED_TCP</a>);
00388 
00389         <span class="comment">/*</span>
00390 <span class="comment">         * Update connection state cs &amp; send uncompressed packet (that is,</span>
00391 <span class="comment">         * a regular ip/tcp packet but with the 'conversation id' we hope</span>
00392 <span class="comment">         * to use on future compressed packets in the protocol field).</span>
00393 <span class="comment">         */</span>
00394 uncompressed:
00395         BCOPY(<a class="code" href="structip.html">ip</a>, &amp;cs-&gt;cs_ip, hlen);
00396         <a class="code" href="structip.html">ip</a>-&gt;ip_p = cs-&gt;cs_id;
00397         comp-&gt;<a class="code" href="structvjcompress.html#o2">last_xmit</a> = cs-&gt;cs_id;
00398         <span class="keywordflow">return</span> (<a class="code" href="vj_8h.html#a3">TYPE_UNCOMPRESSED_TCP</a>);
00399 }
00400 
00401 <span class="comment">/*</span>
00402 <span class="comment"> * Called when we may have missed a packet.</span>
00403 <span class="comment"> */</span>
00404 <span class="keywordtype">void</span> <a class="code" href="vj_8h.html#a21">vj_uncompress_err</a>(<span class="keyword">struct</span> <a class="code" href="structvjcompress.html">vjcompress</a> *comp)
00405 {
00406     comp-&gt;<a class="code" href="structvjcompress.html#o3">flags</a> |= <a class="code" href="vj_8h.html#a18">VJF_TOSS</a>;
00407         INCR(vjs_errorin);
00408 }
00409 
00410 <span class="comment">/*</span>
00411 <span class="comment"> * "Uncompress" a packet of type TYPE_UNCOMPRESSED_TCP.</span>
00412 <span class="comment"> * Return 0 on success, -1 on failure.</span>
00413 <span class="comment"> */</span>
00414 <span class="keywordtype">int</span> <a class="code" href="vj_8h.html#a22">vj_uncompress_uncomp</a>(
00415         <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *nb,
00416         <span class="keyword">struct</span> <a class="code" href="structvjcompress.html">vjcompress</a> *comp
00417 )
00418 {
00419         <span class="keyword">register</span> u_int hlen;
00420         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structcstate.html">cstate</a> *cs;
00421         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structip.html">ip</a> *<a class="code" href="structip.html">ip</a>;
00422         
00423         <a class="code" href="structip.html">ip</a> = (<span class="keyword">struct </span><a class="code" href="structip.html">ip</a> *)nb-&gt;<a class="code" href="structpbuf.html#o1">payload</a>;
00424         hlen = getip_hl(*<a class="code" href="structip.html">ip</a>) &lt;&lt; 2;
00425         <span class="keywordflow">if</span> (<a class="code" href="structip.html">ip</a>-&gt;ip_p &gt;= <a class="code" href="vj_8h.html#a0">MAX_SLOTS</a>
00426                         || hlen + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structtcphdr.html">tcphdr</a>) &gt; nb-&gt;len
00427                         || (hlen += getth_off(*((<span class="keyword">struct</span> <a class="code" href="structtcphdr.html">tcphdr</a> *)&amp;((<span class="keywordtype">char</span> *)<a class="code" href="structip.html">ip</a>)[hlen])) &lt;&lt; 2)
00428                             &gt; nb-&gt;len
00429                         || hlen &gt; <a class="code" href="vj_8h.html#a1">MAX_HDR</a>) {
00430                 <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"vj_uncompress_uncomp: bad cid=%d, hlen=%d buflen=%d\n"</span>, 
00431                                         <a class="code" href="structip.html">ip</a>-&gt;ip_p, hlen, nb-&gt;len));
00432                 comp-&gt;<a class="code" href="structvjcompress.html#o3">flags</a> |= <a class="code" href="vj_8h.html#a18">VJF_TOSS</a>;
00433                 INCR(vjs_errorin);
00434                 <span class="keywordflow">return</span> -1;
00435         }
00436         cs = &amp;comp-&gt;<a class="code" href="structvjcompress.html#o7">rstate</a>[comp-&gt;<a class="code" href="structvjcompress.html#o1">last_recv</a> = <a class="code" href="structip.html">ip</a>-&gt;ip_p];
00437         comp-&gt;<a class="code" href="structvjcompress.html#o3">flags</a> &amp;=~ VJF_TOSS;
00438         <a class="code" href="structip.html">ip</a>-&gt;ip_p = <a class="code" href="sockets_8h.html#a28">IPPROTO_TCP</a>;
00439         BCOPY(<a class="code" href="structip.html">ip</a>, &amp;cs-&gt;cs_ip, hlen);
00440         cs-&gt;cs_hlen = hlen;
00441         INCR(vjs_uncompressedin);
00442         <span class="keywordflow">return</span> 0;
00443 }
00444 
00445 <span class="comment">/*</span>
00446 <span class="comment"> * Uncompress a packet of type TYPE_COMPRESSED_TCP.</span>
00447 <span class="comment"> * The packet is composed of a buffer chain and the first buffer</span>
00448 <span class="comment"> * must contain an accurate chain length.</span>
00449 <span class="comment"> * The first buffer must include the entire compressed TCP/IP header. </span>
00450 <span class="comment"> * This procedure replaces the compressed header with the uncompressed</span>
00451 <span class="comment"> * header and returns the length of the VJ header.</span>
00452 <span class="comment"> */</span>
00453 <span class="keywordtype">int</span> <a class="code" href="vj_8h.html#a23">vj_uncompress_tcp</a>(
00454         <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> **nb,
00455         <span class="keyword">struct</span> <a class="code" href="structvjcompress.html">vjcompress</a> *comp
00456 )
00457 {
00458         u_char *cp;
00459         <span class="keyword">struct </span><a class="code" href="structtcphdr.html">tcphdr</a> *th;
00460         <span class="keyword">struct </span><a class="code" href="structcstate.html">cstate</a> *cs;
00461         u_short *bp;
00462         <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *n0 = *nb;
00463         u32_t tmp;
00464         u_int vjlen, hlen, changes;
00465         
00466         INCR(vjs_compressedin);
00467         cp = (u_char *)n0-&gt;payload;
00468         changes = *cp++;
00469         <span class="keywordflow">if</span> (changes &amp; <a class="code" href="vj_8h.html#a6">NEW_C</a>) {
00470                 <span class="comment">/* </span>
00471 <span class="comment">                 * Make sure the state index is in range, then grab the state.</span>
00472 <span class="comment">                 * If we have a good state index, clear the 'discard' flag. </span>
00473 <span class="comment">                 */</span>
00474                 <span class="keywordflow">if</span> (*cp &gt;= <a class="code" href="vj_8h.html#a0">MAX_SLOTS</a>) {
00475                         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"vj_uncompress_tcp: bad cid=%d\n"</span>, *cp));
00476                         <span class="keywordflow">goto</span> bad;
00477                 }
00478                 
00479                 comp-&gt;<a class="code" href="structvjcompress.html#o3">flags</a> &amp;=~ VJF_TOSS;
00480                 comp-&gt;<a class="code" href="structvjcompress.html#o1">last_recv</a> = *cp++;
00481         } <span class="keywordflow">else</span> {
00482                 <span class="comment">/* </span>
00483 <span class="comment">                 * this packet has an implicit state index.  If we've</span>
00484 <span class="comment">                 * had a line error since the last time we got an</span>
00485 <span class="comment">                 * explicit state index, we have to toss the packet. </span>
00486 <span class="comment">                 */</span>
00487                 <span class="keywordflow">if</span> (comp-&gt;<a class="code" href="structvjcompress.html#o3">flags</a> &amp; <a class="code" href="vj_8h.html#a18">VJF_TOSS</a>) {
00488                         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"vj_uncompress_tcp: tossing\n"</span>));
00489                         INCR(vjs_tossed);
00490                         <span class="keywordflow">return</span> (-1);
00491                 }
00492         }
00493         cs = &amp;comp-&gt;<a class="code" href="structvjcompress.html#o7">rstate</a>[comp-&gt;<a class="code" href="structvjcompress.html#o1">last_recv</a>];
00494         hlen = getip_hl(cs-&gt;cs_ip) &lt;&lt; 2;
00495         th = (<span class="keyword">struct </span><a class="code" href="structtcphdr.html">tcphdr</a> *)&amp;((u_char *)&amp;cs-&gt;cs_ip)[hlen];
00496         th-&gt;th_sum = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>((*cp &lt;&lt; 8) | cp[1]);
00497         cp += 2;
00498         <span class="keywordflow">if</span> (changes &amp; <a class="code" href="vj_8h.html#a15">TCP_PUSH_BIT</a>)
00499                 th-&gt;th_flags |= <a class="code" href="tcp_8h.html#a12">TCP_PSH</a>;
00500         <span class="keywordflow">else</span>
00501                 th-&gt;th_flags &amp;=~ TCP_PSH;
00502         
00503         <span class="keywordflow">switch</span> (changes &amp; <a class="code" href="vj_8h.html#a14">SPECIALS_MASK</a>) {
00504         <span class="keywordflow">case</span> <a class="code" href="vj_8h.html#a12">SPECIAL_I</a>:
00505                 {
00506                         <span class="keyword">register</span> u32_t i = <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(cs-&gt;cs_ip.ip_len) - cs-&gt;cs_hlen;
00507                         <span class="comment">/* some compilers can't nest inline assembler.. */</span>
00508                         tmp = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(th-&gt;th_ack) + i;
00509                         th-&gt;th_ack = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(tmp);
00510                         tmp = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(th-&gt;th_seq) + i;
00511                         th-&gt;th_seq = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(tmp);
00512                 }
00513                 <span class="keywordflow">break</span>;
00514         
00515         <span class="keywordflow">case</span> <a class="code" href="vj_8h.html#a13">SPECIAL_D</a>:
00516                 <span class="comment">/* some compilers can't nest inline assembler.. */</span>
00517                 tmp = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(th-&gt;th_seq) + <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(cs-&gt;cs_ip.ip_len) - cs-&gt;cs_hlen;
00518                 th-&gt;th_seq = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(tmp);
00519                 <span class="keywordflow">break</span>;
00520         
00521         <span class="keywordflow">default</span>:
00522                 <span class="keywordflow">if</span> (changes &amp; <a class="code" href="vj_8h.html#a11">NEW_U</a>) {
00523                         th-&gt;th_flags |= <a class="code" href="tcp_8h.html#a14">TCP_URG</a>;
00524                         DECODEU(th-&gt;th_urp);
00525                 } <span class="keywordflow">else</span>
00526                         th-&gt;th_flags &amp;=~ TCP_URG;
00527                 <span class="keywordflow">if</span> (changes &amp; <a class="code" href="vj_8h.html#a10">NEW_W</a>)
00528                         DECODES(th-&gt;th_win);
00529                 <span class="keywordflow">if</span> (changes &amp; <a class="code" href="vj_8h.html#a9">NEW_A</a>)
00530                         DECODEL(th-&gt;th_ack);
00531                 <span class="keywordflow">if</span> (changes &amp; <a class="code" href="vj_8h.html#a8">NEW_S</a>)
00532                         DECODEL(th-&gt;th_seq);
00533                 <span class="keywordflow">break</span>;
00534         }
00535         <span class="keywordflow">if</span> (changes &amp; <a class="code" href="vj_8h.html#a7">NEW_I</a>) {
00536                 DECODES(cs-&gt;cs_ip.ip_id);
00537         } <span class="keywordflow">else</span> {
00538                 cs-&gt;cs_ip.ip_id = <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(cs-&gt;cs_ip.ip_id) + 1;
00539                 cs-&gt;cs_ip.ip_id = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(cs-&gt;cs_ip.ip_id);
00540         }
00541         
00542         <span class="comment">/*</span>
00543 <span class="comment">         * At this point, cp points to the first byte of data in the</span>
00544 <span class="comment">         * packet.  Fill in the IP total length and update the IP</span>
00545 <span class="comment">         * header checksum.</span>
00546 <span class="comment">         */</span>
00547         vjlen = (u_short)(cp - (u_char*)n0-&gt;payload);
00548         <span class="keywordflow">if</span> (n0-&gt;len &lt; vjlen) {
00549                 <span class="comment">/* </span>
00550 <span class="comment">                 * We must have dropped some characters (crc should detect</span>
00551 <span class="comment">                 * this but the old slip framing won't) </span>
00552 <span class="comment">                 */</span>
00553                 <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"vj_uncompress_tcp: head buffer %d too short %d\n"</span>, 
00554                                   n0-&gt;len, vjlen));
00555                 <span class="keywordflow">goto</span> bad;
00556         }
00557         
00558 <span class="preprocessor">#if BYTE_ORDER == LITTLE_ENDIAN</span>
00559 <span class="preprocessor"></span>        tmp = n0-&gt;tot_len - vjlen + cs-&gt;cs_hlen;
00560         cs-&gt;cs_ip.ip_len = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(tmp);
00561 <span class="preprocessor">#else</span>
00562 <span class="preprocessor"></span>        cs-&gt;cs_ip.ip_len = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(n0-&gt;tot_len - vjlen + cs-&gt;cs_hlen);
00563 <span class="preprocessor">#endif</span>
00564 <span class="preprocessor"></span>        
00565         <span class="comment">/* recompute the ip header checksum */</span>
00566         bp = (u_short *) &amp;cs-&gt;cs_ip;
00567         cs-&gt;cs_ip.ip_sum = 0;
00568         <span class="keywordflow">for</span> (tmp = 0; hlen &gt; 0; hlen -= 2)
00569                 tmp += *bp++;
00570         tmp = (tmp &amp; 0xffff) + (tmp &gt;&gt; 16);
00571         tmp = (tmp &amp; 0xffff) + (tmp &gt;&gt; 16);
00572         cs-&gt;cs_ip.ip_sum = (u_short)(~tmp);
00573         
00574         <span class="comment">/* Remove the compressed header and prepend the uncompressed header. */</span>
00575         <a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(n0, -vjlen);
00576 
00577         <span class="keywordflow">if</span>(<a class="code" href="mem_8h.html#a1">MEM_ALIGN</a>(n0-&gt;payload) != n0-&gt;payload) {
00578                 <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *np, *q;
00579                 u8_t *bufptr;
00580 
00581                 np = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(PBUF_RAW, n0-&gt;len + cs-&gt;cs_hlen, PBUF_POOL);
00582                 <span class="keywordflow">if</span>(!np) {
00583                         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"vj_uncompress_tcp: realign failed\n"</span>));
00584                         *nb = <a class="code" href="def_8h.html#a2">NULL</a>;
00585                         <span class="keywordflow">goto</span> bad;
00586                 }
00587 
00588                 <a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(np, -cs-&gt;cs_hlen);
00589 
00590                 bufptr = n0-&gt;payload;
00591                 <span class="keywordflow">for</span>(q = np; q != <a class="code" href="def_8h.html#a2">NULL</a>; q = q-&gt;next) {
00592                         memcpy(q-&gt;payload, bufptr, q-&gt;len);
00593                         bufptr += q-&gt;len;
00594                 }
00595 
00596                 <span class="keywordflow">if</span>(n0-&gt;next) {
00597                         <a class="code" href="pbuf_8c.html#a17">pbuf_chain</a>(np, n0-&gt;next);
00598                         <a class="code" href="pbuf_8c.html#a19">pbuf_dechain</a>(n0);
00599                 }
00600                 <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(n0);
00601                 n0 = np;
00602         }
00603 
00604         <span class="keywordflow">if</span>(<a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(n0, cs-&gt;cs_hlen)) {
00605                 <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *np;
00606 
00607                 <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"vj_uncompress_tcp: cs-&gt;cs_hlen &lt;= PBUF_POOL_BUFSIZE"</span>, cs-&gt;cs_hlen &lt;= PBUF_POOL_BUFSIZE);
00608                 np = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(PBUF_RAW, cs-&gt;cs_hlen, PBUF_POOL);
00609                 <span class="keywordflow">if</span>(!np) {
00610                         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"vj_uncompress_tcp: prepend failed\n"</span>));
00611                         *nb = <a class="code" href="def_8h.html#a2">NULL</a>;
00612                         <span class="keywordflow">goto</span> bad;
00613                 }
00614                 <a class="code" href="pbuf_8c.html#a17">pbuf_chain</a>(np, n0);
00615                 <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(n0);
00616                 n0 = np;
00617         }
00618         <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"n0-&gt;len &gt;= cs-&gt;cs_hlen"</span>, n0-&gt;len &gt;= cs-&gt;cs_hlen);
00619         memcpy(n0-&gt;payload, &amp;cs-&gt;cs_ip, cs-&gt;cs_hlen);
00620 
00621         *nb = n0;
00622 
00623         <span class="keywordflow">return</span> vjlen;
00624         
00625 bad:
00626         comp-&gt;<a class="code" href="structvjcompress.html#o3">flags</a> |= <a class="code" href="vj_8h.html#a18">VJF_TOSS</a>;
00627         INCR(vjs_errorin);
00628         <span class="keywordflow">return</span> (-1);
00629 }
00630 
00631 <span class="preprocessor">#endif</span>
00632 <span class="preprocessor"></span>
00633 
</pre></div>	</td>
  </tr>
</table>
<hr>
<div align="center">Copyright (c) 2001-2003 Swedish Institute of Computer Science</div>
</html>
