
<html>
<head>
<title>lwIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="doxygen.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<table width="98%" border="0" align="center">
  <tr>
    <td>
      <h2>lwIP code documentation</h2>
<hr>

<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>pbuf.c</h1><a href="pbuf_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00030 <span class="comment">/*</span>
00031 <span class="comment"> * Copyright (c) 2001-2003 Swedish Institute of Computer Science.</span>
00032 <span class="comment"> * All rights reserved.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Redistribution and use in source and binary forms, with or without modification,</span>
00035 <span class="comment"> * are permitted provided that the following conditions are met:</span>
00036 <span class="comment"> *</span>
00037 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span>
00038 <span class="comment"> *    this list of conditions and the following disclaimer.</span>
00039 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
00040 <span class="comment"> *    this list of conditions and the following disclaimer in the documentation</span>
00041 <span class="comment"> *    and/or other materials provided with the distribution.</span>
00042 <span class="comment"> * 3. The name of the author may not be used to endorse or promote products</span>
00043 <span class="comment"> *    derived from this software without specific prior written permission.</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED</span>
00046 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
00047 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT</span>
00048 <span class="comment"> * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
00049 <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT</span>
00050 <span class="comment"> * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
00051 <span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
00052 <span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
00053 <span class="comment"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY</span>
00054 <span class="comment"> * OF SUCH DAMAGE.</span>
00055 <span class="comment"> *</span>
00056 <span class="comment"> * This file is part of the lwIP TCP/IP stack.</span>
00057 <span class="comment"> *</span>
00058 <span class="comment"> * Author: Adam Dunkels &lt;adam@sics.se&gt;</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> */</span>
00061 
00062 <span class="preprocessor">#include "<a class="code" href="opt_8h.html">lwip/opt.h</a>"</span>
00063 
00064 <span class="preprocessor">#include "<a class="code" href="stats_8h.html">lwip/stats.h</a>"</span>
00065 
00066 <span class="preprocessor">#include "<a class="code" href="def_8h.html">lwip/def.h</a>"</span>
00067 <span class="preprocessor">#include "<a class="code" href="mem_8h.html">lwip/mem.h</a>"</span>
00068 <span class="preprocessor">#include "<a class="code" href="memp_8h.html">lwip/memp.h</a>"</span>
00069 <span class="preprocessor">#include "<a class="code" href="pbuf_8h.html">lwip/pbuf.h</a>"</span>
00070 
00071 <span class="preprocessor">#include "<a class="code" href="sys_8h.html">lwip/sys.h</a>"</span>
00072 
00073 <span class="preprocessor">#include "arch/perf.h"</span>
00074 
00075 <span class="preprocessor">#include "netif/ipsecdev.h"</span>                     
<a name="l00076"></a><a class="code" href="pbuf_8c.html#a3">00076</a> <span class="keywordtype">int</span> <a class="code" href="pbuf_8c.html#a3">dbg_flag</a> = 0;                                       
<a name="l00078"></a><a class="code" href="pbuf_8c.html#a4">00078</a> <span class="keyword">static</span> u8_t <a class="code" href="pbuf_8c.html#a4">pbuf_pool_memory</a>[(<a class="code" href="opt_8h.html#a14">PBUF_POOL_SIZE</a> * <a class="code" href="mem_8h.html#a0">MEM_ALIGN_SIZE</a>(PBUF_POOL_BUFSIZE + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a>)))];
00079 
00080 <span class="preprocessor">#if !SYS_LIGHTWEIGHT_PROT</span>
<a name="l00081"></a><a class="code" href="pbuf_8c.html#a5">00081</a> <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">volatile</span> u8_t <a class="code" href="pbuf_8c.html#a5">pbuf_pool_free_lock</a>, <a class="code" href="pbuf_8c.html#a6">pbuf_pool_alloc_lock</a>;
<a name="l00082"></a><a class="code" href="pbuf_8c.html#a7">00082</a> <span class="keyword">static</span> sys_sem_t <a class="code" href="pbuf_8c.html#a7">pbuf_pool_free_sem</a>;
00083 <span class="preprocessor">#endif</span>
00084 <span class="preprocessor"></span>
<a name="l00085"></a><a class="code" href="pbuf_8c.html#a8">00085</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *<a class="code" href="pbuf_8c.html#a8">pbuf_pool</a> = <a class="code" href="def_8h.html#a2">NULL</a>;
00086 
00102 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
00103 <span class="preprocessor"></span>
00109 <span class="keyword">typedef</span> <span class="keyword">struct </span>memptr_struct {
00110         <span class="keywordtype">void</span> *ptr;
00111         <span class="keywordtype">int</span>  flags;
00112 } pbufstats_memptr;
00113 
00114 <span class="comment">/* maximum number of pbuf pointers we want to track   */</span>
00115 <span class="preprocessor">#define MAX_PTR 50                              </span>
00116 <span class="preprocessor"></span>pbufstats_memptr pbufstats_mempointers[MAX_PTR];        
00118 <span class="keywordtype">int</span> pbufstats_pbuf_counter = 0;                 
00120 <span class="keywordtype">char</span> pbufstats_text_pbuf_layers[][] = { 
00121                                                                                 {<span class="stringliteral">"PBUF_TRANSPORT"</span>},
00122                                                                                 {<span class="stringliteral">"PBUF_IP"</span>},
00123                                                                                 {<span class="stringliteral">"PBUF_LINK"</span>},
00124                                                                                 {<span class="stringliteral">"PBUF_RAW"</span>} 
00125                                                                         };
00126 
00127 <span class="keywordtype">char</span> pbufstats_text_pbuf_flags[][] = {  
00128                                                                                 {<span class="stringliteral">"PBUF_RAM"</span>},   
00129                                                                                 {<span class="stringliteral">"PBUF_ROM"</span>},
00130                                                                                 {<span class="stringliteral">"PBUF_REF"</span>},
00131                                                                                 {<span class="stringliteral">"PBUF_POOL"</span>} 
00132                                                                    };
00133 
00134 <span class="keywordtype">int</span> pbufstats_pbuftype_stats[] = {              
00135                                                                                 0, 
00136                                                                         0, 
00137                                                                         0, 
00138                                                                         0  
00139                                                            };
00140 
00147 <span class="keywordtype">void</span> pbufstats_print_pbuf_counter(<span class="keywordtype">char</span> *txt)
00148 {
00149         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( PBUF_DEBUG | 2, (<span class="stringliteral">"@@@@ pbufstats_pbuf_counter = %d - %s\n"</span>, pbufstats_pbuf_counter, txt) );
00150         <span class="keywordflow">if</span>(pbufstats_pbuf_counter &lt; 0) {
00151                 <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( PBUF_DEBUG | 2, (<span class="stringliteral">"*** pbuf statistics: ERROR: pbufstats_pbuf_counter == %d (&lt;0 means more calls of pbuf_free() than pbuf_alloc() ****"</span>, pbufstats_pbuf_counter) );
00152         }
00153 }
00154 
00155 
00160 <span class="keywordtype">void</span> pbufstats_print_pbuftype_stats()
00161 {
00162         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( PBUF_DEBUG | 2, (<span class="stringliteral">"*** pbuf statistics: pbuf flag type stats:\n"</span>) );
00163         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( PBUF_DEBUG | 2, (<span class="stringliteral">"       PBUF_RAM : %d\n"</span>, pbufstats_pbuftype_stats[0]) );
00164         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( PBUF_DEBUG | 2, (<span class="stringliteral">"       PBUF_ROM : %d\n"</span>, pbufstats_pbuftype_stats[1]) );
00165         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( PBUF_DEBUG | 2, (<span class="stringliteral">"       PBUF_REF : %d\n"</span>, pbufstats_pbuftype_stats[2]) );
00166         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( PBUF_DEBUG | 2, (<span class="stringliteral">"       PBUF_POOL: %d\n"</span>, pbufstats_pbuftype_stats[3]) );
00167 }
00168 
00169 
00174 <span class="keywordtype">void</span> pbufstats_addptr(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p) 
00175 {
00176         <span class="keywordtype">int</span> i;
00177 
00178         <span class="comment">// find emptry position</span>
00179         <span class="keywordflow">for</span>(i = 0; i &lt; MAX_PTR; i++)
00180         {
00181                 <span class="keywordflow">if</span>(pbufstats_mempointers[i].ptr  == (<span class="keywordtype">void</span>*) -1) <span class="keywordflow">break</span>;
00182         }
00183 
00184         <span class="keywordflow">if</span>(i == MAX_PTR)
00185         {
00186                 <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( PBUF_DEBUG | 2, (<span class="stringliteral">"*** pbuf statistics: ERROR: no space in ptr list for pbuf statistics\n"</span>) );
00187                 <span class="keywordflow">return</span>;
00188         }
00189 
00190         pbufstats_mempointers[i].ptr    = p;
00191         pbufstats_mempointers[i].<a class="code" href="structpbuf.html#o4">flags</a>  = p-&gt;<a class="code" href="structpbuf.html#o4">flags</a>;
00192 
00193         pbufstats_pbuftype_stats[i]++;
00194 
00195         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( PBUF_DEBUG | 2, (<span class="stringliteral">"*** pbuf statistics: ADDED pos. %d: p=%p, flags=%d(%s)\n"</span>, i, (<span class="keywordtype">void</span> *)pbufstats_mempointers[i].ptr, pbufstats_mempointers[i].flags, pbufstats_text_pbuf_flags[pbufstats_mempointers[i].flags]) );
00196         pbufstats_print_pbuftype_stats();
00197 }
00198 
00199 
00205 <span class="keywordtype">void</span> pbufstats_delptr(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p) 
00206 {
00207         <span class="keywordtype">int</span> i;
00208 
00209         <span class="comment">// find emptry position</span>
00210         <span class="keywordflow">for</span>(i = 0; i &lt; MAX_PTR; i++)
00211         {
00212                 <span class="keywordflow">if</span>(pbufstats_mempointers[i].ptr  == (<span class="keywordtype">void</span>*) p) <span class="keywordflow">break</span>;
00213         }
00214 
00215         <span class="keywordflow">if</span>(i == MAX_PTR)
00216         {
00217                 <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( PBUF_DEBUG | 2, (<span class="stringliteral">"*** pbuf statistics: ERROR: could not find ptr %p in list\n"</span>, (<span class="keywordtype">void</span> *)p) );
00218                 <span class="keywordflow">return</span>;
00219         }
00220 
00221         <span class="keywordflow">if</span>(pbufstats_mempointers[i].ptr != (<span class="keywordtype">void</span> *)p)
00222         {
00223                 <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( PBUF_DEBUG | 2, (<span class="stringliteral">"*** pbuf statistics: ERROR: pointer %d does not match! expected: %p   is: %p\n"</span>, i, (<span class="keywordtype">void</span> *)pbufstats_mempointers[i].ptr, (<span class="keywordtype">void</span> *)p) );
00224                 <span class="keywordflow">return</span>;
00225         }
00226 
00227         <span class="keywordflow">if</span>(pbufstats_mempointers[i].flags  != p-&gt;<a class="code" href="structpbuf.html#o4">flags</a>)
00228         {
00229                 <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( PBUF_DEBUG | 2, (<span class="stringliteral">"*** pbuf statistics: ERROR: flags %d do not match! expected: %d(%s)   is: %d(%s)\n"</span>, i, pbufstats_mempointers[i].flags, pbufstats_text_pbuf_flags[pbufstats_mempointers[i].flags], p-&gt;<a class="code" href="structpbuf.html#o4">flags</a>, pbufstats_text_pbuf_flags[p-&gt;<a class="code" href="structpbuf.html#o4">flags</a>]) );
00230                 <span class="keywordflow">return</span>;
00231         }
00232 
00233         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( PBUF_DEBUG | 2, (<span class="stringliteral">"*** pbuf statistics: REMOVED pos. %d: p=%p, flags=%d(%s)\n"</span>, i, (<span class="keywordtype">void</span> *)pbufstats_mempointers[i].ptr, pbufstats_mempointers[i].flags, pbufstats_text_pbuf_flags[pbufstats_mempointers[i].flags]) );
00234 
00235         pbufstats_mempointers[i].ptr   = (<span class="keywordtype">void</span>*) -1;
00236         pbufstats_mempointers[i].flags = -1;
00237 
00238         pbufstats_pbuftype_stats[i]--;
00239 
00240         pbufstats_print_pbuftype_stats();
00241 
00242 }
00243 
00248 <span class="keywordtype">void</span> pbuf_statistics_init(<span class="keywordtype">void</span>)
00249 {
00250         <span class="keywordtype">int</span> i;
00251 
00252         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( PBUF_DEBUG | 2, (<span class="stringliteral">"*** pbuf statistics: initializing\n"</span>) );
00253 
00254         pbufstats_pbuf_counter = 0;
00255 
00256         <span class="keywordflow">for</span>(i = 0; i &lt; MAX_PTR; i++)
00257         {
00258                 pbufstats_mempointers[i].ptr   = (<span class="keywordtype">void</span>*) -1;
00259                 pbufstats_mempointers[i].flags = -1;
00260         }
00261 }
00262 
00263 <span class="preprocessor">#endif</span>
00264 <span class="preprocessor"></span>
00265 
00266 <span class="keywordtype">void</span>
<a name="l00267"></a><a class="code" href="pbuf_8c.html#a9">00267</a> <a class="code" href="pbuf_8c.html#a9">pbuf_init</a>(<span class="keywordtype">void</span>)
00268 {
00269   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p, *q = <a class="code" href="def_8h.html#a2">NULL</a>;
00270   u16_t i;
00271 
00272 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
00273 <span class="preprocessor"></span>  pbuf_statistics_init();
00274 <span class="preprocessor">#endif</span>
00275 <span class="preprocessor"></span>
00276   <a class="code" href="pbuf_8c.html#a8">pbuf_pool</a> = (<span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *)&amp;<a class="code" href="pbuf_8c.html#a4">pbuf_pool_memory</a>[0];
00277 
00278  <span class="comment">// LWIP_ASSERT("pbuf_init: pool aligned", (long)pbuf_pool % MEM_ALIGNMENT == 0);</span>
00279   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"pbuf_init: pool aligned"</span>, (((<span class="keywordtype">long</span>)<a class="code" href="pbuf_8c.html#a8">pbuf_pool</a> % <a class="code" href="opt_8h.html#a2">MEM_ALIGNMENT</a>) == 0));
00280 
00281 <span class="preprocessor">#ifdef PBUF_STATS</span>
00282 <span class="preprocessor"></span>  lwip_stats.pbuf.avail = <a class="code" href="opt_8h.html#a14">PBUF_POOL_SIZE</a>;
00283 <span class="preprocessor">#endif </span><span class="comment">/* PBUF_STATS */</span>
00284 
00285   <span class="comment">/* Set up -&gt;next pointers to link the pbufs of the pool together */</span>
00286   p = <a class="code" href="pbuf_8c.html#a8">pbuf_pool</a>;
00287 
00288   <span class="keywordflow">for</span>(i = 0; i &lt; <a class="code" href="opt_8h.html#a14">PBUF_POOL_SIZE</a>; ++i) {
00289     p-&gt;<a class="code" href="structpbuf.html#o0">next</a> = (<span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *)((u8_t *)p + <a class="code" href="opt_8h.html#a15">PBUF_POOL_BUFSIZE</a> + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a>));
00290     p-&gt;<a class="code" href="structpbuf.html#o3">len</a> = p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a> = <a class="code" href="opt_8h.html#a15">PBUF_POOL_BUFSIZE</a>;
00291     p-&gt;<a class="code" href="structpbuf.html#o1">payload</a> = <a class="code" href="mem_8h.html#a1">MEM_ALIGN</a>((<span class="keywordtype">void</span> *)((u8_t *)p + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a>)));
00292     q = p;
00293     p = p-&gt;<a class="code" href="structpbuf.html#o0">next</a>;
00294   }
00295 
00296   <span class="comment">/* The -&gt;next pointer of last pbuf is NULL to indicate that there</span>
00297 <span class="comment">     are no more pbufs in the pool */</span>
00298   q-&gt;<a class="code" href="structpbuf.html#o0">next</a> = <a class="code" href="def_8h.html#a2">NULL</a>;
00299 
00300 <span class="preprocessor">#if !SYS_LIGHTWEIGHT_PROT</span>
00301 <span class="preprocessor"></span>  <a class="code" href="pbuf_8c.html#a6">pbuf_pool_alloc_lock</a> = 0;
00302   <a class="code" href="pbuf_8c.html#a5">pbuf_pool_free_lock</a> = 0;
00303   <a class="code" href="pbuf_8c.html#a7">pbuf_pool_free_sem</a> = <a class="code" href="sys_8h.html#a9">sys_sem_new</a>(1);
00304 <span class="preprocessor">#endif</span>
00305 <span class="preprocessor"></span>}
00306 
00310 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *
<a name="l00311"></a><a class="code" href="pbuf_8c.html#a10">00311</a> <a class="code" href="pbuf_8c.html#a10">pbuf_pool_alloc</a>(<span class="keywordtype">void</span>)
00312 {
00313   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p = <a class="code" href="def_8h.html#a2">NULL</a>;
00314 
00315 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
00316 <span class="preprocessor"></span>        pbufstats_print_pbuf_counter(<span class="stringliteral">"pbuf_pool_alloc"</span>);
00317 <span class="preprocessor">#endif</span>
00318 <span class="preprocessor"></span>
00319   <a class="code" href="sys_8h.html#a1">SYS_ARCH_DECL_PROTECT</a>(old_level);
00320   <a class="code" href="sys_8h.html#a2">SYS_ARCH_PROTECT</a>(old_level);
00321 
00322 <span class="preprocessor">#if !SYS_LIGHTWEIGHT_PROT</span>
00323 <span class="preprocessor"></span>  <span class="comment">/* Next, check the actual pbuf pool, but if the pool is locked, we</span>
00324 <span class="comment">     pretend to be out of buffers and return NULL. */</span>
00325   <span class="keywordflow">if</span> (<a class="code" href="pbuf_8c.html#a5">pbuf_pool_free_lock</a>) {
00326 <span class="preprocessor">#ifdef PBUF_STATS</span>
00327 <span class="preprocessor"></span>    ++lwip_stats.pbuf.alloc_locked;
00328 <span class="preprocessor">#endif </span><span class="comment">/* PBUF_STATS */</span>
00329     <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00330   }
00331   <a class="code" href="pbuf_8c.html#a6">pbuf_pool_alloc_lock</a> = 1;
00332   <span class="keywordflow">if</span> (!<a class="code" href="pbuf_8c.html#a5">pbuf_pool_free_lock</a>) {
00333 <span class="preprocessor">#endif </span><span class="comment">/* SYS_LIGHTWEIGHT_PROT */</span>
00334     p = <a class="code" href="pbuf_8c.html#a8">pbuf_pool</a>;
00335     <span class="keywordflow">if</span> (p) {
00336       <a class="code" href="pbuf_8c.html#a8">pbuf_pool</a> = p-&gt;<a class="code" href="structpbuf.html#o0">next</a>;
00337     }
00338 <span class="preprocessor">#if !SYS_LIGHTWEIGHT_PROT</span>
00339 <span class="preprocessor"></span><span class="preprocessor">#ifdef PBUF_STATS</span>
00340 <span class="preprocessor"></span>  } <span class="keywordflow">else</span> {
00341     ++lwip_stats.pbuf.alloc_locked;
00342 <span class="preprocessor">#endif </span><span class="comment">/* PBUF_STATS */</span>
00343   }
00344   <a class="code" href="pbuf_8c.html#a6">pbuf_pool_alloc_lock</a> = 0;
00345 <span class="preprocessor">#endif </span><span class="comment">/* SYS_LIGHTWEIGHT_PROT */</span>
00346 
00347 <span class="preprocessor">#ifdef PBUF_STATS</span>
00348 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (p != <a class="code" href="def_8h.html#a2">NULL</a>) {
00349     ++lwip_stats.pbuf.used;
00350     <span class="keywordflow">if</span> (lwip_stats.pbuf.used &gt; lwip_stats.pbuf.max) {
00351       lwip_stats.pbuf.max = lwip_stats.pbuf.used;
00352     }
00353   }
00354 <span class="preprocessor">#endif </span><span class="comment">/* PBUF_STATS */</span>
00355 
00356   <a class="code" href="sys_8h.html#a3">SYS_ARCH_UNPROTECT</a>(old_level);
00357   <span class="keywordflow">return</span> p;
00358 }
00359 
00360 
00390 <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *
<a name="l00391"></a><a class="code" href="pbuf_8c.html#a11">00391</a> <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(pbuf_layer l, u16_t length, pbuf_flag flag)
00392 {
00393   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p, *q, *r;
00394   u16_t offset;
00395   s32_t rem_len; <span class="comment">/* remaining length */</span>
00396 
00397 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
00398 <span class="preprocessor"></span>        <span class="keywordtype">char</span> text[200];
00399 <span class="preprocessor">#endif</span>
00400 <span class="preprocessor"></span>
00401 
00402   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 3, (<span class="stringliteral">"pbuf_alloc(length=%u)\n"</span>, length));
00403 
00404 
00405 
00406 
00407   <span class="comment">/* determine header offset */</span>
00408   offset = 0;
00409   <span class="keywordflow">switch</span> (l) {
00410   <span class="keywordflow">case</span> <a class="code" href="pbuf_8h.html#a26a7">PBUF_TRANSPORT</a>:
00411     <span class="comment">/* add room for transport (often TCP) layer header */</span>
00412     offset += <a class="code" href="pbuf_8h.html#a0">PBUF_TRANSPORT_HLEN</a>;
00413     <span class="comment">/* FALLTHROUGH */</span>
00414   <span class="keywordflow">case</span> <a class="code" href="pbuf_8h.html#a26a8">PBUF_IP</a>:
00415     <span class="comment">/* add room for IP layer header */</span>
00416     offset += <a class="code" href="pbuf_8h.html#a1">PBUF_IP_HLEN</a>;
00417     <span class="comment">/* FALLTHROUGH */</span>
00418   <span class="keywordflow">case</span> <a class="code" href="pbuf_8h.html#a26a9">PBUF_LINK</a>:
00419     <span class="comment">/* add room for link layer header */</span>
00420     offset += <a class="code" href="opt_8h.html#a16">PBUF_LINK_HLEN</a>;
00421     <span class="keywordflow">break</span>;
00422   <span class="keywordflow">case</span> <a class="code" href="pbuf_8h.html#a26a10">PBUF_RAW</a>:
00423     <span class="keywordflow">break</span>;
00424   <span class="keywordflow">default</span>:
00425     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"pbuf_alloc: bad pbuf layer"</span>, 0);
00426     <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00427   }
00428 
00429   <span class="comment">/* add room for IPsec layer header */</span>
00430   offset += IPSEC_HLEN;         
00432   <span class="keywordflow">switch</span> (flag) {
00433   <span class="keywordflow">case</span> <a class="code" href="pbuf_8h.html#a27a14">PBUF_POOL</a>:
00434     <span class="comment">/* allocate head of pbuf chain into p */</span>
00435     p = <a class="code" href="pbuf_8c.html#a10">pbuf_pool_alloc</a>();
00436     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 3, (<span class="stringliteral">"pbuf_alloc: allocated pbuf %p\n"</span>, (<span class="keywordtype">void</span> *)p));
00437     <span class="keywordflow">if</span> (p == <a class="code" href="def_8h.html#a2">NULL</a>) {
00438 <span class="preprocessor">#ifdef PBUF_STATS</span>
00439 <span class="preprocessor"></span>      ++lwip_stats.pbuf.err;
00440 <span class="preprocessor">#endif </span><span class="comment">/* PBUF_STATS */</span>
00441       <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00442     }
00443     p-&gt;<a class="code" href="structpbuf.html#o0">next</a> = <a class="code" href="def_8h.html#a2">NULL</a>;
00444 
00445     <span class="comment">/* make the payload pointer point 'offset' bytes into pbuf data memory */</span>
00446     p-&gt;<a class="code" href="structpbuf.html#o1">payload</a> = <a class="code" href="mem_8h.html#a1">MEM_ALIGN</a>((<span class="keywordtype">void</span> *)((u8_t *)p + (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a>) + offset)));
00447     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"pbuf_alloc: pbuf p-&gt;payload properly aligned"</span>,
00448             ((u32_t)p-&gt;<a class="code" href="structpbuf.html#o1">payload</a> % <a class="code" href="opt_8h.html#a2">MEM_ALIGNMENT</a>) == 0);
00449     <span class="comment">/* the total length of the pbuf chain is the requested size */</span>
00450     p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a> = length;
00451     <span class="comment">/* set the length of the first pbuf in the chain */</span>
00452     p-&gt;<a class="code" href="structpbuf.html#o3">len</a> = length &gt; <a class="code" href="opt_8h.html#a15">PBUF_POOL_BUFSIZE</a> - offset? <a class="code" href="opt_8h.html#a15">PBUF_POOL_BUFSIZE</a> - offset: length;
00453     <span class="comment">/* set pbuf type */</span>
00454     p-&gt;<a class="code" href="structpbuf.html#o4">flags</a> = <a class="code" href="pbuf_8h.html#a4">PBUF_FLAG_POOL</a>;
00455     <span class="comment">/* set reference count (needed here in case we fail) */</span>
00456     p-&gt;<a class="code" href="structpbuf.html#o5">ref</a> = 1;
00457 
00458     <span class="comment">/* now allocate the tail of the pbuf chain */</span>
00459 
00460     <span class="comment">/* remember first pbuf for linkage in next iteration */</span>
00461     r = p;
00462     <span class="comment">/* remaining length to be allocated */</span>
00463     rem_len = length - p-&gt;<a class="code" href="structpbuf.html#o3">len</a>;
00464     <span class="comment">/* any remaining pbufs to be allocated? */</span>
00465     <span class="keywordflow">while</span> (rem_len &gt; 0) {
00466       q = <a class="code" href="pbuf_8c.html#a10">pbuf_pool_alloc</a>();
00467       <span class="keywordflow">if</span> (q == <a class="code" href="def_8h.html#a2">NULL</a>) {
00468        <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | 2, (<span class="stringliteral">"pbuf_alloc: Out of pbufs in pool.\n"</span>));
00469 <span class="preprocessor">#ifdef PBUF_STATS</span>
00470 <span class="preprocessor"></span>        ++lwip_stats.pbuf.err;
00471 <span class="preprocessor">#endif </span><span class="comment">/* PBUF_STATS */</span>
00472         <span class="comment">/* free chain so far allocated */</span>
00473         <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00474         <span class="comment">/* bail out unsuccesfully */</span>
00475         <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00476       }
00477       q-&gt;next = <a class="code" href="def_8h.html#a2">NULL</a>;
00478       <span class="comment">/* make previous pbuf point to this pbuf */</span>
00479       r-&gt;next = q;
00480       <span class="comment">/* set total length of this pbuf and next in chain */</span>
00481       q-&gt;tot_len = rem_len;
00482       <span class="comment">/* this pbuf length is pool size, unless smaller sized tail */</span>
00483       q-&gt;len = rem_len &gt; <a class="code" href="opt_8h.html#a15">PBUF_POOL_BUFSIZE</a>? <a class="code" href="opt_8h.html#a15">PBUF_POOL_BUFSIZE</a>: rem_len;
00484       q-&gt;flags = <a class="code" href="pbuf_8h.html#a4">PBUF_FLAG_POOL</a>;
00485       q-&gt;payload = (<span class="keywordtype">void</span> *)((u8_t *)q + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a>));
00486       <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"pbuf_alloc: pbuf q-&gt;payload properly aligned"</span>,
00487               ((u32_t)q-&gt;payload % <a class="code" href="opt_8h.html#a2">MEM_ALIGNMENT</a>) == 0);
00488       q-&gt;ref = 1;
00489       <span class="comment">/* calculate remaining length to be allocated */</span>
00490       rem_len -= q-&gt;len;
00491       <span class="comment">/* remember this pbuf for linkage in next iteration */</span>
00492       r = q;
00493     }
00494     <span class="comment">/* end of chain */</span>
00495     <span class="comment">//r-&gt;next = NULL;</span>
00496 
00497     <span class="keywordflow">break</span>;
00498   <span class="keywordflow">case</span> <a class="code" href="pbuf_8h.html#a27a11">PBUF_RAM</a>:
00499     <span class="comment">/* If pbuf is to be allocated in RAM, allocate memory for it. */</span>
00500     p = <a class="code" href="mem_8c.html#a11">mem_malloc</a>(<a class="code" href="mem_8h.html#a0">MEM_ALIGN_SIZE</a>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a>) + length + offset));
00501     <span class="keywordflow">if</span> (p == <a class="code" href="def_8h.html#a2">NULL</a>) {
00502       <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00503     }
00504     <span class="comment">/* Set up internal structure of the pbuf. */</span>
00505     p-&gt;payload = <a class="code" href="mem_8h.html#a1">MEM_ALIGN</a>((<span class="keywordtype">void</span> *)((u8_t *)p + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a>) + offset));
00506     p-&gt;len = p-&gt;tot_len = length;
00507     p-&gt;next = <a class="code" href="def_8h.html#a2">NULL</a>;
00508     p-&gt;flags = <a class="code" href="pbuf_8h.html#a2">PBUF_FLAG_RAM</a>;
00509 
00510     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"pbuf_alloc: pbuf-&gt;payload properly aligned"</span>,
00511            ((u32_t)p-&gt;payload % <a class="code" href="opt_8h.html#a2">MEM_ALIGNMENT</a>) == 0);
00512     <span class="keywordflow">break</span>;
00513   <span class="comment">/* pbuf references existing (static constant) ROM payload? */</span>
00514   <span class="keywordflow">case</span> <a class="code" href="pbuf_8h.html#a27a12">PBUF_ROM</a>:
00515   <span class="comment">/* pbuf references existing (externally allocated) RAM payload? */</span>
00516   <span class="keywordflow">case</span> <a class="code" href="pbuf_8h.html#a27a13">PBUF_REF</a>:
00517     <span class="comment">/* only allocate memory for the pbuf structure */</span>
00518     p = <a class="code" href="memp_8c.html#a7">memp_mallocp</a>(<a class="code" href="memp_8h.html#a17a0">MEMP_PBUF</a>);
00519     <span class="keywordflow">if</span> (p == <a class="code" href="def_8h.html#a2">NULL</a>) {
00520       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 2, (<span class="stringliteral">"pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n"</span>, flag == <a class="code" href="pbuf_8h.html#a27a12">PBUF_ROM</a>?<span class="stringliteral">"ROM"</span>:<span class="stringliteral">"REF"</span>));
00521       <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00522     }
00523     <span class="comment">/* caller must set this field properly, afterwards */</span>
00524     p-&gt;payload = <a class="code" href="def_8h.html#a2">NULL</a>;
00525     p-&gt;len = p-&gt;tot_len = length;
00526     p-&gt;next = <a class="code" href="def_8h.html#a2">NULL</a>;
00527     p-&gt;flags = (flag == <a class="code" href="pbuf_8h.html#a27a12">PBUF_ROM</a>? <a class="code" href="pbuf_8h.html#a3">PBUF_FLAG_ROM</a>: <a class="code" href="pbuf_8h.html#a5">PBUF_FLAG_REF</a>);
00528     <span class="keywordflow">break</span>;
00529   <span class="keywordflow">default</span>:
00530     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"pbuf_alloc: erroneous flag"</span>, 0);
00531     <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00532   }
00533   <span class="comment">/* set reference count */</span>
00534   p-&gt;<a class="code" href="structpbuf.html#o5">ref</a> = 1;
00535   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 3, (<span class="stringliteral">"pbuf_alloc(length=%u) == %p\n"</span>, length, (<span class="keywordtype">void</span> *)p));
00536 
00537 
00538 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
00539 <span class="preprocessor"></span>        pbufstats_pbuf_counter++;
00540         sprintf(text, <span class="stringliteral">"pbuf_alloc: p=%p, flag=%s, layer=%s length=%d"</span>, p, pbufstats_text_pbuf_flags[flag],  pbufstats_text_pbuf_layers[l], length);
00541         pbufstats_print_pbuf_counter(text);
00542         pbufstats_addptr(p);
00543 <span class="preprocessor">#endif</span>
00544 <span class="preprocessor"></span>
00545   <span class="keywordflow">return</span> p;
00546 }
00547 
00548 
00549 <span class="preprocessor">#ifdef PBUF_STATS</span>
00550 <span class="preprocessor"></span><span class="preprocessor">#define DEC_PBUF_STATS do { --lwip_stats.pbuf.used; } while (0)</span>
00551 <span class="preprocessor"></span><span class="preprocessor">#else </span><span class="comment">/* PBUF_STATS */</span>
<a name="l00552"></a><a class="code" href="pbuf_8c.html#a0">00552</a> <span class="preprocessor">#define DEC_PBUF_STATS</span>
00553 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* PBUF_STATS */</span>
00554 
<a name="l00555"></a><a class="code" href="pbuf_8c.html#a1">00555</a> <span class="preprocessor">#define PBUF_POOL_FAST_FREE(p)  do {                                    \</span>
00556 <span class="preprocessor">                                  p-&gt;next = pbuf_pool;                  \</span>
00557 <span class="preprocessor">                                  pbuf_pool = p;                        \</span>
00558 <span class="preprocessor">                                  DEC_PBUF_STATS;                       \</span>
00559 <span class="preprocessor">                                } while (0)</span>
00560 <span class="preprocessor"></span>
00561 <span class="preprocessor">#if SYS_LIGHTWEIGHT_PROT</span>
00562 <span class="preprocessor"></span><span class="preprocessor">#define PBUF_POOL_FREE(p)  do {                                         \</span>
00563 <span class="preprocessor">                                SYS_ARCH_DECL_PROTECT(old_level);       \</span>
00564 <span class="preprocessor">                                SYS_ARCH_PROTECT(old_level);            \</span>
00565 <span class="preprocessor">                                PBUF_POOL_FAST_FREE(p);                 \</span>
00566 <span class="preprocessor">                                SYS_ARCH_UNPROTECT(old_level);          \</span>
00567 <span class="preprocessor">                               } while (0)</span>
00568 <span class="preprocessor"></span><span class="preprocessor">#else </span><span class="comment">/* SYS_LIGHTWEIGHT_PROT */</span>
<a name="l00569"></a><a class="code" href="pbuf_8c.html#a2">00569</a> <span class="preprocessor">#define PBUF_POOL_FREE(p)  do {                                         \</span>
00570 <span class="preprocessor">                             sys_sem_wait(pbuf_pool_free_sem);          \</span>
00571 <span class="preprocessor">                             PBUF_POOL_FAST_FREE(p);                    \</span>
00572 <span class="preprocessor">                             sys_sem_signal(pbuf_pool_free_sem);        \</span>
00573 <span class="preprocessor">                           } while (0)</span>
00574 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* SYS_LIGHTWEIGHT_PROT */</span>
00575 
00591 <span class="keywordtype">void</span>
<a name="l00592"></a><a class="code" href="pbuf_8c.html#a12">00592</a> <a class="code" href="pbuf_8c.html#a12">pbuf_realloc</a>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p, u16_t new_len)
00593 {
00594   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *q;
00595   u16_t rem_len; <span class="comment">/* remaining length */</span>
00596   s16_t grow;
00597 
00598 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
00599 <span class="preprocessor"></span>        <span class="keywordtype">char</span> text[200];
00600 
00601         sprintf(text, <span class="stringliteral">"pbuf_realloc: p=%p, new_len=%d, p-&gt;flags=%s"</span>, (<span class="keywordtype">void</span> *)p, new_len, pbufstats_text_pbuf_flags[p-&gt;<a class="code" href="structpbuf.html#o4">flags</a>]);
00602         pbufstats_print_pbuf_counter(text);
00603 <span class="preprocessor">#endif</span>
00604 <span class="preprocessor"></span>
00605 
00606   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"pbuf_realloc: sane p-&gt;flags"</span>, p-&gt;flags == <a class="code" href="pbuf_8h.html#a4">PBUF_FLAG_POOL</a> ||
00607               p-&gt;flags == <a class="code" href="pbuf_8h.html#a3">PBUF_FLAG_ROM</a> ||
00608               p-&gt;flags == <a class="code" href="pbuf_8h.html#a2">PBUF_FLAG_RAM</a> ||
00609               p-&gt;flags == <a class="code" href="pbuf_8h.html#a5">PBUF_FLAG_REF</a>);
00610 
00611 
00612 
00613   <span class="comment">/* desired length larger than current length? */</span>
00614   <span class="keywordflow">if</span> (new_len &gt;= p-&gt;tot_len) {
00615     <span class="comment">/* enlarging not yet supported */</span>
00616     <span class="keywordflow">return</span>;
00617   }
00618 
00619   <span class="comment">/* the pbuf chain grows by (new_len - p-&gt;tot_len) bytes</span>
00620 <span class="comment">   * (which may be negative in case of shrinking) */</span>
00621   grow = new_len - p-&gt;tot_len;
00622 
00623   <span class="comment">/* first, step over any pbufs that should remain in the chain */</span>
00624   rem_len = new_len;
00625   q = p;
00626   <span class="comment">/* this pbuf should be kept? */</span>
00627   <span class="keywordflow">while</span> (rem_len &gt; q-&gt;len) {
00628     <span class="comment">/* decrease remaining length by pbuf length */</span>
00629     rem_len -= q-&gt;len;
00630     <span class="comment">/* decrease total length indicator */</span>
00631     q-&gt;tot_len += grow;
00632     <span class="comment">/* proceed to next pbuf in chain */</span>
00633     q = q-&gt;next;
00634   }
00635   <span class="comment">/* we have now reached the new last pbuf (in q) */</span>
00636   <span class="comment">/* rem_len == desired length for pbuf q */</span>
00637 
00638   <span class="comment">/* shrink allocated memory for PBUF_RAM */</span>
00639   <span class="comment">/* (other types merely adjust their length fields */</span>
00640   <span class="keywordflow">if</span> ((q-&gt;flags == <a class="code" href="pbuf_8h.html#a2">PBUF_FLAG_RAM</a>) &amp;&amp; (rem_len != q-&gt;len)) {
00641     <span class="comment">/* reallocate and adjust the length of the pbuf that will be split */</span>
00642     <a class="code" href="mem_8c.html#a10">mem_realloc</a>(q, (u8_t *)q-&gt;payload - (u8_t *)q + rem_len);
00643   }
00644   <span class="comment">/* adjust length fields for new last pbuf */</span>
00645   q-&gt;len = rem_len;
00646   q-&gt;tot_len = q-&gt;len;
00647 
00648   <span class="comment">/* any remaining pbufs in chain? */</span>
00649   <span class="keywordflow">if</span> (q-&gt;next != <a class="code" href="def_8h.html#a2">NULL</a>) {
00650     <span class="comment">/* free remaining pbufs in chain */</span>
00651     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(q-&gt;next);
00652   }
00653   <span class="comment">/* q is last packet in chain */</span>
00654   q-&gt;next = <a class="code" href="def_8h.html#a2">NULL</a>;
00655 
00656 }
00657 
00677 u8_t
<a name="l00678"></a><a class="code" href="pbuf_8c.html#a13">00678</a> <a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p, s16_t header_size)
00679 {
00680   <span class="keywordtype">void</span> *payload;
00681 
00682 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
00683 <span class="preprocessor"></span>        <span class="keywordtype">char</span> text[200];
00684         sprintf(text, <span class="stringliteral">"pbuf_header: p=%p, header_size=%d, p-&gt;flags=%s"</span>, (<span class="keywordtype">void</span> *)p, header_size, pbufstats_text_pbuf_flags[p-&gt;<a class="code" href="structpbuf.html#o4">flags</a>]);
00685         pbufstats_print_pbuf_counter(text);
00686 <span class="preprocessor">#endif</span>
00687 <span class="preprocessor"></span>
00688 
00689   <span class="comment">/* remember current payload pointer */</span>
00690   payload = p-&gt;payload;
00691 
00692   <span class="comment">/* pbuf types containing payloads? */</span>
00693   <span class="keywordflow">if</span> (p-&gt;flags == <a class="code" href="pbuf_8h.html#a2">PBUF_FLAG_RAM</a> || p-&gt;flags == <a class="code" href="pbuf_8h.html#a4">PBUF_FLAG_POOL</a>) {
00694     <span class="comment">/* set new payload pointer */</span>
00695     p-&gt;payload = (u8_t *)p-&gt;payload - header_size;
00696     <span class="comment">/* boundary check fails? */</span>
00697     <span class="keywordflow">if</span> ((u8_t *)p-&gt;payload &lt; (u8_t *)p + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a>)) {
00698       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( <a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | 2, (<span class="stringliteral">"pbuf_header: failed as %p &lt; %p\n"</span>,
00699         (u8_t *)p-&gt;payload,
00700         (u8_t *)p + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a>)) );\
00701       <span class="comment">/* restore old payload pointer */</span>
00702       p-&gt;payload = payload;
00703       <span class="comment">/* bail out unsuccesfully */</span>
00704       <span class="keywordflow">return</span> 1;
00705     }
00706   <span class="comment">/* pbuf types refering to payloads? */</span>
00707   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p-&gt;flags == <a class="code" href="pbuf_8h.html#a5">PBUF_FLAG_REF</a> || p-&gt;flags == <a class="code" href="pbuf_8h.html#a3">PBUF_FLAG_ROM</a>) {
00708     <span class="comment">/* hide a header in the payload? */</span>
00709     <span class="keywordflow">if</span> ((header_size &lt; 0) &amp;&amp; (header_size - p-&gt;len &lt;= 0)) {
00710       <span class="comment">/* increase payload pointer */</span>
00711       p-&gt;payload = (u8_t *)p-&gt;payload - header_size;
00712     } <span class="keywordflow">else</span> {
00713       <span class="comment">/* cannot expand payload to front (yet!)</span>
00714 <span class="comment">       * bail out unsuccesfully */</span>
00715       <span class="keywordflow">return</span> 1;
00716     }
00717   }
00718   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( <a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a>, (<span class="stringliteral">"pbuf_header: old %p new %p (%d)\n"</span>, (<span class="keywordtype">void</span> *)payload, (<span class="keywordtype">void</span> *)p-&gt;payload, header_size) );
00719   <span class="comment">/* modify pbuf length fields */</span>
00720   p-&gt;len += header_size;
00721   p-&gt;tot_len += header_size;
00722 
00723   <span class="keywordflow">return</span> 0;
00724 }
00725 
00754 u8_t
<a name="l00755"></a><a class="code" href="pbuf_8c.html#a14">00755</a> <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p)
00756 {
00757 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
00758 <span class="preprocessor"></span>          <span class="keywordtype">char</span> text[200];
00759 <span class="preprocessor">#endif</span>
00760 <span class="preprocessor"></span>
00761           <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *q;
00762           u8_t count;
00763           <a class="code" href="sys_8h.html#a1">SYS_ARCH_DECL_PROTECT</a>(old_level);
00764         
00765           <span class="keywordflow">if</span> (p == <a class="code" href="def_8h.html#a2">NULL</a>) {
00766             <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 2, (<span class="stringliteral">"pbuf_free(p == NULL) was called.\n"</span>));
00767             <span class="keywordflow">return</span> 0;
00768           }
00769           <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 3, (<span class="stringliteral">"pbuf_free(%p)\n"</span>, (<span class="keywordtype">void</span> *)p));
00770         
00771           PERF_START;
00772         
00773           <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"pbuf_free: sane flags"</span>,
00774             p-&gt;<a class="code" href="structpbuf.html#o4">flags</a> == <a class="code" href="pbuf_8h.html#a2">PBUF_FLAG_RAM</a> || p-&gt;<a class="code" href="structpbuf.html#o4">flags</a> == <a class="code" href="pbuf_8h.html#a3">PBUF_FLAG_ROM</a> ||
00775             p-&gt;<a class="code" href="structpbuf.html#o4">flags</a> == <a class="code" href="pbuf_8h.html#a5">PBUF_FLAG_REF</a> || p-&gt;<a class="code" href="structpbuf.html#o4">flags</a> == <a class="code" href="pbuf_8h.html#a4">PBUF_FLAG_POOL</a>);
00776         
00777           count = 0;
00778 
00779 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
00780 <span class="preprocessor"></span>          <span class="keywordflow">if</span>(p == <a class="code" href="def_8h.html#a2">NULL</a>) {
00781                 pbufstats_print_pbuf_counter(<span class="stringliteral">"pbuf_free: p is NULL!"</span>);
00782                 pbufstats_pbuf_counter--;
00783           }
00784 <span class="preprocessor">#endif</span>
00785 <span class="preprocessor"></span>
00786           <span class="comment">/* Since decrementing ref cannot be guaranteed to be a single machine operation</span>
00787 <span class="comment">           * we must protect it. Also, the later test of ref must be protected.</span>
00788 <span class="comment">           */</span>
00789           <a class="code" href="sys_8h.html#a2">SYS_ARCH_PROTECT</a>(old_level);
00790           <span class="comment">/* de-allocate all consecutive pbufs from the head of the chain that</span>
00791 <span class="comment">           * obtain a zero reference count after decrementing*/</span>
00792           <span class="keywordflow">while</span> (p != <a class="code" href="def_8h.html#a2">NULL</a>) {
00793                     <span class="comment">/* all pbufs in a chain are referenced at least once */</span>
00794                     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"pbuf_free: p-&gt;ref &gt; 0"</span>, p-&gt;<a class="code" href="structpbuf.html#o5">ref</a> &gt; 0);
00795 
00796 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
00797 <span class="preprocessor"></span>                        sprintf(text, <span class="stringliteral">"pbuf_free: p=%p, p-&gt;flags=%s"</span>, (<span class="keywordtype">void</span> *)p, pbufstats_text_pbuf_flags[p-&gt;<a class="code" href="structpbuf.html#o4">flags</a>]);
00798                         pbufstats_print_pbuf_counter(text);
00799                         pbufstats_pbuf_counter--;
00800 
00801                         pbufstats_delptr(p);
00802 <span class="preprocessor">#endif</span>
00803 <span class="preprocessor"></span>
00804                     <span class="comment">/* decrease reference count (number of pointers to pbuf) */</span>
00805                     p-&gt;ref--;
00806                     <span class="comment">/* this pbuf is no longer referenced to? */</span>
00807                     <span class="keywordflow">if</span> (p-&gt;ref == 0) 
00808                     {
00809                               <span class="comment">/* remember next pbuf in chain for next iteration */</span>
00810                               q = p-&gt;next;
00811                               <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( <a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | 2, (<span class="stringliteral">"pbuf_free: deallocating %p\n"</span>, (<span class="keywordtype">void</span> *)p));
00812                               <span class="comment">/* is this a pbuf from the pool? */</span>
00813                               <span class="keywordflow">if</span> (p-&gt;flags == <a class="code" href="pbuf_8h.html#a4">PBUF_FLAG_POOL</a>) 
00814                               {
00815                                         p-&gt;len = p-&gt;tot_len = <a class="code" href="opt_8h.html#a15">PBUF_POOL_BUFSIZE</a>;
00816                                         p-&gt;payload = (<span class="keywordtype">void</span> *)((u8_t *)p + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a>));
00817                                         <a class="code" href="pbuf_8c.html#a2">PBUF_POOL_FREE</a>(p);
00818                                       <span class="comment">/* a ROM or RAM referencing pbuf */</span>
00819                               } 
00820                               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p-&gt;flags == <a class="code" href="pbuf_8h.html#a3">PBUF_FLAG_ROM</a> || p-&gt;flags == <a class="code" href="pbuf_8h.html#a5">PBUF_FLAG_REF</a>) 
00821                               {
00822                                         <a class="code" href="memp_8c.html#a9">memp_freep</a>(<a class="code" href="memp_8h.html#a17a0">MEMP_PBUF</a>, p);
00823                                       <span class="comment">/* p-&gt;flags == PBUF_FLAG_RAM */</span>
00824                               } 
00825                               <span class="keywordflow">else</span> {
00826                                         <a class="code" href="mem_8c.html#a8">mem_free</a>(p);
00827                               }
00828                               count++;
00829                               <span class="comment">/* proceed to next pbuf */</span>
00830                               p = q;
00831                     <span class="comment">/* p-&gt;ref &gt; 0, this pbuf is still referenced to */</span>
00832                     <span class="comment">/* (and so the remaining pbufs in chain as well) */</span>
00833                     } 
00834                     <span class="keywordflow">else</span> {
00835                               <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>( <a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | 2, (<span class="stringliteral">"pbuf_free: %p has ref %u, ending here.\n"</span>, (<span class="keywordtype">void</span> *)p, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)p-&gt;ref));
00836                               <span class="comment">/* stop walking through chain */</span>
00837                               p = <a class="code" href="def_8h.html#a2">NULL</a>;
00838                     }
00839           }
00840           <a class="code" href="sys_8h.html#a3">SYS_ARCH_UNPROTECT</a>(old_level);
00841           PERF_STOP(<span class="stringliteral">"pbuf_free"</span>);
00842           <span class="comment">/* return number of de-allocated pbufs */</span>
00843           <span class="keywordflow">return</span> count;
00844 }
00845 
00846 
00847 
00848 
00849 
00850 
00851 
00859 u8_t
<a name="l00860"></a><a class="code" href="pbuf_8c.html#a15">00860</a> <a class="code" href="pbuf_8c.html#a15">pbuf_clen</a>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p)
00861 {
00862   u8_t len;
00863 
00864   len = 0;
00865   <span class="keywordflow">while</span> (p != <a class="code" href="def_8h.html#a2">NULL</a>) {
00866     ++len;
00867     p = p-&gt;<a class="code" href="structpbuf.html#o0">next</a>;
00868   }
00869   <span class="keywordflow">return</span> len;
00870 }
00871 
00879 <span class="keywordtype">void</span>
<a name="l00880"></a><a class="code" href="pbuf_8c.html#a16">00880</a> <a class="code" href="pbuf_8c.html#a16">pbuf_ref</a>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p)
00881 {
00882   <a class="code" href="sys_8h.html#a1">SYS_ARCH_DECL_PROTECT</a>(old_level);
00883   <span class="comment">/* pbuf given? */</span>
00884   <span class="keywordflow">if</span> (p != <a class="code" href="def_8h.html#a2">NULL</a>) {
00885     <a class="code" href="sys_8h.html#a2">SYS_ARCH_PROTECT</a>(old_level);
00886     ++(p-&gt;<a class="code" href="structpbuf.html#o5">ref</a>);
00887     <a class="code" href="sys_8h.html#a3">SYS_ARCH_UNPROTECT</a>(old_level);
00888   }
00889 }
00890 
00904 <span class="keywordtype">void</span>
<a name="l00905"></a><a class="code" href="pbuf_8c.html#a17">00905</a> <a class="code" href="pbuf_8c.html#a17">pbuf_chain</a>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *h, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *t)
00906 {
00907   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p;
00908 
00909 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
00910 <span class="preprocessor"></span>        <span class="keywordtype">char</span> text[200];
00911         sprintf(text, <span class="stringliteral">"pbuf_chain: h=%p, head flag=%s, t=%p, tail flag=%s"</span>, (<span class="keywordtype">void</span> *)h, pbufstats_text_pbuf_flags[h-&gt;<a class="code" href="structpbuf.html#o4">flags</a>],  (<span class="keywordtype">void</span> *)t, pbufstats_text_pbuf_flags[t-&gt;<a class="code" href="structpbuf.html#o4">flags</a>]);
00912         pbufstats_print_pbuf_counter(text);
00913 <span class="preprocessor">#endif</span>
00914 <span class="preprocessor"></span>
00915 
00916   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"h != NULL"</span>, h != <a class="code" href="def_8h.html#a2">NULL</a>);
00917   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"t != NULL"</span>, t != <a class="code" href="def_8h.html#a2">NULL</a>);
00918 
00919   <span class="keywordflow">if</span> (t == <a class="code" href="def_8h.html#a2">NULL</a>)
00920     <span class="keywordflow">return</span>;
00921 
00922   <span class="comment">/* proceed to last pbuf of chain */</span>
00923   <span class="keywordflow">for</span> (p = h; p-&gt;<a class="code" href="structpbuf.html#o0">next</a> != <a class="code" href="def_8h.html#a2">NULL</a>; p = p-&gt;<a class="code" href="structpbuf.html#o0">next</a>) {
00924     <span class="comment">/* add total length of second chain to all totals of first chain */</span>
00925     p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a> += t-&gt;tot_len;
00926   }
00927   <span class="comment">/* p is last pbuf of first h chain */</span>
00928   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"p-&gt;tot_len == p-&gt;len (of last pbuf in chain)"</span>, p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a> == p-&gt;<a class="code" href="structpbuf.html#o3">len</a>);
00929   <span class="comment">/* add total length of second chain to last pbuf total of first chain */</span>
00930   p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a> += t-&gt;tot_len;
00931   <span class="comment">/* chain last pbuf of h chain (p) with first of tail (t) */</span>
00932   p-&gt;<a class="code" href="structpbuf.html#o0">next</a> = t;
00933   <span class="comment">/* t is now referenced to one more time */</span>
00934   <a class="code" href="pbuf_8c.html#a16">pbuf_ref</a>(t);
00935   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a9">DBG_FRESH</a> | 2, (<span class="stringliteral">"pbuf_chain: %p references %p\n"</span>, (<span class="keywordtype">void</span> *)p, (<span class="keywordtype">void</span> *)t));
00936 }
00937 
00938 <span class="comment">/* For packet queueing. Note that queued packets must be dequeued first</span>
00939 <span class="comment"> * before calling any pbuf functions. */</span>
00940 <span class="preprocessor">#if ARP_QUEUEING</span>
00941 <span class="preprocessor"></span>
00948 <span class="keywordtype">void</span>
00949 pbuf_queue(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *n)
00950 {
00951 
00952 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
00953 <span class="preprocessor"></span>        <span class="keywordtype">char</span> text[200];
00954         sprintf(text, <span class="stringliteral">"pbuf_queue: p=%p, prev flag=%s, n=%p, next flag=%s"</span>, (<span class="keywordtype">void</span> *)p, text_pbuf_flags[p-&gt;flags],  (<span class="keywordtype">void</span> *)n, text_pbuf_flags[n-&gt;flags]);
00955         print_pbuf_counter(text);
00956 <span class="preprocessor">#endif</span>
00957 <span class="preprocessor"></span>
00958 
00959   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"p != NULL"</span>, p != NULL);
00960   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"n != NULL"</span>, n != NULL);
00961 
00962   <span class="keywordflow">if</span> ((p == <a class="code" href="def_8h.html#a2">NULL</a>) || (n == <a class="code" href="def_8h.html#a2">NULL</a>))
00963     <span class="keywordflow">return</span>;
00964 
00965   <span class="comment">/* iterate through all packets on queue */</span>
00966   <span class="keywordflow">while</span> (p-&gt;<a class="code" href="structpbuf.html#o0">next</a> != <a class="code" href="def_8h.html#a2">NULL</a>) {
00967 <span class="comment">/* be very picky about pbuf chain correctness */</span>
00968 <span class="preprocessor">#if PBUF_DEBUG</span>
00969 <span class="preprocessor"></span>    <span class="comment">/* iterate through all pbufs in packet */</span>
00970     <span class="keywordflow">while</span> (p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a> != p-&gt;<a class="code" href="structpbuf.html#o3">len</a>) {
00971       <span class="comment">/* make sure each packet is complete */</span>
00972       <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"p-&gt;next != NULL"</span>, p-&gt;<a class="code" href="structpbuf.html#o0">next</a> != NULL);
00973       p = p-&gt;<a class="code" href="structpbuf.html#o0">next</a>;
00974     }
00975 <span class="preprocessor">#endif</span>
00976 <span class="preprocessor"></span>    <span class="comment">/* now p-&gt;tot_len == p-&gt;len */</span>
00977     <span class="comment">/* proceed to next packet on queue */</span>
00978     p = p-&gt;<a class="code" href="structpbuf.html#o0">next</a>;
00979   }
00980   <span class="comment">/* chain last pbuf of h chain (p) with first of tail (t) */</span>
00981   p-&gt;<a class="code" href="structpbuf.html#o0">next</a> = n;
00982   <span class="comment">/* t is now referenced to one more time */</span>
00983   <a class="code" href="pbuf_8c.html#a16">pbuf_ref</a>(n);
00984   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(PBUF_DEBUG | DBG_FRESH | 2, (<span class="stringliteral">"pbuf_queue: referencing queued packet %p\n"</span>, (<span class="keywordtype">void</span> *)n));
00985 }
00986 
00994 <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *
00995 pbuf_dequeue(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p)
00996 {
00997   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *q;
00998 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
00999 <span class="preprocessor"></span>        <span class="keywordtype">char</span> text[200];
01000         sprintf(text, <span class="stringliteral">"pbuf_dequeue: p=%p, flag=%s"</span>, (<span class="keywordtype">void</span> *)p, text_pbuf_flags[p-&gt;flags]);
01001         print_pbuf_counter(text);
01002 <span class="preprocessor">#endif</span>
01003 <span class="preprocessor"></span>
01004   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"p != NULL"</span>, p != NULL);
01005 
01006   <span class="comment">/* iterate through all pbufs in packet */</span>
01007   <span class="keywordflow">while</span> (p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a> != p-&gt;<a class="code" href="structpbuf.html#o3">len</a>) {
01008     <span class="comment">/* make sure each packet is complete */</span>
01009     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"p-&gt;next != NULL"</span>, p-&gt;<a class="code" href="structpbuf.html#o0">next</a> != NULL);
01010     p = p-&gt;<a class="code" href="structpbuf.html#o0">next</a>;
01011   }
01012   <span class="comment">/* remember next packet on queue */</span>
01013   q = p-&gt;<a class="code" href="structpbuf.html#o0">next</a>;
01014   <span class="comment">/* dequeue p from queue */</span>
01015   p-&gt;<a class="code" href="structpbuf.html#o0">next</a> = <a class="code" href="def_8h.html#a2">NULL</a>;
01016   <span class="comment">/* q is now referenced to one less time */</span>
01017   <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(q);
01018   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(PBUF_DEBUG | DBG_FRESH | 2, (<span class="stringliteral">"pbuf_dequeue: dereferencing remaining queue %p\n"</span>, (<span class="keywordtype">void</span> *)q) );
01019 
01020 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
01021 <span class="preprocessor"></span>        <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(PBUF_DEBUG | 2, (<span class="stringliteral">"@@@pbuf_dequeue: dereferencing remaining queue %p\n"</span>, (<span class="keywordtype">void</span> *)q) );
01022 <span class="preprocessor">#endif</span>
01023 <span class="preprocessor"></span>  <span class="keywordflow">return</span> q;
01024 }
01025 <span class="preprocessor">#endif</span>
01026 <span class="preprocessor"></span>
01049 <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *
<a name="l01050"></a><a class="code" href="pbuf_8c.html#a18">01050</a> <a class="code" href="pbuf_8c.html#a18">pbuf_take</a>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p)
01051 {
01052   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *q , *prev, *head;
01053 
01054 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
01055 <span class="preprocessor"></span>        <span class="keywordtype">char</span> text[200];
01056         sprintf(text, <span class="stringliteral">"pbuf_take: p=%p, flag=%s"</span>, (<span class="keywordtype">void</span> *)p, pbufstats_text_pbuf_flags[p-&gt;<a class="code" href="structpbuf.html#o4">flags</a>]);
01057         pbufstats_print_pbuf_counter(text);
01058 <span class="preprocessor">#endif</span>
01059 <span class="preprocessor"></span>
01060   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"pbuf_take: p != NULL\n"</span>, p != <a class="code" href="def_8h.html#a2">NULL</a>);
01061   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 3, (<span class="stringliteral">"pbuf_take(%p)\n"</span>, (<span class="keywordtype">void</span>*)p));
01062 
01063   prev = <a class="code" href="def_8h.html#a2">NULL</a>;
01064   head = p;
01065   <span class="comment">/* iterate through pbuf chain */</span>
01066   <span class="keywordflow">do</span>
01067   {
01068     <span class="comment">/* pbuf is of type PBUF_REF? */</span>
01069     <span class="keywordflow">if</span> (p-&gt;flags == <a class="code" href="pbuf_8h.html#a5">PBUF_FLAG_REF</a>) {
01070       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"pbuf_take: encountered PBUF_REF %p\n"</span>, (<span class="keywordtype">void</span> *)p));
01071       <span class="comment">/* allocate a pbuf (w/ payload) fully in RAM */</span>
01072       <span class="comment">/* PBUF_POOL buffers are faster if we can use them */</span>
01073       <span class="keywordflow">if</span> (p-&gt;len &lt;= <a class="code" href="opt_8h.html#a15">PBUF_POOL_BUFSIZE</a>) {
01074         q = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(<a class="code" href="pbuf_8h.html#a26a10">PBUF_RAW</a>, p-&gt;len, <a class="code" href="pbuf_8h.html#a27a14">PBUF_POOL</a>);
01075         <span class="keywordflow">if</span> (q == <a class="code" href="def_8h.html#a2">NULL</a>) <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 2, (<span class="stringliteral">"pbuf_take: Could not allocate PBUF_POOL\n"</span>));
01076       } <span class="keywordflow">else</span> {
01077         <span class="comment">/* no replacement pbuf yet */</span>
01078         q = <a class="code" href="def_8h.html#a2">NULL</a>;
01079         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 2, (<span class="stringliteral">"pbuf_take: PBUF_POOL too small to replace PBUF_REF\n"</span>));
01080       }
01081       <span class="comment">/* no (large enough) PBUF_POOL was available? retry with PBUF_RAM */</span>
01082       <span class="keywordflow">if</span> (q == <a class="code" href="def_8h.html#a2">NULL</a>) {
01083         q = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(<a class="code" href="pbuf_8h.html#a26a10">PBUF_RAW</a>, p-&gt;len, <a class="code" href="pbuf_8h.html#a27a11">PBUF_RAM</a>);
01084         <span class="keywordflow">if</span> (q == <a class="code" href="def_8h.html#a2">NULL</a>) <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 2, (<span class="stringliteral">"pbuf_take: Could not allocate PBUF_RAM\n"</span>));
01085       }
01086       <span class="comment">/* replacement pbuf could be allocated? */</span>
01087       <span class="keywordflow">if</span> (q != <a class="code" href="def_8h.html#a2">NULL</a>)
01088       {
01089         <span class="comment">/* copy p to q */</span>
01090         <span class="comment">/* copy successor */</span>
01091         q-&gt;next = p-&gt;next;
01092         <span class="comment">/* remove linkage from original pbuf */</span>
01093         p-&gt;next = <a class="code" href="def_8h.html#a2">NULL</a>;
01094         <span class="comment">/* remove linkage to original pbuf */</span>
01095         <span class="keywordflow">if</span> (prev != <a class="code" href="def_8h.html#a2">NULL</a>) {
01096           <span class="comment">/* prev-&gt;next == p at this point */</span>
01097           <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"prev-&gt;next == p"</span>, prev-&gt;next == p);
01098           <span class="comment">/* break chain and insert new pbuf instead */</span>
01099           prev-&gt;next = q;
01100         <span class="comment">/* prev == NULL, so we replaced the head pbuf of the chain */</span>
01101         } <span class="keywordflow">else</span> {
01102           head = q;
01103         }
01104         <span class="comment">/* copy pbuf payload */</span>
01105         memcpy(q-&gt;payload, p-&gt;payload, p-&gt;len);
01106         q-&gt;tot_len = p-&gt;tot_len;
01107         q-&gt;len = p-&gt;len;
01108         <span class="comment">/* in case p was the first pbuf, it is no longer refered to by</span>
01109 <span class="comment">         * our caller, as the caller MUST do p = pbuf_take(p);</span>
01110 <span class="comment">         * in case p was not the first pbuf, it is no longer refered to</span>
01111 <span class="comment">         * by prev. we can safely free the pbuf here.</span>
01112 <span class="comment">         * (note that we have set p-&gt;next to NULL already so that</span>
01113 <span class="comment">         * we will not free the rest of the chain by accident.)</span>
01114 <span class="comment">         */</span>
01115         <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
01116         <span class="comment">/* do not copy ref, since someone else might be using the old buffer */</span>
01117         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a>, (<span class="stringliteral">"pbuf_take: replaced PBUF_REF %p with %p\n"</span>, (<span class="keywordtype">void</span> *)p, (<span class="keywordtype">void</span> *)q));
01118         p = q;
01119       } <span class="keywordflow">else</span> {
01120         <span class="comment">/* deallocate chain */</span>
01121         <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(head);
01122         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | 2, (<span class="stringliteral">"pbuf_take: failed to allocate replacement pbuf for %p\n"</span>, (<span class="keywordtype">void</span> *)p));
01123         <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
01124       }
01125     <span class="comment">/* p-&gt;flags != PBUF_FLAG_REF */</span>
01126     } <span class="keywordflow">else</span> {
01127       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 1, (<span class="stringliteral">"pbuf_take: skipping pbuf not of type PBUF_REF\n"</span>));
01128     }
01129     <span class="comment">/* remember this pbuf */</span>
01130     prev = p;
01131     <span class="comment">/* proceed to next pbuf in original chain */</span>
01132     p = p-&gt;next;
01133   } <span class="keywordflow">while</span> (p);
01134   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 1, (<span class="stringliteral">"pbuf_take: end of chain reached.\n"</span>));
01135 
01136   <span class="keywordflow">return</span> head;
01137 }
01138 
01147 <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *
<a name="l01148"></a><a class="code" href="pbuf_8c.html#a19">01148</a> <a class="code" href="pbuf_8c.html#a19">pbuf_dechain</a>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p)
01149 {
01150   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *q;
01151   u8_t tail_gone = 1;
01152 <span class="preprocessor">#ifdef PBUF_DEBUG</span>
01153 <span class="preprocessor"></span>        <span class="keywordtype">char</span> text[200];
01154         sprintf(text, <span class="stringliteral">"pbuf_dechain: p=%p, flag=%s"</span>, (<span class="keywordtype">void</span>*)p, pbufstats_text_pbuf_flags[p-&gt;<a class="code" href="structpbuf.html#o4">flags</a>]);
01155         pbufstats_print_pbuf_counter(text);
01156 <span class="preprocessor">#endif</span>
01157 <span class="preprocessor"></span>
01158   <span class="comment">/* tail */</span>
01159   q = p-&gt;next;
01160   <span class="comment">/* pbuf has successor in chain? */</span>
01161   <span class="keywordflow">if</span> (q != <a class="code" href="def_8h.html#a2">NULL</a>) {
01162     <span class="comment">/* assert tot_len invariant: (p-&gt;tot_len == p-&gt;len + (p-&gt;next? p-&gt;next-&gt;tot_len: 0) */</span>
01163     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"p-&gt;tot_len == p-&gt;len + q-&gt;tot_len"</span>, q-&gt;tot_len == p-&gt;tot_len - p-&gt;len);
01164     <span class="comment">/* enforce invariant if assertion is disabled */</span>
01165     q-&gt;tot_len = p-&gt;tot_len - p-&gt;len;
01166     <span class="comment">/* decouple pbuf from remainder */</span>
01167     p-&gt;next = <a class="code" href="def_8h.html#a2">NULL</a>;
01168     <span class="comment">/* total length of pbuf p is its own length only */</span>
01169     p-&gt;tot_len = p-&gt;len;
01170     <span class="comment">/* q is no longer referenced by p, free it */</span>
01171     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a8">DBG_STATE</a>, (<span class="stringliteral">"pbuf_dechain: unreferencing %p\n"</span>, (<span class="keywordtype">void</span> *)q));
01172     tail_gone = <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(q);
01173     <span class="keywordflow">if</span> (tail_gone &gt; 0) <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a62">PBUF_DEBUG</a> | <a class="code" href="debug_8h.html#a8">DBG_STATE</a>,
01174       (<span class="stringliteral">"pbuf_dechain: deallocated %p (as it is no longer referenced)\n"</span>, (<span class="keywordtype">void</span> *)q));
01175     <span class="comment">/* return remaining tail or NULL if deallocated */</span>
01176   }
01177   <span class="comment">/* assert tot_len invariant: (p-&gt;tot_len == p-&gt;len + (p-&gt;next? p-&gt;next-&gt;tot_len: 0) */</span>
01178   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"p-&gt;tot_len == p-&gt;len"</span>, p-&gt;tot_len == p-&gt;len);
01179   <span class="keywordflow">return</span> (tail_gone &gt; 0? <a class="code" href="def_8h.html#a2">NULL</a>: q);
01180 }
01181 
01182 <span class="comment">/* TODO: This function is unused in the lwIP stack and will be deprecated. This is due</span>
01183 <span class="comment"> * to the new way chains are built. */</span>
01184 <span class="preprocessor">#if 0</span>
01185 <span class="preprocessor"></span>
01192 <span class="keywordtype">void</span>
01193 <a class="code" href="pbuf_8h.html#a20">pbuf_ref_chain</a>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p)
01194 {
01195   <a class="code" href="sys_8h.html#a1">SYS_ARCH_DECL_PROTECT</a>(old_level);
01196   <a class="code" href="sys_8h.html#a2">SYS_ARCH_PROTECT</a>(old_level);
01197 
01198   <span class="keywordflow">while</span> (p != <a class="code" href="def_8h.html#a2">NULL</a>) {
01199     ++p-&gt;<a class="code" href="structpbuf.html#o5">ref</a>;
01200     p = p-&gt;<a class="code" href="structpbuf.html#o0">next</a>;
01201   }
01202   <a class="code" href="sys_8h.html#a3">SYS_ARCH_UNPROTECT</a>(old_level);
01203 }
01204 <span class="preprocessor">#endif</span>
</pre></div>	</td>
  </tr>
</table>
<hr>
<div align="center">Copyright (c) 2001-2003 Swedish Institute of Computer Science</div>
</html>
