
<html>
<head>
<title>lwIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="doxygen.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<table width="98%" border="0" align="center">
  <tr>
    <td>
      <h2>lwIP code documentation</h2>
<hr>

<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>etharp.c</h1><a href="etharp_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00011 <span class="comment">/*</span>
00012 <span class="comment"> * Copyright (c) 2001-2003 Swedish Institute of Computer Science.</span>
00013 <span class="comment"> * All rights reserved.</span>
00014 <span class="comment"> *</span>
00015 <span class="comment"> * Redistribution and use in source and binary forms, with or without modification,</span>
00016 <span class="comment"> * are permitted provided that the following conditions are met:</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span>
00019 <span class="comment"> *    this list of conditions and the following disclaimer.</span>
00020 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
00021 <span class="comment"> *    this list of conditions and the following disclaimer in the documentation</span>
00022 <span class="comment"> *    and/or other materials provided with the distribution.</span>
00023 <span class="comment"> * 3. The name of the author may not be used to endorse or promote products</span>
00024 <span class="comment"> *    derived from this software without specific prior written permission.</span>
00025 <span class="comment"> *</span>
00026 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED</span>
00027 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
00028 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT</span>
00029 <span class="comment"> * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
00030 <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT</span>
00031 <span class="comment"> * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
00032 <span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
00033 <span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
00034 <span class="comment"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY</span>
00035 <span class="comment"> * OF SUCH DAMAGE.</span>
00036 <span class="comment"> *</span>
00037 <span class="comment"> * This file is part of the lwIP TCP/IP stack.</span>
00038 <span class="comment"> *</span>
00039 <span class="comment"> * Author: Adam Dunkels &lt;adam@sics.se&gt;</span>
00040 <span class="comment"> *</span>
00041 <span class="comment"> */</span>
00042 
00043 <span class="comment">/*</span>
00044 <span class="comment"> * TODO:</span>
00045 <span class="comment"> *</span>
00046 <span class="comment">RFC 3220 4.6          IP Mobility Support for IPv4          January 2002</span>
00047 <span class="comment"></span>
00048 <span class="comment">      -  A Gratuitous ARP [45] is an ARP packet sent by a node in order</span>
00049 <span class="comment">         to spontaneously cause other nodes to update an entry in their</span>
00050 <span class="comment">         ARP cache.  A gratuitous ARP MAY use either an ARP Request or</span>
00051 <span class="comment">         an ARP Reply packet.  In either case, the ARP Sender Protocol</span>
00052 <span class="comment">         Address and ARP Target Protocol Address are both set to the IP</span>
00053 <span class="comment">         address of the cache entry to be updated, and the ARP Sender</span>
00054 <span class="comment">         Hardware Address is set to the link-layer address to which this</span>
00055 <span class="comment">         cache entry should be updated.  When using an ARP Reply packet,</span>
00056 <span class="comment">         the Target Hardware Address is also set to the link-layer</span>
00057 <span class="comment">         address to which this cache entry should be updated (this field</span>
00058 <span class="comment">         is not used in an ARP Request packet).</span>
00059 <span class="comment"></span>
00060 <span class="comment">         In either case, for a gratuitous ARP, the ARP packet MUST be</span>
00061 <span class="comment">         transmitted as a local broadcast packet on the local link.  As</span>
00062 <span class="comment">         specified in [36], any node receiving any ARP packet (Request</span>
00063 <span class="comment">         or Reply) MUST update its local ARP cache with the Sender</span>
00064 <span class="comment">         Protocol and Hardware Addresses in the ARP packet, if the</span>
00065 <span class="comment">         receiving node has an entry for that IP address already in its</span>
00066 <span class="comment">         ARP cache.  This requirement in the ARP protocol applies even</span>
00067 <span class="comment">         for ARP Request packets, and for ARP Reply packets that do not</span>
00068 <span class="comment">         match any ARP Request transmitted by the receiving node [36].</span>
00069 <span class="comment">*</span>
00070 <span class="comment">  My suggestion would be to send a ARP request for our newly obtained</span>
00071 <span class="comment">  address upon configuration of an Ethernet interface.</span>
00072 <span class="comment"></span>
00073 <span class="comment">*/</span>
00074 
00075 <span class="preprocessor">#include "<a class="code" href="opt_8h.html">lwip/opt.h</a>"</span>
00076 <span class="preprocessor">#include "lwip/inet.h"</span>
00077 <span class="preprocessor">#include "<a class="code" href="etharp_8h.html">netif/etharp.h</a>"</span>
00078 <span class="preprocessor">#include "lwip/ip.h"</span>
00079 <span class="preprocessor">#include "<a class="code" href="stats_8h.html">lwip/stats.h</a>"</span>
00080 
00081 <span class="comment">/* ARP needs to inform DHCP of any ARP replies? */</span>
00082 <span class="preprocessor">#if (LWIP_DHCP &amp;&amp; DHCP_DOES_ARP_CHECK)</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#  include "<a class="code" href="dhcp_8h.html">lwip/dhcp.h</a>"</span>
00084 <span class="preprocessor">#endif</span>
00085 <span class="preprocessor"></span>
<a name="l00087"></a><a class="code" href="etharp_8c.html#a0">00087</a> <span class="preprocessor">#define ARP_MAXAGE 120</span>
00088 <span class="preprocessor"></span>
<a name="l00089"></a><a class="code" href="etharp_8c.html#a1">00089</a> <span class="preprocessor">#define ARP_MAXPENDING 2</span>
00090 <span class="preprocessor"></span>
<a name="l00091"></a><a class="code" href="etharp_8c.html#a2">00091</a> <span class="preprocessor">#define HWTYPE_ETHERNET 1</span>
00092 <span class="preprocessor"></span>
<a name="l00094"></a><a class="code" href="etharp_8c.html#a3">00094</a> <span class="preprocessor">#define ARP_REQUEST 1</span>
<a name="l00095"></a><a class="code" href="etharp_8c.html#a4">00095</a> <span class="preprocessor"></span><span class="preprocessor">#define ARP_REPLY 2</span>
00096 <span class="preprocessor"></span>
<a name="l00097"></a><a class="code" href="etharp_8c.html#a5">00097</a> <span class="preprocessor">#define ARPH_HWLEN(hdr) (ntohs((hdr)-&gt;_hwlen_protolen) &gt;&gt; 8)</span>
<a name="l00098"></a><a class="code" href="etharp_8c.html#a6">00098</a> <span class="preprocessor"></span><span class="preprocessor">#define ARPH_PROTOLEN(hdr) (ntohs((hdr)-&gt;_hwlen_protolen) &amp; 0xff)</span>
00099 <span class="preprocessor"></span>
<a name="l00100"></a><a class="code" href="etharp_8c.html#a7">00100</a> <span class="preprocessor">#define ARPH_HWLEN_SET(hdr, len) (hdr)-&gt;_hwlen_protolen = htons(ARPH_PROTOLEN(hdr) | ((len) &lt;&lt; 8))</span>
<a name="l00101"></a><a class="code" href="etharp_8c.html#a8">00101</a> <span class="preprocessor"></span><span class="preprocessor">#define ARPH_PROTOLEN_SET(hdr, len) (hdr)-&gt;_hwlen_protolen = htons((len) | (ARPH_HWLEN(hdr) &lt;&lt; 8))</span>
00102 <span class="preprocessor"></span>
<a name="l00103"></a><a class="code" href="etharp_8c.html#a23">00103</a> <span class="keyword">enum</span> <a class="code" href="etharp_8c.html#a23">etharp_state</a> {
00104   <a class="code" href="etharp_8c.html#a23a12">ETHARP_STATE_EMPTY</a>,
00105   <a class="code" href="etharp_8c.html#a23a13">ETHARP_STATE_PENDING</a>,
00106   <a class="code" href="etharp_8c.html#a23a14">ETHARP_STATE_STABLE</a>
00107 };
00108 
<a name="l00109"></a><a class="code" href="structetharp__entry.html">00109</a> <span class="keyword">struct </span><a class="code" href="structetharp__entry.html">etharp_entry</a> {
<a name="l00110"></a><a class="code" href="structetharp__entry.html#o0">00110</a>   <span class="keyword">struct </span><a class="code" href="structip__addr.html">ip_addr</a> ipaddr;
<a name="l00111"></a><a class="code" href="structetharp__entry.html#o1">00111</a>   <span class="keyword">struct </span><a class="code" href="structeth__addr.html">eth_addr</a> ethaddr;
<a name="l00112"></a><a class="code" href="structetharp__entry.html#o2">00112</a>   <span class="keyword">enum</span> <a class="code" href="etharp_8c.html#a23">etharp_state</a> <a class="code" href="structetharp__entry.html#o2">state</a>;
00113 <span class="preprocessor">#if ARP_QUEUEING</span>
00114 <span class="preprocessor"></span>  <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p;
00115 <span class="preprocessor">#endif</span>
<a name="l00116"></a><a class="code" href="structetharp__entry.html#o3">00116</a> <span class="preprocessor"></span>  u8_t <a class="code" href="structetharp__entry.html#o3">ctime</a>;
00117 };
00118 
<a name="l00119"></a><a class="code" href="etharp_8c.html#a10">00119</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structeth__addr.html">eth_addr</a> <a class="code" href="etharp_8c.html#a10">ethbroadcast</a> = {{0xff,0xff,0xff,0xff,0xff,0xff}};
<a name="l00120"></a><a class="code" href="etharp_8c.html#a11">00120</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structetharp__entry.html">etharp_entry</a> <a class="code" href="etharp_8c.html#a11">arp_table</a>[<a class="code" href="opt_8h.html#a17">ARP_TABLE_SIZE</a>];
00121 
00122 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *<a class="code" href="etharp_8c.html#a15">update_arp_entry</a>(<span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *ipaddr, <span class="keyword">struct</span> <a class="code" href="structeth__addr.html">eth_addr</a> *ethaddr, u8_t flags);
<a name="l00123"></a><a class="code" href="etharp_8c.html#a9">00123</a> <span class="preprocessor">#define ARP_INSERT_FLAG 1</span>
00124 <span class="preprocessor"></span>
00128 <span class="keywordtype">void</span>
<a name="l00129"></a><a class="code" href="etharp_8c.html#a16">00129</a> <a class="code" href="etharp_8c.html#a16">etharp_init</a>(<span class="keywordtype">void</span>)
00130 {
00131   u8_t i;
00132   <span class="comment">/* clear ARP entries */</span>
00133   <span class="keywordflow">for</span>(i = 0; i &lt; <a class="code" href="opt_8h.html#a17">ARP_TABLE_SIZE</a>; ++i) {
00134     <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> = <a class="code" href="etharp_8c.html#a23a12">ETHARP_STATE_EMPTY</a>;
00135 <span class="preprocessor">#if ARP_QUEUEING</span>
00136 <span class="preprocessor"></span>    <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p = <a class="code" href="def_8h.html#a2">NULL</a>;
00137 <span class="preprocessor">#endif</span>
00138 <span class="preprocessor"></span>  }
00139 }
00140 
00147 <span class="keywordtype">void</span>
<a name="l00148"></a><a class="code" href="etharp_8c.html#a17">00148</a> <a class="code" href="etharp_8c.html#a17">etharp_tmr</a>(<span class="keywordtype">void</span>)
00149 {
00150   u8_t i;
00151 
00152   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a>, (<span class="stringliteral">"etharp_timer\n"</span>));
00153   <span class="comment">/* remove expired entries from the ARP table */</span>
00154   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="opt_8h.html#a17">ARP_TABLE_SIZE</a>; ++i) {
00155     <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o3">ctime</a>++;
00156     <span class="keywordflow">if</span> ((<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> == <a class="code" href="etharp_8c.html#a23a14">ETHARP_STATE_STABLE</a>) &amp;&amp;
00157         (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o3">ctime</a> &gt;= <a class="code" href="etharp_8c.html#a0">ARP_MAXAGE</a>)) {
00158       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a>, (<span class="stringliteral">"etharp_timer: expired stable entry %u.\n"</span>, i));
00159       <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> = <a class="code" href="etharp_8c.html#a23a12">ETHARP_STATE_EMPTY</a>;
00160 <span class="preprocessor">#if ARP_QUEUEING</span>
00161 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p != <a class="code" href="def_8h.html#a2">NULL</a>) {
00162         <span class="comment">/* remove any queued packet */</span>
00163         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a>, (<span class="stringliteral">"etharp_timer: freeing packet queue %p.\n"</span>, i, (<span class="keywordtype">void</span> *)(<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p)));
00164         <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p);
00165         <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p = <a class="code" href="def_8h.html#a2">NULL</a>;
00166       }
00167 <span class="preprocessor">#endif</span>
00168 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> == <a class="code" href="etharp_8c.html#a23a13">ETHARP_STATE_PENDING</a>) &amp;&amp;
00169         (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o3">ctime</a> &gt;= <a class="code" href="etharp_8c.html#a1">ARP_MAXPENDING</a>)) {
00170       <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> = <a class="code" href="etharp_8c.html#a23a12">ETHARP_STATE_EMPTY</a>;
00171       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a>, (<span class="stringliteral">"etharp_timer: expired pending entry %u.\n"</span>, i));
00172 <span class="preprocessor">#if ARP_QUEUEING</span>
00173 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p != <a class="code" href="def_8h.html#a2">NULL</a>) {
00174         <span class="comment">/* remove any queued packet */</span>
00175         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a>, (<span class="stringliteral">"etharp_timer: freeing packet queue %p.\n"</span>, i, (<span class="keywordtype">void</span> *)(<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p)));
00176         <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p);
00177         <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p = <a class="code" href="def_8h.html#a2">NULL</a>;
00178       }
00179 <span class="preprocessor">#endif</span>
00180 <span class="preprocessor"></span>    }
00181   }
00182 }
00183 
00191 <span class="keyword">static</span> u8_t
<a name="l00192"></a><a class="code" href="etharp_8c.html#a18">00192</a> <a class="code" href="etharp_8c.html#a18">find_arp_entry</a>(<span class="keywordtype">void</span>)
00193 {
00194   u8_t i, j, maxtime;
00195 
00196   <span class="comment">/* Try to find an unused entry in the ARP table. */</span>
00197   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="opt_8h.html#a17">ARP_TABLE_SIZE</a>; ++i) {
00198     <span class="keywordflow">if</span> (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> == <a class="code" href="etharp_8c.html#a23a12">ETHARP_STATE_EMPTY</a>) {
00199       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a>, (<span class="stringliteral">"find_arp_entry: found empty entry %u\n"</span>, i));
00200       <span class="keywordflow">break</span>;
00201     }
00202   }
00203 
00204   <span class="comment">/* If no unused entry is found, we try to find the oldest entry and</span>
00205 <span class="comment">     throw it away. If all entries are new and have 0 ctime drop one  */</span>
00206   <span class="keywordflow">if</span> (i == <a class="code" href="opt_8h.html#a17">ARP_TABLE_SIZE</a>) {
00207     maxtime = 0;
00208     j = <a class="code" href="opt_8h.html#a17">ARP_TABLE_SIZE</a>;
00209     <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="opt_8h.html#a17">ARP_TABLE_SIZE</a>; ++i) {
00210       <span class="comment">/* remember entry with oldest stable entry in j*/</span>
00211       <span class="keywordflow">if</span> ((<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> == <a class="code" href="etharp_8c.html#a23a14">ETHARP_STATE_STABLE</a>) &amp;&amp;
00212 <span class="preprocessor">#if ARP_QUEUEING </span><span class="comment">/* do not want to re-use an entry with queued packets */</span>
00213       (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p == <a class="code" href="def_8h.html#a2">NULL</a>) &amp;&amp;
00214 <span class="preprocessor">#endif</span>
00215 <span class="preprocessor"></span>      (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o3">ctime</a> &gt;= maxtime)) {
00216         maxtime = <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o3">ctime</a>;
00217         j = i;
00218       }
00219     }
00220     <span class="keywordflow">if</span> (j != <a class="code" href="opt_8h.html#a17">ARP_TABLE_SIZE</a>) {
00221       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a>, (<span class="stringliteral">"find_arp_entry: found oldest stable entry %u\n"</span>, j));
00222     } <span class="keywordflow">else</span> {
00223       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a>, (<span class="stringliteral">"find_arp_entry: no replacable entry could be found\n"</span>));
00224     }
00225     i = j;
00226   }
00227   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a>, (<span class="stringliteral">"find_arp_entry: returning %u, state %u\n"</span>, i, <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].state));
00228   <span class="keywordflow">return</span> i;
00229 }
00230 
00245 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *
<a name="l00246"></a><a class="code" href="etharp_8c.html#a15">00246</a> <a class="code" href="etharp_8c.html#a15">update_arp_entry</a>(<span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *ipaddr, <span class="keyword">struct</span> <a class="code" href="structeth__addr.html">eth_addr</a> *ethaddr, u8_t flags)
00247 {
00248   u8_t i, k;
00249   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 3, (<span class="stringliteral">"update_arp_entry()\n"</span>));
00250   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"netif-&gt;hwaddr_len != 0"</span>, netif-&gt;<a class="code" href="structnetif.html#o8">hwaddr_len</a> != 0);
00251   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"update_arp_entry: %u.%u.%u.%u - %02x:%02x:%02x:%02x:%02x:%02x\n"</span>, <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a34">ip4_addr1</a>(ipaddr), <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a35">ip4_addr2</a>(ipaddr), <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a36">ip4_addr3</a>(ipaddr), <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a37">ip4_addr4</a>(ipaddr),
00252   ethaddr-&gt;addr[0], ethaddr-&gt;addr[1], ethaddr-&gt;addr[2], ethaddr-&gt;addr[3], ethaddr-&gt;addr[4], ethaddr-&gt;addr[5]));
00253   <span class="comment">/* do not update for 0.0.0.0 addresses */</span>
00254   <span class="keywordflow">if</span> (ipaddr-&gt;<a class="code" href="structip__addr.html#o0">addr</a> == 0) {
00255     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"update_arp_entry: will not add 0.0.0.0 to ARP cache\n"</span>));
00256     <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00257   }
00258   <span class="comment">/* Walk through the ARP mapping table and try to find an entry to</span>
00259 <span class="comment">  update. If none is found, the IP -&gt; MAC address mapping is</span>
00260 <span class="comment">  inserted in the ARP table. */</span>
00261   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="opt_8h.html#a17">ARP_TABLE_SIZE</a>; ++i) {
00262     <span class="comment">/* Check if the source IP address of the incoming packet matches</span>
00263 <span class="comment">    the IP address in this ARP table entry. */</span>
00264     <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(ipaddr, &amp;<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].ipaddr)) {
00265       <span class="comment">/* pending entry? */</span>
00266       <span class="keywordflow">if</span> (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> == <a class="code" href="etharp_8c.html#a23a13">ETHARP_STATE_PENDING</a>) {
00267         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"update_arp_entry: pending entry %u goes stable\n"</span>, i));
00268         <span class="comment">/* A pending entry was found, mark it stable */</span>
00269         <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> = <a class="code" href="etharp_8c.html#a23a14">ETHARP_STATE_STABLE</a>;
00270         <span class="comment">/* fall-through to next if */</span>
00271       }
00272       <span class="comment">/* stable entry? (possible just marked to become stable) */</span>
00273       <span class="keywordflow">if</span> (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> == <a class="code" href="etharp_8c.html#a23a14">ETHARP_STATE_STABLE</a>) {
00274 <span class="preprocessor">#if ARP_QUEUEING</span>
00275 <span class="preprocessor"></span>        <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p;
00276         <span class="keyword">struct </span><a class="code" href="structeth__hdr.html">eth_hdr</a> *ethhdr;
00277 <span class="preprocessor">#endif</span>
00278 <span class="preprocessor"></span>        <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"update_arp_entry: updating stable entry %u\n"</span>, i));
00279         <span class="comment">/* An old entry found, update this and return. */</span>
00280         <span class="keywordflow">for</span> (k = 0; k &lt; netif-&gt;<a class="code" href="structnetif.html#o8">hwaddr_len</a>; ++k) {
00281           <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o1">ethaddr</a>.addr[k] = ethaddr-&gt;addr[k];
00282         }
00283         <span class="comment">/* reset time stamp */</span>
00284         <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o3">ctime</a> = 0;
00285 <span class="preprocessor">#if ARP_QUEUEING</span>
00286 <span class="preprocessor"></span>        p = <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p;
00287         <span class="comment">/* queued packet present? */</span>
00288         <span class="keywordflow">if</span> (p != <a class="code" href="def_8h.html#a2">NULL</a>) {
00289           <span class="comment">/* NULL attached buffer immediately */</span>
00290           <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p = <a class="code" href="def_8h.html#a2">NULL</a>;
00291           <span class="comment">/* fill-in Ethernet header */</span>
00292           ethhdr = p-&gt;payload;
00293           <span class="keywordflow">for</span> (k = 0; k &lt; netif-&gt;<a class="code" href="structnetif.html#o8">hwaddr_len</a>; ++k) {
00294             ethhdr-&gt;dest.addr[k] = ethaddr-&gt;addr[k];
00295           }
00296           ethhdr-&gt;type = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(<a class="code" href="etharp_8h.html#a2">ETHTYPE_IP</a>);
00297           <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"update_arp_entry: sending queued IP packet.\n"</span>));
00298           <span class="comment">/* send the queued IP packet */</span>
00299           netif-&gt;<a class="code" href="structnetif.html#o6">linkoutput</a>(netif, p);
00300           <span class="comment">/* free the queued IP packet */</span>
00301           <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00302         }
00303 <span class="preprocessor">#endif</span>
00304 <span class="preprocessor"></span>        <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00305       }
00306     } <span class="comment">/* if */</span>
00307   } <span class="comment">/* for */</span>
00308 
00309   <span class="comment">/* no matching ARP entry was found */</span>
00310   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"update_arp_entry: i == ARP_TABLE_SIZE"</span>, i == <a class="code" href="opt_8h.html#a17">ARP_TABLE_SIZE</a>);
00311 
00312   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"update_arp_entry: IP address not yet in table\n"</span>));
00313   <span class="comment">/* allowed to insert an entry? */</span>
00314   <span class="keywordflow">if</span> ((<a class="code" href="opt_8h.html#a20">ETHARP_ALWAYS_INSERT</a>) || (flags &amp; <a class="code" href="etharp_8c.html#a9">ARP_INSERT_FLAG</a>))
00315   {
00316     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"update_arp_entry: adding entry to table\n"</span>));
00317     <span class="comment">/* find an empty or old entry. */</span>
00318     i = <a class="code" href="etharp_8c.html#a18">find_arp_entry</a>();
00319     <span class="keywordflow">if</span> (i == <a class="code" href="opt_8h.html#a17">ARP_TABLE_SIZE</a>) {
00320       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"update_arp_entry: no available entry found\n"</span>));
00321       <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00322     }
00323     <span class="comment">/* see if find_arp_entry() gave us an old stable, or empty entry to re-use */</span>
00324     <span class="keywordflow">if</span> (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> == <a class="code" href="etharp_8c.html#a23a14">ETHARP_STATE_STABLE</a>) {
00325       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"update_arp_entry: overwriting old stable entry %u\n"</span>, i));
00326       <span class="comment">/* stable entries should have no queued packets (TODO: allow later) */</span>
00327 <span class="preprocessor">#if ARP_QUEUEING</span>
00328 <span class="preprocessor"></span>      <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"update_arp_entry: arp_table[i].p == NULL"</span>, <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p == <a class="code" href="def_8h.html#a2">NULL</a>);
00329 <span class="preprocessor">#endif</span>
00330 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
00331       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | <a class="code" href="debug_8h.html#a8">DBG_STATE</a>, (<span class="stringliteral">"update_arp_entry: filling empty entry %u with state %u\n"</span>, i, <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].state));
00332       <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"update_arp_entry: arp_table[i].state == ETHARP_STATE_EMPTY"</span>, <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].state == <a class="code" href="etharp_8c.html#a23a12">ETHARP_STATE_EMPTY</a>);
00333     }
00334     <span class="comment">/* set IP address */</span>
00335     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a27">ip_addr_set</a>(&amp;<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].ipaddr, ipaddr);
00336     <span class="comment">/* set Ethernet hardware address */</span>
00337     <span class="keywordflow">for</span> (k = 0; k &lt; netif-&gt;<a class="code" href="structnetif.html#o8">hwaddr_len</a>; ++k) {
00338       <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o1">ethaddr</a>.addr[k] = ethaddr-&gt;addr[k];
00339     }
00340     <span class="comment">/* reset time-stamp */</span>
00341     <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o3">ctime</a> = 0;
00342     <span class="comment">/* mark as stable */</span>
00343     <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> = <a class="code" href="etharp_8c.html#a23a14">ETHARP_STATE_STABLE</a>;
00344     <span class="comment">/* no queued packet */</span>
00345 <span class="preprocessor">#if ARP_QUEUEING</span>
00346 <span class="preprocessor"></span>    <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p = <a class="code" href="def_8h.html#a2">NULL</a>;
00347 <span class="preprocessor">#endif</span>
00348 <span class="preprocessor"></span>  }
00349   <span class="keywordflow">else</span>
00350   {
00351     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"update_arp_entry: no matching stable entry to update\n"</span>));
00352   }
00353   <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00354 }
00355 
00371 <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *
<a name="l00372"></a><a class="code" href="etharp_8c.html#a19">00372</a> <a class="code" href="etharp_8c.html#a19">etharp_ip_input</a>(<span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p)
00373 {
00374   <span class="keyword">struct </span><a class="code" href="structethip__hdr.html">ethip_hdr</a> *hdr;
00375 
00376   <span class="comment">/* Only insert an entry if the source IP address of the</span>
00377 <span class="comment">     incoming IP packet comes from a host on the local network. */</span>
00378   hdr = p-&gt;<a class="code" href="structpbuf.html#o1">payload</a>;
00379   <span class="comment">/* source is on local network? */</span>
00380   <span class="keywordflow">if</span> (!<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a28">ip_addr_maskcmp</a>(&amp;(hdr-&gt;ip.src), &amp;(netif-&gt;<a class="code" href="structnetif.html#o1">ip_addr</a>), &amp;(netif-&gt;<a class="code" href="structnetif.html#o2">netmask</a>))) {
00381     <span class="comment">/* do nothing */</span>
00382     <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00383   }
00384 
00385   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"etharp_ip_input: updating ETHARP table.\n"</span>));
00386   <span class="comment">/* update ARP table, ask to insert entry */</span>
00387   <a class="code" href="etharp_8c.html#a15">update_arp_entry</a>(netif, &amp;(hdr-&gt;ip.src), &amp;(hdr-&gt;eth.src), <a class="code" href="etharp_8c.html#a9">ARP_INSERT_FLAG</a>);
00388   <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00389 }
00390 
00391 
00406 <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *
<a name="l00407"></a><a class="code" href="etharp_8c.html#a20">00407</a> <a class="code" href="etharp_8c.html#a20">etharp_arp_input</a>(<span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>, <span class="keyword">struct</span> <a class="code" href="structeth__addr.html">eth_addr</a> *ethaddr, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p)
00408 {
00409   <span class="keyword">struct </span><a class="code" href="structetharp__hdr.html">etharp_hdr</a> *hdr;
00410   u8_t i;
00411 
00412   <span class="comment">/* drop short ARP packets */</span>
00413   <span class="keywordflow">if</span> (p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a> &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structetharp__hdr.html">etharp_hdr</a>)) {
00414     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 1, (<span class="stringliteral">"etharp_arp_input: packet too short (%d/%d)\n"</span>, p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structetharp__hdr.html">etharp_hdr</a>)));
00415     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00416     <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00417   }
00418 
00419   hdr = p-&gt;<a class="code" href="structpbuf.html#o1">payload</a>;
00420 
00421   <span class="keywordflow">switch</span> (<a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(hdr-&gt;opcode)) {
00422   <span class="comment">/* ARP request? */</span>
00423   <span class="keywordflow">case</span> <a class="code" href="etharp_8c.html#a3">ARP_REQUEST</a>:
00424     <span class="comment">/* ARP request. If it asked for our address, we send out a</span>
00425 <span class="comment">    reply. In any case, we time-stamp any existing ARP entry,</span>
00426 <span class="comment">    and possiby send out an IP packet that was queued on it. */</span>
00427 
00428     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a> (<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"etharp_arp_input: incoming ARP request\n"</span>));
00429     <span class="comment">/* we are not configured? */</span>
00430     <span class="keywordflow">if</span> (netif-&gt;<a class="code" href="structnetif.html#o1">ip_addr</a>.<a class="code" href="structip__addr.html#o0">addr</a> == 0) {
00431       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"etharp_arp_input: we are unconfigured, ARP request ignored.\n"</span>));
00432       <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00433       <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00434     }
00435     <span class="comment">/* update the ARP cache */</span>
00436     <a class="code" href="etharp_8c.html#a15">update_arp_entry</a>(netif, &amp;(hdr-&gt;sipaddr), &amp;(hdr-&gt;shwaddr), 0);
00437     <span class="comment">/* ARP request for our address? */</span>
00438     <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(hdr-&gt;dipaddr), &amp;(netif-&gt;<a class="code" href="structnetif.html#o1">ip_addr</a>))) {
00439 
00440       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"etharp_arp_input: replying to ARP request for our IP address\n"</span>));
00441       <span class="comment">/* re-use pbuf to send ARP reply */</span>
00442       hdr-&gt;opcode = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(<a class="code" href="etharp_8c.html#a4">ARP_REPLY</a>);
00443 
00444       <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a27">ip_addr_set</a>(&amp;(hdr-&gt;dipaddr), &amp;(hdr-&gt;sipaddr));
00445       <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a27">ip_addr_set</a>(&amp;(hdr-&gt;sipaddr), &amp;(netif-&gt;<a class="code" href="structnetif.html#o1">ip_addr</a>));
00446 
00447       <span class="keywordflow">for</span>(i = 0; i &lt; netif-&gt;<a class="code" href="structnetif.html#o8">hwaddr_len</a>; ++i) {
00448         hdr-&gt;dhwaddr.addr[i] = hdr-&gt;shwaddr.addr[i];
00449         hdr-&gt;shwaddr.addr[i] = ethaddr-&gt;addr[i];
00450         hdr-&gt;ethhdr.dest.addr[i] = hdr-&gt;dhwaddr.addr[i];
00451         hdr-&gt;ethhdr.src.addr[i] = ethaddr-&gt;addr[i];
00452       }
00453 
00454       hdr-&gt;hwtype = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(<a class="code" href="etharp_8c.html#a2">HWTYPE_ETHERNET</a>);
00455       <a class="code" href="etharp_8c.html#a7">ARPH_HWLEN_SET</a>(hdr, netif-&gt;<a class="code" href="structnetif.html#o8">hwaddr_len</a>);
00456 
00457         hdr-&gt;proto = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(<a class="code" href="etharp_8h.html#a2">ETHTYPE_IP</a>);
00458       <a class="code" href="etharp_8c.html#a8">ARPH_PROTOLEN_SET</a>(hdr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a>));
00459 
00460         hdr-&gt;ethhdr.type = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(<a class="code" href="etharp_8h.html#a1">ETHTYPE_ARP</a>);
00461       <span class="comment">/* return ARP reply */</span>
00462       netif-&gt;<a class="code" href="structnetif.html#o6">linkoutput</a>(netif, p);
00463     } <span class="keywordflow">else</span> {
00464       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"etharp_arp_input: incoming ARP request was not for us.\n"</span>));
00465     }
00466     <span class="keywordflow">break</span>;
00467   <span class="keywordflow">case</span> <a class="code" href="etharp_8c.html#a4">ARP_REPLY</a>:
00468     <span class="comment">/* ARP reply. We insert or update the ARP table. */</span>
00469     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"etharp_arp_input: incoming ARP reply\n"</span>));
00470 <span class="preprocessor">#if (LWIP_DHCP &amp;&amp; DHCP_DOES_ARP_CHECK)</span>
00471 <span class="preprocessor"></span>    <span class="comment">/* DHCP needs to know about ARP replies */</span>
00472     dhcp_arp_reply(netif, &amp;hdr-&gt;sipaddr);
00473 <span class="preprocessor">#endif</span>
00474 <span class="preprocessor"></span>    <span class="comment">/* ARP reply directed to us? */</span>
00475     <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(hdr-&gt;dipaddr), &amp;(netif-&gt;<a class="code" href="structnetif.html#o1">ip_addr</a>))) {
00476       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"etharp_arp_input: incoming ARP reply is for us\n"</span>));
00477       <span class="comment">/* update_the ARP cache, ask to insert */</span>
00478       <a class="code" href="etharp_8c.html#a15">update_arp_entry</a>(netif, &amp;(hdr-&gt;sipaddr), &amp;(hdr-&gt;shwaddr), <a class="code" href="etharp_8c.html#a9">ARP_INSERT_FLAG</a>);
00479     <span class="comment">/* ARP reply not directed to us */</span>
00480     } <span class="keywordflow">else</span> {
00481       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"etharp_arp_input: incoming ARP reply is not for us\n"</span>));
00482       <span class="comment">/* update the destination address pair */</span>
00483       <a class="code" href="etharp_8c.html#a15">update_arp_entry</a>(netif, &amp;(hdr-&gt;sipaddr), &amp;(hdr-&gt;shwaddr), 0);
00484       <span class="comment">/* update the destination address pair */</span>
00485       <a class="code" href="etharp_8c.html#a15">update_arp_entry</a>(netif, &amp;(hdr-&gt;dipaddr), &amp;(hdr-&gt;dhwaddr), 0);
00486     }
00487     <span class="keywordflow">break</span>;
00488   <span class="keywordflow">default</span>:
00489     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"etharp_arp_input: ARP unknown opcode type %d\n"</span>, <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(hdr-&gt;opcode)));
00490     <span class="keywordflow">break</span>;
00491   }
00492   <span class="comment">/* free ARP packet */</span>
00493   <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00494   p = <a class="code" href="def_8h.html#a2">NULL</a>;
00495   <span class="comment">/* nothing to send, we did it! */</span>
00496   <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00497 }
00498 
00520 <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *
<a name="l00521"></a><a class="code" href="etharp_8c.html#a21">00521</a> <a class="code" href="etharp_8c.html#a21">etharp_output</a>(<span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *ipaddr, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *q)
00522 {
00523   <span class="keyword">struct </span><a class="code" href="structeth__addr.html">eth_addr</a> *dest, *srcaddr, mcastaddr;
00524   <span class="keyword">struct </span><a class="code" href="structeth__hdr.html">eth_hdr</a> *ethhdr;
00525   u8_t i;
00526 
00527   <span class="comment">/* Make room for Ethernet header. */</span>
00528   <span class="keywordflow">if</span> (<a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(q, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structeth__hdr.html">eth_hdr</a>)) != 0) {
00529     <span class="comment">/* The pbuf_header() call shouldn't fail, and we'll just bail</span>
00530 <span class="comment">    out if it does.. */</span>
00531     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 2, (<span class="stringliteral">"etharp_output: could not allocate room for header.\n"</span>));
00532 <span class="preprocessor">#ifdef LINK_STATS</span>
00533 <span class="preprocessor"></span>    ++lwip_stats.link.lenerr;
00534 <span class="preprocessor">#endif </span><span class="comment">/* LINK_STATS */</span>
00535     <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00536   }
00537 
00538   <span class="comment">/* obtain source Ethernet address of the given interface */</span>
00539   srcaddr = (<span class="keyword">struct </span><a class="code" href="structeth__addr.html">eth_addr</a> *)netif-&gt;<a class="code" href="structnetif.html#o9">hwaddr</a>;
00540 
00541   <span class="comment">/* assume unresolved Ethernet address */</span>
00542   dest = <a class="code" href="def_8h.html#a2">NULL</a>;
00543   <span class="comment">/* Construct Ethernet header. Start with looking up deciding which</span>
00544 <span class="comment">  MAC address to use as a destination address. Broadcasts and</span>
00545 <span class="comment">  multicasts are special, all other addresses are looked up in the</span>
00546 <span class="comment">  ARP table. */</span>
00547 
00548   <span class="comment">/* destination IP address is an IP broadcast address? */</span>
00549   <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(ipaddr) ||
00550     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a31">ip_addr_isbroadcast</a>(ipaddr, &amp;(netif-&gt;<a class="code" href="structnetif.html#o2">netmask</a>))) {
00551     <span class="comment">/* broadcast on Ethernet also */</span>
00552     dest = (<span class="keyword">struct </span><a class="code" href="structeth__addr.html">eth_addr</a> *)&amp;<a class="code" href="etharp_8c.html#a10">ethbroadcast</a>;
00553   }
00554   <span class="comment">/* destination IP address is an IP multicast address? */</span>
00555   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a32">ip_addr_ismulticast</a>(ipaddr)) {
00556     <span class="comment">/* Hash IP multicast address to MAC address. */</span>
00557     mcastaddr.addr[0] = 0x01;
00558     mcastaddr.addr[1] = 0x0;
00559     mcastaddr.addr[2] = 0x5e;
00560     mcastaddr.addr[3] = <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a35">ip4_addr2</a>(ipaddr) &amp; 0x7f;
00561     mcastaddr.addr[4] = <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a36">ip4_addr3</a>(ipaddr);
00562     mcastaddr.addr[5] = <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a37">ip4_addr4</a>(ipaddr);
00563     <span class="comment">/* destination Ethernet address is multicast */</span>
00564     dest = &amp;mcastaddr;
00565   }
00566   <span class="comment">/* destination IP address is an IP unicast address */</span>
00567   <span class="keywordflow">else</span> {
00568     <span class="comment">/* destination IP network address not on local network? */</span>
00569     <span class="comment">/* this occurs if the packet is routed to the default gateway on this interface */</span>
00570     <span class="keywordflow">if</span> (!<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a28">ip_addr_maskcmp</a>(ipaddr, &amp;(netif-&gt;<a class="code" href="structnetif.html#o1">ip_addr</a>), &amp;(netif-&gt;<a class="code" href="structnetif.html#o2">netmask</a>))) {
00571       <span class="comment">/* gateway available? */</span>
00572       <span class="keywordflow">if</span> (netif-&gt;<a class="code" href="structnetif.html#o3">gw</a>.<a class="code" href="structip__addr.html#o0">addr</a> != 0)
00573       {
00574         <span class="comment">/* use the gateway IP address */</span>
00575         ipaddr = &amp;(netif-&gt;<a class="code" href="structnetif.html#o3">gw</a>);
00576       }
00577       <span class="comment">/* no gateway available? */</span>
00578       <span class="keywordflow">else</span>
00579       {
00580         <span class="comment">/* IP destination address outside local network, but no gateway available */</span>
00581         <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00582       }
00583     }
00584 
00585     <span class="comment">/* Ethernet address for IP destination address is in ARP cache? */</span>
00586     <span class="keywordflow">for</span>(i = 0; i &lt; <a class="code" href="opt_8h.html#a17">ARP_TABLE_SIZE</a>; ++i) {
00587       <span class="comment">/* match found? */</span>
00588       <span class="keywordflow">if</span> (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> == <a class="code" href="etharp_8c.html#a23a14">ETHARP_STATE_STABLE</a> &amp;&amp;
00589         <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(ipaddr, &amp;<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].ipaddr)) {
00590         dest = &amp;<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o1">ethaddr</a>;
00591         <span class="keywordflow">break</span>;
00592       }
00593     }
00594     <span class="comment">/* could not find the destination Ethernet address in ARP cache? */</span>
00595     <span class="keywordflow">if</span> (dest == <a class="code" href="def_8h.html#a2">NULL</a>) {
00596       <span class="comment">/* ARP query for the IP address, submit this IP packet for queueing */</span>
00597       <a class="code" href="etharp_8c.html#a22">etharp_query</a>(netif, ipaddr, q);
00598       <span class="comment">/* return nothing */</span>
00599       <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00600     }
00601     <span class="comment">/* destination Ethernet address resolved from ARP cache */</span>
00602     <span class="keywordflow">else</span>
00603     {
00604       <span class="comment">/* fallthrough */</span>
00605     }
00606   }
00607 
00608   <span class="comment">/* destination Ethernet address known */</span>
00609   <span class="keywordflow">if</span> (dest != <a class="code" href="def_8h.html#a2">NULL</a>) {
00610     <span class="comment">/* A valid IP-&gt;MAC address mapping was found, so we construct the</span>
00611 <span class="comment">    Ethernet header for the outgoing packet. */</span>
00612     ethhdr = q-&gt;<a class="code" href="structpbuf.html#o1">payload</a>;
00613 
00614     <span class="keywordflow">for</span>(i = 0; i &lt; netif-&gt;<a class="code" href="structnetif.html#o8">hwaddr_len</a>; i++) {
00615       ethhdr-&gt;dest.addr[i] = dest-&gt;addr[i];
00616       ethhdr-&gt;src.addr[i] = srcaddr-&gt;addr[i];
00617     }
00618 
00619     ethhdr-&gt;type = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(<a class="code" href="etharp_8h.html#a2">ETHTYPE_IP</a>);
00620     <span class="comment">/* return the outgoing packet */</span>
00621     <span class="keywordflow">return</span> q;
00622   }
00623   <span class="comment">/* never reached; here for safety */</span>
00624   <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a2">NULL</a>;
00625 }
00626 
<a name="l00648"></a><a class="code" href="etharp_8c.html#a22">00648</a> <a class="code" href="err_8h.html#a13">err_t</a> <a class="code" href="etharp_8c.html#a22">etharp_query</a>(<span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *ipaddr, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *q)
00649 {
00650   <span class="keyword">struct </span><a class="code" href="structeth__addr.html">eth_addr</a> *srcaddr;
00651   <span class="keyword">struct </span><a class="code" href="structetharp__hdr.html">etharp_hdr</a> *hdr;
00652   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p;
00653   <a class="code" href="err_8h.html#a13">err_t</a> result = <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00654   u8_t i;
00655   u8_t perform_arp_request = 1;
00656   <span class="comment">/* prevent 'unused argument' warning if ARP_QUEUEING == 0 */</span>
00657   (<span class="keywordtype">void</span>)q;
00658   srcaddr = (<span class="keyword">struct </span><a class="code" href="structeth__addr.html">eth_addr</a> *)netif-&gt;<a class="code" href="structnetif.html#o9">hwaddr</a>;
00659   <span class="comment">/* bail out if this IP address is pending */</span>
00660   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="opt_8h.html#a17">ARP_TABLE_SIZE</a>; ++i) {
00661     <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(ipaddr, &amp;<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].ipaddr)) {
00662       <span class="keywordflow">if</span> (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> == <a class="code" href="etharp_8c.html#a23a13">ETHARP_STATE_PENDING</a>) {
00663         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | <a class="code" href="debug_8h.html#a8">DBG_STATE</a>, (<span class="stringliteral">"etharp_query: requested IP already pending as entry %u\n"</span>, i));
00664         <span class="comment">/* break out of for-loop, user may wish to queue a packet on a stable entry */</span>
00665         <span class="comment">/* TODO: we will issue a new ARP request, which should not occur too often */</span>
00666         <span class="comment">/* we might want to run a faster timer on ARP to limit this */</span>
00667         <span class="keywordflow">break</span>;
00668       }
00669       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> == <a class="code" href="etharp_8c.html#a23a14">ETHARP_STATE_STABLE</a>) {
00670         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | <a class="code" href="debug_8h.html#a8">DBG_STATE</a>, (<span class="stringliteral">"etharp_query: requested IP already stable as entry %u\n"</span>, i));
00671         <span class="comment">/* user may wish to queue a packet on a stable entry, so we proceed without ARP requesting */</span>
00672         <span class="comment">/* TODO: even if the ARP entry is stable, we might do an ARP request anyway */</span>
00673         perform_arp_request = 0;
00674         <span class="keywordflow">break</span>;
00675       }
00676     }
00677   }
00678   <span class="comment">/* queried address not yet in ARP table? */</span>
00679   <span class="keywordflow">if</span> (i == <a class="code" href="opt_8h.html#a17">ARP_TABLE_SIZE</a>) {
00680     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"etharp_query: IP address not found in ARP table\n"</span>));
00681     <span class="comment">/* find an available entry */</span>
00682     i = <a class="code" href="etharp_8c.html#a18">find_arp_entry</a>();
00683     <span class="comment">/* bail out if no ARP entries are available */</span>
00684     <span class="keywordflow">if</span> (i == <a class="code" href="opt_8h.html#a17">ARP_TABLE_SIZE</a>) {
00685       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | 2, (<span class="stringliteral">"etharp_query: no more ARP entries available.\n"</span>));
00686       <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a1">ERR_MEM</a>;
00687     }
00688     <span class="comment">/* we will now recycle entry i */</span>
00689     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"etharp_query: created ARP table entry %u.\n"</span>, i));
00690     <span class="comment">/* i is available, create ARP entry */</span>
00691     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a27">ip_addr_set</a>(&amp;<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].ipaddr, ipaddr);
00692     <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o3">ctime</a> = 0;
00693     <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].<a class="code" href="structetharp__entry.html#o2">state</a> = <a class="code" href="etharp_8c.html#a23a13">ETHARP_STATE_PENDING</a>;
00694 <span class="preprocessor">#if ARP_QUEUEING</span>
00695 <span class="preprocessor"></span>    <span class="comment">/* free queued packet, as entry is now invalidated */</span>
00696     <span class="keywordflow">if</span> (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p != <a class="code" href="def_8h.html#a2">NULL</a>) {
00697       <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p);
00698       <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p = <a class="code" href="def_8h.html#a2">NULL</a>;
00699       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 3, (<span class="stringliteral">"etharp_query: dropped packet on ARP queue. Should not occur.\n"</span>));
00700     }
00701 <span class="preprocessor">#endif</span>
00702 <span class="preprocessor"></span>  }
00703 <span class="preprocessor">#if ARP_QUEUEING</span>
00704 <span class="preprocessor"></span>  <span class="comment">/* any pbuf to queue and queue is empty? */</span>
00705   <span class="keywordflow">if</span> (q != <a class="code" href="def_8h.html#a2">NULL</a>) {
00706 <span class="comment">/* yield later packets over older packets? */</span>
00707 <span class="preprocessor">#if ARP_QUEUE_FIRST == 0</span>
00708 <span class="preprocessor"></span>    <span class="comment">/* earlier queued packet on this entry? */</span>
00709     <span class="keywordflow">if</span> (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p != <a class="code" href="def_8h.html#a2">NULL</a>) {
00710       <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p);
00711       <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p = <a class="code" href="def_8h.html#a2">NULL</a>;
00712       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 3, (<span class="stringliteral">"etharp_query: dropped packet on ARP queue. Should not occur.\n"</span>));
00713       <span class="comment">/* fall-through into next if */</span>
00714     }
00715 <span class="preprocessor">#endif</span>
00716 <span class="preprocessor"></span>    <span class="comment">/* packet can be queued? */</span>
00717     <span class="keywordflow">if</span> (<a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p == <a class="code" href="def_8h.html#a2">NULL</a>) {
00718       <span class="comment">/* copy PBUF_REF referenced payloads into PBUF_RAM */</span>
00719       q = <a class="code" href="pbuf_8c.html#a18">pbuf_take</a>(q);
00720       <span class="comment">/* remember pbuf to queue, if any */</span>
00721       <a class="code" href="etharp_8c.html#a11">arp_table</a>[i].p = q;
00722       <span class="comment">/* pbufs are queued, increase the reference count */</span>
00723       <a class="code" href="pbuf_8c.html#a16">pbuf_ref</a>(q);
00724       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | <a class="code" href="debug_8h.html#a8">DBG_STATE</a>, (<span class="stringliteral">"etharp_query: queued packet %p on ARP entry %u.\n"</span>, (<span class="keywordtype">void</span> *)q, i));
00725     }
00726   }
00727 <span class="preprocessor">#endif</span>
00728 <span class="preprocessor"></span>  <span class="comment">/* ARP request? */</span>
00729   <span class="keywordflow">if</span> (perform_arp_request)
00730   {
00731     <span class="comment">/* allocate a pbuf for the outgoing ARP request packet */</span>
00732     p = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(<a class="code" href="pbuf_8h.html#a26a9">PBUF_LINK</a>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structetharp__hdr.html">etharp_hdr</a>), <a class="code" href="pbuf_8h.html#a27a11">PBUF_RAM</a>);
00733     <span class="comment">/* could allocate pbuf? */</span>
00734     <span class="keywordflow">if</span> (p != <a class="code" href="def_8h.html#a2">NULL</a>) {
00735       u8_t j;
00736       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a>, (<span class="stringliteral">"etharp_query: sending ARP request.\n"</span>));
00737       hdr = p-&gt;payload;
00738       hdr-&gt;opcode = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(<a class="code" href="etharp_8c.html#a3">ARP_REQUEST</a>);
00739       <span class="keywordflow">for</span>(j = 0; j &lt; netif-&gt;<a class="code" href="structnetif.html#o8">hwaddr_len</a>; ++j)
00740       {
00741         hdr-&gt;dhwaddr.addr[j] = 0x00;
00742         hdr-&gt;shwaddr.addr[j] = srcaddr-&gt;addr[j];
00743       }
00744       <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a27">ip_addr_set</a>(&amp;(hdr-&gt;dipaddr), ipaddr);
00745       <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a27">ip_addr_set</a>(&amp;(hdr-&gt;sipaddr), &amp;(netif-&gt;<a class="code" href="structnetif.html#o1">ip_addr</a>));
00746 
00747       hdr-&gt;hwtype = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(<a class="code" href="etharp_8c.html#a2">HWTYPE_ETHERNET</a>);
00748       <a class="code" href="etharp_8c.html#a7">ARPH_HWLEN_SET</a>(hdr, netif-&gt;<a class="code" href="structnetif.html#o8">hwaddr_len</a>);
00749 
00750       hdr-&gt;proto = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(<a class="code" href="etharp_8h.html#a2">ETHTYPE_IP</a>);
00751       <a class="code" href="etharp_8c.html#a8">ARPH_PROTOLEN_SET</a>(hdr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a>));
00752       <span class="keywordflow">for</span>(j = 0; j &lt; netif-&gt;<a class="code" href="structnetif.html#o8">hwaddr_len</a>; ++j)
00753       {
00754         hdr-&gt;ethhdr.dest.addr[j] = 0xff;
00755         hdr-&gt;ethhdr.src.addr[j] = srcaddr-&gt;addr[j];
00756       }
00757       hdr-&gt;ethhdr.type = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(<a class="code" href="etharp_8h.html#a1">ETHTYPE_ARP</a>);
00758       <span class="comment">/* send ARP query */</span>
00759       result = netif-&gt;<a class="code" href="structnetif.html#o6">linkoutput</a>(netif, p);
00760       <span class="comment">/* free ARP query packet */</span>
00761       <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00762       p = <a class="code" href="def_8h.html#a2">NULL</a>;
00763     } <span class="keywordflow">else</span> {
00764       result = <a class="code" href="err_8h.html#a1">ERR_MEM</a>;
00765       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(<a class="code" href="opt_8h.html#a60">ETHARP_DEBUG</a> | <a class="code" href="debug_8h.html#a7">DBG_TRACE</a> | 2, (<span class="stringliteral">"etharp_query: could not allocate pbuf for ARP request.\n"</span>));
00766     }
00767   }
00768   <span class="keywordflow">return</span> result;
00769 }
</pre></div>	</td>
  </tr>
</table>
<hr>
<div align="center">Copyright (c) 2001-2003 Swedish Institute of Computer Science</div>
</html>
