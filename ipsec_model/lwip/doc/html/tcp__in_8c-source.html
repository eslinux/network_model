
<html>
<head>
<title>lwIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="doxygen.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<table width="98%" border="0" align="center">
  <tr>
    <td>
      <h2>lwIP code documentation</h2>
<hr>

<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>tcp_in.c</h1><a href="tcp__in_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00007 <span class="comment">/*</span>
00008 <span class="comment"> * Copyright (c) 2001-2003 Swedish Institute of Computer Science.</span>
00009 <span class="comment"> * All rights reserved.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Redistribution and use in source and binary forms, with or without modification,</span>
00012 <span class="comment"> * are permitted provided that the following conditions are met:</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span>
00015 <span class="comment"> *    this list of conditions and the following disclaimer.</span>
00016 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
00017 <span class="comment"> *    this list of conditions and the following disclaimer in the documentation</span>
00018 <span class="comment"> *    and/or other materials provided with the distribution.</span>
00019 <span class="comment"> * 3. The name of the author may not be used to endorse or promote products</span>
00020 <span class="comment"> *    derived from this software without specific prior written permission.</span>
00021 <span class="comment"> *</span>
00022 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED</span>
00023 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
00024 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT</span>
00025 <span class="comment"> * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
00026 <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT</span>
00027 <span class="comment"> * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
00028 <span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
00029 <span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
00030 <span class="comment"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY</span>
00031 <span class="comment"> * OF SUCH DAMAGE.</span>
00032 <span class="comment"> *</span>
00033 <span class="comment"> * This file is part of the lwIP TCP/IP stack.</span>
00034 <span class="comment"> *</span>
00035 <span class="comment"> * Author: Adam Dunkels &lt;adam@sics.se&gt;</span>
00036 <span class="comment"> *</span>
00037 <span class="comment"> */</span>
00038 
00039 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00040 <span class="comment">/* tcp_input.c</span>
00041 <span class="comment"> *</span>
00042 <span class="comment"> * The input processing functions of TCP.</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> * These functions are generally called in the order (ip_input() -&gt;) tcp_input() -&gt;</span>
00045 <span class="comment"> * tcp_process() -&gt; tcp_receive() (-&gt; application).</span>
00046 <span class="comment"> *</span>
00047 <span class="comment"> */</span>
00048 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00049 
00050 
00051 <span class="preprocessor">#include "<a class="code" href="def_8h.html">lwip/def.h</a>"</span>
00052 <span class="preprocessor">#include "<a class="code" href="opt_8h.html">lwip/opt.h</a>"</span>
00053 
00054 <span class="preprocessor">#include "<a class="code" href="netif_8h.html">lwip/netif.h</a>"</span>
00055 <span class="preprocessor">#include "<a class="code" href="mem_8h.html">lwip/mem.h</a>"</span>
00056 <span class="preprocessor">#include "<a class="code" href="memp_8h.html">lwip/memp.h</a>"</span>
00057 
00058 <span class="preprocessor">#include "lwip/inet.h"</span>
00059 <span class="preprocessor">#include "<a class="code" href="tcp_8h.html">lwip/tcp.h</a>"</span>
00060 
00061 <span class="preprocessor">#include "<a class="code" href="stats_8h.html">lwip/stats.h</a>"</span>
00062 
00063 <span class="preprocessor">#include "arch/perf.h"</span>
00064 <span class="preprocessor">#if LWIP_TCP</span>
00065 <span class="preprocessor"></span><span class="comment">/* These variables are global to all functions involved in the input</span>
00066 <span class="comment">   processing of TCP segments. They are set by the tcp_input()</span>
00067 <span class="comment">   function. */</span>
00068 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> inseg;
00069 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtcp__hdr.html">tcp_hdr</a> *<a class="code" href="structtcphdr.html">tcphdr</a>;
00070 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structip__hdr.html">ip_hdr</a> *iphdr;
00071 <span class="keyword">static</span> u32_t seqno, ackno;
00072 <span class="keyword">static</span> u8_t flags;
00073 <span class="keyword">static</span> u16_t tcplen;
00074 
00075 <span class="keyword">static</span> u8_t recv_flags;
00076 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *recv_data;
00077 
00078 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *<a class="code" href="tcp_8h.html#a47">tcp_input_pcb</a>;
00079 
00080 <span class="comment">/* Forward declarations. */</span>
00081 <span class="keyword">static</span> <a class="code" href="err_8h.html#a13">err_t</a> tcp_process(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
00082 <span class="keyword">static</span> <span class="keywordtype">void</span> tcp_receive(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
00083 <span class="keyword">static</span> <span class="keywordtype">void</span> tcp_parseopt(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
00084 
00085 <span class="keyword">static</span> <a class="code" href="err_8h.html#a13">err_t</a> tcp_listen_input(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *pcb);
00086 <span class="keyword">static</span> <a class="code" href="err_8h.html#a13">err_t</a> tcp_timewait_input(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
00087 
00088 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00089 <span class="comment">/* tcp_input:</span>
00090 <span class="comment"> *</span>
00091 <span class="comment"> * The initial input processing of TCP. It verifies the TCP header, demultiplexes</span>
00092 <span class="comment"> * the segment between the PCBs and passes it on to tcp_process(), which implements</span>
00093 <span class="comment"> * the TCP finite state machine. This function is called by the IP layer (in</span>
00094 <span class="comment"> * ip_input()).</span>
00095 <span class="comment"> */</span>
00096 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00097 <span class="keywordtype">void</span>
00098 <a class="code" href="tcp_8h.html#a84">tcp_input</a>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p, <span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *inp)
00099 {
00100   <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, *prev;
00101   <span class="keyword">struct </span><a class="code" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *lpcb;
00102   u8_t offset;
00103   <a class="code" href="err_8h.html#a13">err_t</a> err;
00104 
00105 
00106   PERF_START;
00107 
00108 
00109 <span class="preprocessor">#ifdef TCP_STATS</span>
00110 <span class="preprocessor"></span>  ++lwip_stats.tcp.recv;
00111 <span class="preprocessor">#endif </span><span class="comment">/* TCP_STATS */</span>
00112 
00113   iphdr = p-&gt;<a class="code" href="structpbuf.html#o1">payload</a>;
00114   tcphdr = (<span class="keyword">struct </span><a class="code" href="structtcp__hdr.html">tcp_hdr</a> *)((u8_t *)p-&gt;<a class="code" href="structpbuf.html#o1">payload</a> + <a class="code" href="ipv4_2lwip_2ip_8h.html#a11">IPH_HL</a>(iphdr) * 4);
00115 
00116   <span class="comment">/* remove header from payload */</span>
00117   <span class="keywordflow">if</span> (<a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(p, -((s16_t)(<a class="code" href="ipv4_2lwip_2ip_8h.html#a11">IPH_HL</a>(iphdr) * 4))) || (p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a> &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structtcp__hdr.html">tcp_hdr</a>))) {
00118     <span class="comment">/* drop short packets */</span>
00119     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_INPUT_DEBUG, (<span class="stringliteral">"tcp_input: short packet (%u bytes) discarded\n"</span>, p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a>));
00120 <span class="preprocessor">#ifdef TCP_STATS</span>
00121 <span class="preprocessor"></span>    ++lwip_stats.tcp.lenerr;
00122     ++lwip_stats.tcp.drop;
00123 <span class="preprocessor">#endif </span><span class="comment">/* TCP_STATS */</span>
00124     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00125     <span class="keywordflow">return</span>;
00126   }
00127 
00128   <span class="comment">/* Don't even process incoming broadcasts/multicasts. */</span>
00129   <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a31">ip_addr_isbroadcast</a>(&amp;(iphdr-&gt;dest), &amp;(inp-&gt;<a class="code" href="structnetif.html#o2">netmask</a>)) ||
00130      <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a32">ip_addr_ismulticast</a>(&amp;(iphdr-&gt;dest))) {
00131     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00132     <span class="keywordflow">return</span>;
00133   }
00134 
00135   <span class="comment">/* Verify TCP checksum. */</span>
00136   <span class="keywordflow">if</span> (<a class="code" href="inet6_8c.html#a1">inet_chksum_pseudo</a>(p, (<span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *)&amp;(iphdr-&gt;src),
00137       (<span class="keyword">struct</span> ip_addr *)&amp;(iphdr-&gt;dest),
00138       IP_PROTO_TCP, p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a>) != 0) {
00139       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_INPUT_DEBUG, (<span class="stringliteral">"tcp_input: packet discarded due to failing checksum 0x%04x\n"</span>,
00140         <a class="code" href="inet6_8c.html#a1">inet_chksum_pseudo</a>(p, (<span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *)&amp;(iphdr-&gt;src), (<span class="keyword">struct</span> ip_addr *)&amp;(iphdr-&gt;dest),
00141       IP_PROTO_TCP, p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a>)));
00142 <span class="preprocessor">#if TCP_DEBUG</span>
00143 <span class="preprocessor"></span>    tcp_debug_print(tcphdr);
00144 <span class="preprocessor">#endif </span><span class="comment">/* TCP_DEBUG */</span>
00145 <span class="preprocessor">#ifdef TCP_STATS</span>
00146 <span class="preprocessor"></span>    ++lwip_stats.tcp.chkerr;
00147     ++lwip_stats.tcp.drop;
00148 <span class="preprocessor">#endif </span><span class="comment">/* TCP_STATS */</span>
00149 
00150     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00151     <span class="keywordflow">return</span>;
00152   }
00153 
00154 
00155   <span class="comment">/* Move the payload pointer in the pbuf so that it points to the</span>
00156 <span class="comment">     TCP data instead of the TCP header. */</span>
00157   offset = <a class="code" href="tcp_8h.html#a24">TCPH_OFFSET</a>(tcphdr) &gt;&gt; 4;
00158   <a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(p, -(offset * 4));
00159 
00160   <span class="comment">/* Convert fields in TCP header to host byte order. */</span>
00161   tcphdr-&gt;src = <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(tcphdr-&gt;src);
00162   tcphdr-&gt;dest = <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(tcphdr-&gt;dest);
00163   seqno = tcphdr-&gt;seqno = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(tcphdr-&gt;seqno);
00164   ackno = tcphdr-&gt;ackno = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(tcphdr-&gt;ackno);
00165   tcphdr-&gt;wnd = <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(tcphdr-&gt;wnd);
00166 
00167   flags = <a class="code" href="tcp_8h.html#a25">TCPH_FLAGS</a>(tcphdr) &amp; <a class="code" href="tcp_8h.html#a15">TCP_FLAGS</a>;
00168   tcplen = p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a> + ((flags &amp; <a class="code" href="tcp_8h.html#a9">TCP_FIN</a> || flags &amp; <a class="code" href="tcp_8h.html#a10">TCP_SYN</a>)? 1: 0);
00169 
00170   <span class="comment">/* Demultiplex an incoming segment. First, we check if it is destined</span>
00171 <span class="comment">     for an active connection. */</span>
00172   prev = <a class="code" href="def_8h.html#a2">NULL</a>;
00173   <span class="keywordflow">for</span>(pcb = <a class="code" href="tcp_8h.html#a50">tcp_active_pcbs</a>; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;next) {
00174     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_input: active pcb-&gt;state != CLOSED"</span>, pcb-&gt;state != CLOSED);
00175     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_input: active pcb-&gt;state != TIME-WAIT"</span>, pcb-&gt;state != TIME_WAIT);
00176     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_input: active pcb-&gt;state != LISTEN"</span>, pcb-&gt;state != LISTEN);
00177     <span class="keywordflow">if</span> (pcb-&gt;remote_port == tcphdr-&gt;src &amp;&amp;
00178        pcb-&gt;local_port == tcphdr-&gt;dest &amp;&amp;
00179        <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(pcb-&gt;remote_ip), &amp;(iphdr-&gt;src)) &amp;&amp;
00180        <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(pcb-&gt;local_ip), &amp;(iphdr-&gt;dest))) {
00181 
00182       <span class="comment">/* Move this PCB to the front of the list so that subsequent</span>
00183 <span class="comment">   lookups will be faster (we exploit locality in TCP segment</span>
00184 <span class="comment">   arrivals). */</span>
00185       <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_input: pcb-&gt;next != pcb (before cache)"</span>, pcb-&gt;next != pcb);
00186       <span class="keywordflow">if</span> (prev != <a class="code" href="def_8h.html#a2">NULL</a>) {
00187   prev-&gt;next = pcb-&gt;next;
00188   pcb-&gt;next = <a class="code" href="tcp_8h.html#a50">tcp_active_pcbs</a>;
00189   <a class="code" href="tcp_8h.html#a50">tcp_active_pcbs</a> = pcb;
00190       }
00191       <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_input: pcb-&gt;next != pcb (after cache)"</span>, pcb-&gt;next != pcb);
00192       <span class="keywordflow">break</span>;
00193     }
00194     prev = pcb;
00195   }
00196 
00197   <span class="keywordflow">if</span> (pcb == <a class="code" href="def_8h.html#a2">NULL</a>) {
00198     <span class="comment">/* If it did not go to an active connection, we check the connections</span>
00199 <span class="comment">       in the TIME-WAIT state. */</span>
00200 
00201     <span class="keywordflow">for</span>(pcb = <a class="code" href="tcp_8h.html#a51">tcp_tw_pcbs</a>; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;next) {
00202       <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_input: TIME-WAIT pcb-&gt;state == TIME-WAIT"</span>, pcb-&gt;state == TIME_WAIT);
00203       <span class="keywordflow">if</span> (pcb-&gt;remote_port == tcphdr-&gt;src &amp;&amp;
00204    pcb-&gt;local_port == tcphdr-&gt;dest &amp;&amp;
00205    <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(pcb-&gt;remote_ip), &amp;(iphdr-&gt;src)) &amp;&amp;
00206          <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(pcb-&gt;local_ip), &amp;(iphdr-&gt;dest))) {
00207   <span class="comment">/* We don't really care enough to move this PCB to the front</span>
00208 <span class="comment">     of the list since we are not very likely to receive that</span>
00209 <span class="comment">     many segments for connections in TIME-WAIT. */</span>
00210   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_INPUT_DEBUG, (<span class="stringliteral">"tcp_input: packed for TIME_WAITing connection.\n"</span>));
00211   tcp_timewait_input(pcb);
00212   <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00213   <span class="keywordflow">return</span>;
00214       }
00215     }
00216 
00217   <span class="comment">/* Finally, if we still did not get a match, we check all PCBs that</span>
00218 <span class="comment">     are LISTENing for incoming connections. */</span>
00219     prev = <a class="code" href="def_8h.html#a2">NULL</a>;
00220     <span class="keywordflow">for</span>(lpcb = <a class="code" href="tcp_8h.html#a49">tcp_listen_pcbs</a>; lpcb != <a class="code" href="def_8h.html#a2">NULL</a>; lpcb = lpcb-&gt;next) {
00221       <span class="keywordflow">if</span> ((<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;(lpcb-&gt;local_ip)) ||
00222     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(lpcb-&gt;local_ip), &amp;(iphdr-&gt;dest))) &amp;&amp;
00223    lpcb-&gt;local_port == tcphdr-&gt;dest) {
00224   <span class="comment">/* Move this PCB to the front of the list so that subsequent</span>
00225 <span class="comment">     lookups will be faster (we exploit locality in TCP segment</span>
00226 <span class="comment">     arrivals). */</span>
00227   <span class="keywordflow">if</span> (prev != <a class="code" href="def_8h.html#a2">NULL</a>) {
00228     ((<span class="keyword">struct </span><a class="code" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *)prev)-&gt;next = lpcb-&gt;next;
00229           <span class="comment">/* our successor is the remainder of the listening list */</span>
00230     lpcb-&gt;next = <a class="code" href="tcp_8h.html#a49">tcp_listen_pcbs</a>;
00231           <span class="comment">/* put this listening pcb at the head of the listening list */</span>
00232     <a class="code" href="tcp_8h.html#a49">tcp_listen_pcbs</a> = lpcb;
00233   }
00234 
00235   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_INPUT_DEBUG, (<span class="stringliteral">"tcp_input: packed for LISTENing connection.\n"</span>));
00236   tcp_listen_input(lpcb);
00237   <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00238   <span class="keywordflow">return</span>;
00239       }
00240       prev = (<span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *)lpcb;
00241     }
00242   }
00243 
00244 <span class="preprocessor">#if TCP_INPUT_DEBUG</span>
00245 <span class="preprocessor"></span>  <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_INPUT_DEBUG, (<span class="stringliteral">"+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "</span>));
00246   tcp_debug_print_flags(<a class="code" href="tcp_8h.html#a25">TCPH_FLAGS</a>(tcphdr));
00247   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_INPUT_DEBUG, (<span class="stringliteral">"-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"</span>));
00248 <span class="preprocessor">#endif </span><span class="comment">/* TCP_INPUT_DEBUG */</span>
00249 
00250 
00251   <span class="keywordflow">if</span> (pcb != <a class="code" href="def_8h.html#a2">NULL</a>) {
00252     <span class="comment">/* The incoming segment belongs to a connection. */</span>
00253 <span class="preprocessor">#if TCP_INPUT_DEBUG</span>
00254 <span class="preprocessor"></span><span class="preprocessor">#if TCP_DEBUG</span>
00255 <span class="preprocessor"></span>    tcp_debug_print_state(pcb-&gt;state);
00256 <span class="preprocessor">#endif </span><span class="comment">/* TCP_DEBUG */</span>
00257 <span class="preprocessor">#endif </span><span class="comment">/* TCP_INPUT_DEBUG */</span>
00258 
00259     <span class="comment">/* Set up a tcp_seg structure. */</span>
00260     inseg.<a class="code" href="structtcp__seg.html#o0">next</a> = <a class="code" href="def_8h.html#a2">NULL</a>;
00261     inseg.<a class="code" href="structtcp__seg.html#o3">len</a> = p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a>;
00262     inseg.<a class="code" href="structtcp__seg.html#o2">dataptr</a> = p-&gt;<a class="code" href="structpbuf.html#o1">payload</a>;
00263     inseg.<a class="code" href="structtcp__seg.html#o1">p</a> = p;
00264     inseg.<a class="code" href="structtcp__seg.html#o4">tcphdr</a> = tcphdr;
00265 
00266     recv_data = <a class="code" href="def_8h.html#a2">NULL</a>;
00267     recv_flags = 0;
00268 
00269     <a class="code" href="tcp_8h.html#a47">tcp_input_pcb</a> = pcb;
00270     err = tcp_process(pcb);
00271     <a class="code" href="tcp_8h.html#a47">tcp_input_pcb</a> = <a class="code" href="def_8h.html#a2">NULL</a>;
00272     <span class="comment">/* A return value of ERR_ABRT means that tcp_abort() was called</span>
00273 <span class="comment">       and that the pcb has been freed. If so, we don't do anything. */</span>
00274     <span class="keywordflow">if</span> (err != <a class="code" href="err_8h.html#a3">ERR_ABRT</a>) {
00275       <span class="keywordflow">if</span> (recv_flags &amp; <a class="code" href="tcp_8h.html#a32">TF_RESET</a>) {
00276   <span class="comment">/* TF_RESET means that the connection was reset by the other</span>
00277 <span class="comment">     end. We then call the error callback to inform the</span>
00278 <span class="comment">     application that the connection is dead before we</span>
00279 <span class="comment">     deallocate the PCB. */</span>
00280   <a class="code" href="tcp_8h.html#a40">TCP_EVENT_ERR</a>(pcb-&gt;errf, pcb-&gt;callback_arg, ERR_RST);
00281   <a class="code" href="tcp_8h.html#a89">tcp_pcb_remove</a>(&amp;tcp_active_pcbs, pcb);
00282   <a class="code" href="memp_8c.html#a8">memp_free</a>(MEMP_TCP_PCB, pcb);
00283       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (recv_flags &amp; <a class="code" href="tcp_8h.html#a33">TF_CLOSED</a>) {
00284   <span class="comment">/* The connection has been closed and we will deallocate the</span>
00285 <span class="comment">     PCB. */</span>
00286   <a class="code" href="tcp_8h.html#a89">tcp_pcb_remove</a>(&amp;tcp_active_pcbs, pcb);
00287   <a class="code" href="memp_8c.html#a8">memp_free</a>(MEMP_TCP_PCB, pcb);
00288       } <span class="keywordflow">else</span> {
00289   err = <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00290   <span class="comment">/* If the application has registered a "sent" function to be</span>
00291 <span class="comment">     called when new send buffer space is available, we call it</span>
00292 <span class="comment">     now. */</span>
00293   <span class="keywordflow">if</span> (pcb-&gt;acked &gt; 0) {
00294     <a class="code" href="tcp_8h.html#a36">TCP_EVENT_SENT</a>(pcb, pcb-&gt;acked, err);
00295   }
00296 
00297   <span class="keywordflow">if</span> (recv_data != <a class="code" href="def_8h.html#a2">NULL</a>) {
00298     <span class="comment">/* Notify application that data has been received. */</span>
00299     <a class="code" href="tcp_8h.html#a37">TCP_EVENT_RECV</a>(pcb, recv_data, ERR_OK, err);
00300   }
00301 
00302   <span class="comment">/* If a FIN segment was received, we call the callback</span>
00303 <span class="comment">     function with a NULL buffer to indicate EOF. */</span>
00304   <span class="keywordflow">if</span> (recv_flags &amp; <a class="code" href="tcp_8h.html#a34">TF_GOT_FIN</a>) {
00305     <a class="code" href="tcp_8h.html#a37">TCP_EVENT_RECV</a>(pcb, NULL, ERR_OK, err);
00306   }
00307   <span class="comment">/* If there were no errors, we try to send something out. */</span>
00308   <span class="keywordflow">if</span> (err == <a class="code" href="err_8h.html#a0">ERR_OK</a>) {
00309     <a class="code" href="tcp_8h.html#a85">tcp_output</a>(pcb);
00310   }
00311       }
00312     }
00313 
00314 
00315     <span class="comment">/* We deallocate the incoming pbuf. If it was buffered by the</span>
00316 <span class="comment">       application, the application should have called pbuf_ref() to</span>
00317 <span class="comment">       increase the reference counter in the pbuf. If so, the buffer</span>
00318 <span class="comment">       isn't actually deallocated by the call to pbuf_free(), only the</span>
00319 <span class="comment">       reference count is decreased. */</span>
00320     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(inseg.<a class="code" href="structtcp__seg.html#o1">p</a>);
00321 <span class="preprocessor">#if TCP_INPUT_DEBUG</span>
00322 <span class="preprocessor"></span><span class="preprocessor">#if TCP_DEBUG</span>
00323 <span class="preprocessor"></span>    tcp_debug_print_state(pcb-&gt;state);
00324 <span class="preprocessor">#endif </span><span class="comment">/* TCP_DEBUG */</span>
00325 <span class="preprocessor">#endif </span><span class="comment">/* TCP_INPUT_DEBUG */</span>
00326 
00327   } <span class="keywordflow">else</span> {
00328     <span class="comment">/* If no matching PCB was found, send a TCP RST (reset) to the</span>
00329 <span class="comment">       sender. */</span>
00330     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_RST_DEBUG, (<span class="stringliteral">"tcp_input: no PCB match found, resetting.\n"</span>));
00331     <span class="keywordflow">if</span> (!(<a class="code" href="tcp_8h.html#a25">TCPH_FLAGS</a>(tcphdr) &amp; <a class="code" href="tcp_8h.html#a11">TCP_RST</a>)) {
00332 <span class="preprocessor">#ifdef TCP_STATS</span>
00333 <span class="preprocessor"></span>      ++lwip_stats.tcp.proterr;
00334       ++lwip_stats.tcp.drop;
00335 <span class="preprocessor">#endif </span><span class="comment">/* TCP_STATS */</span>
00336       <a class="code" href="tcp_8h.html#a96">tcp_rst</a>(ackno, seqno + tcplen,
00337         &amp;(iphdr-&gt;dest), &amp;(iphdr-&gt;src),
00338         tcphdr-&gt;dest, tcphdr-&gt;src);
00339     }
00340     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00341   }
00342 
00343   <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_input: tcp_pcbs_sane()"</span>, <a class="code" href="tcp_8h.html#a43">tcp_pcbs_sane</a>());
00344   PERF_STOP(<span class="stringliteral">"tcp_input"</span>);
00345 }
00346 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00347 <span class="comment">/* tcp_listen_input():</span>
00348 <span class="comment"> *</span>
00349 <span class="comment"> * Called by tcp_input() when a segment arrives for a listening</span>
00350 <span class="comment"> * connection.</span>
00351 <span class="comment"> */</span>
00352 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00353 <span class="keyword">static</span> <a class="code" href="err_8h.html#a13">err_t</a>
00354 tcp_listen_input(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *pcb)
00355 {
00356   <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *npcb;
00357   u32_t optdata;
00358 
00359   <span class="comment">/* In the LISTEN state, we check for incoming SYN segments,</span>
00360 <span class="comment">     creates a new PCB, and responds with a SYN|ACK. */</span>
00361   <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a13">TCP_ACK</a>) {
00362     <span class="comment">/* For incoming segments with the ACK flag set, respond with a</span>
00363 <span class="comment">       RST. */</span>
00364     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_RST_DEBUG, (<span class="stringliteral">"tcp_listen_input: ACK in LISTEN, sending reset\n"</span>));
00365     <a class="code" href="tcp_8h.html#a96">tcp_rst</a>(ackno + 1, seqno + tcplen,
00366       &amp;(iphdr-&gt;dest), &amp;(iphdr-&gt;src),
00367       tcphdr-&gt;dest, tcphdr-&gt;src);
00368   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a10">TCP_SYN</a>) {
00369     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(DEMO_DEBUG, (<span class="stringliteral">"TCP connection request %u -&gt; %u.\n"</span>, tcphdr-&gt;src, tcphdr-&gt;dest));
00370     npcb = <a class="code" href="tcp_8h.html#a67">tcp_alloc</a>(pcb-&gt;<a class="code" href="structtcp__pcb__listen.html#o1">prio</a>);
00371     <span class="comment">/* If a new PCB could not be created (probably due to lack of memory),</span>
00372 <span class="comment">       we don't do anything, but rely on the sender will retransmit the</span>
00373 <span class="comment">       SYN at a time when we have more memory available. */</span>
00374     <span class="keywordflow">if</span> (npcb == <a class="code" href="def_8h.html#a2">NULL</a>) {
00375       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_listen_input: could not allocate PCB\n"</span>));
00376 <span class="preprocessor">#ifdef TCP_STATS</span>
00377 <span class="preprocessor"></span>      ++lwip_stats.tcp.memerr;
00378 <span class="preprocessor">#endif </span><span class="comment">/* TCP_STATS */</span>
00379       <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a1">ERR_MEM</a>;
00380     }
00381     <span class="comment">/* Set up the new PCB. */</span>
00382     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a27">ip_addr_set</a>(&amp;(npcb-&gt;local_ip), &amp;(iphdr-&gt;dest));
00383     npcb-&gt;local_port = pcb-&gt;<a class="code" href="structtcp__pcb__listen.html#o4">local_port</a>;
00384     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a27">ip_addr_set</a>(&amp;(npcb-&gt;remote_ip), &amp;(iphdr-&gt;src));
00385     npcb-&gt;remote_port = tcphdr-&gt;src;
00386     npcb-&gt;state = <a class="code" href="tcp_8h.html#a99a56">SYN_RCVD</a>;
00387     npcb-&gt;rcv_nxt = seqno + 1;
00388     npcb-&gt;snd_wnd = tcphdr-&gt;wnd;
00389     npcb-&gt;ssthresh = npcb-&gt;snd_wnd;
00390     npcb-&gt;snd_wl1 = seqno;
00391     npcb-&gt;callback_arg = pcb-&gt;<a class="code" href="structtcp__pcb__listen.html#o2">callback_arg</a>;
00392 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
00393 <span class="preprocessor"></span>    npcb-&gt;accept = pcb-&gt;accept;
00394 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>
00395 
00396     <span class="comment">/* Register the new PCB so that we can begin receiving segments</span>
00397 <span class="comment">       for it. */</span>
00398     <a class="code" href="tcp_8h.html#a44">TCP_REG</a>(&amp;tcp_active_pcbs, npcb);
00399 
00400     <span class="comment">/* Parse any options in the SYN. */</span>
00401     tcp_parseopt(npcb);
00402 
00403     <span class="comment">/* Build an MSS option. */</span>
00404     optdata = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(((u32_t)2 &lt;&lt; 24) |
00405         ((u32_t)4 &lt;&lt; 16) |
00406         (((u32_t)npcb-&gt;mss / 256) &lt;&lt; 8) |
00407         (npcb-&gt;mss &amp; 255));
00408     <span class="comment">/* Send a SYN|ACK together with the MSS option. */</span>
00409     <a class="code" href="tcp_8h.html#a94">tcp_enqueue</a>(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&amp;optdata, 4);
00410     <span class="keywordflow">return</span> <a class="code" href="tcp_8h.html#a85">tcp_output</a>(npcb);
00411   }
00412   <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00413 }
00414 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00415 <span class="comment">/* tcp_timewait_input():</span>
00416 <span class="comment"> *</span>
00417 <span class="comment"> * Called by tcp_input() when a segment arrives for a connection in</span>
00418 <span class="comment"> * TIME_WAIT.</span>
00419 <span class="comment"> */</span>
00420 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00421 <span class="keyword">static</span> <a class="code" href="err_8h.html#a13">err_t</a>
00422 tcp_timewait_input(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
00423 {
00424   <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a7">TCP_SEQ_GT</a>(seqno + tcplen, pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>)) {
00425     pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a> = seqno + tcplen;
00426   }
00427   <span class="keywordflow">if</span> (tcplen &gt; 0) {
00428     <a class="code" href="tcp_8h.html#a42">tcp_ack_now</a>(pcb);
00429   }
00430   <span class="keywordflow">return</span> <a class="code" href="tcp_8h.html#a85">tcp_output</a>(pcb);
00431 }
00432 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00433 <span class="comment">/* tcp_process</span>
00434 <span class="comment"> *</span>
00435 <span class="comment"> * Implements the TCP state machine. Called by tcp_input. In some</span>
00436 <span class="comment"> * states tcp_receive() is called to receive data. The tcp_seg</span>
00437 <span class="comment"> * argument will be freed by the caller (tcp_input()) unless the</span>
00438 <span class="comment"> * recv_data pointer in the pcb is set.</span>
00439 <span class="comment"> */</span>
00440 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00441 <span class="keyword">static</span> <a class="code" href="err_8h.html#a13">err_t</a>
00442 tcp_process(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
00443 {
00444   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *rseg;
00445   u8_t acceptable = 0;
00446   <a class="code" href="err_8h.html#a13">err_t</a> err;
00447 
00448 
00449   err = <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00450 
00451   <span class="comment">/* Process incoming RST segments. */</span>
00452   <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a11">TCP_RST</a>) {
00453     <span class="comment">/* First, determine if the reset is acceptable. */</span>
00454     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> == <a class="code" href="tcp_8h.html#a99a55">SYN_SENT</a>) {
00455       <span class="keywordflow">if</span> (ackno == pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a>) {
00456   acceptable = 1;
00457       }
00458     } <span class="keywordflow">else</span> {
00459       <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a8">TCP_SEQ_GEQ</a>(seqno, pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>) &amp;&amp;
00460    <a class="code" href="tcp_8h.html#a6">TCP_SEQ_LEQ</a>(seqno, pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a> + pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a>)) {
00461   acceptable = 1;
00462       }
00463     }
00464 
00465     <span class="keywordflow">if</span> (acceptable) {
00466       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_INPUT_DEBUG, (<span class="stringliteral">"tcp_process: Connection RESET\n"</span>));
00467       <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_input: pcb-&gt;state != CLOSED"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> != CLOSED);
00468       recv_flags = <a class="code" href="tcp_8h.html#a32">TF_RESET</a>;
00469       pcb-&gt;<a class="code" href="structtcp__pcb.html#o15">flags</a> &amp;= ~<a class="code" href="tcp_8h.html#a29">TF_ACK_DELAY</a>;
00470       <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a4">ERR_RST</a>;
00471     } <span class="keywordflow">else</span> {
00472       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_INPUT_DEBUG, (<span class="stringliteral">"tcp_process: unacceptable reset seqno %lu rcv_nxt %lu\n"</span>,
00473        seqno, pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>));
00474       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_process: unacceptable reset seqno %lu rcv_nxt %lu\n"</span>,
00475        seqno, pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>));
00476       <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00477     }
00478   }
00479 
00480   <span class="comment">/* Update the PCB (in)activity timer. */</span>
00481   pcb-&gt;<a class="code" href="structtcp__pcb.html#o10">tmr</a> = <a class="code" href="tcp_8h.html#a48">tcp_ticks</a>;
00482 
00483   <span class="comment">/* Do different things depending on the TCP state. */</span>
00484   <span class="keywordflow">switch</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a>) {
00485   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a55">SYN_SENT</a>:
00486     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_INPUT_DEBUG, (<span class="stringliteral">"SYN-SENT: ackno %lu pcb-&gt;snd_nxt %lu unacked %lu\n"</span>, ackno,
00487      pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a>, <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno)));
00488     <span class="keywordflow">if</span> (flags &amp; (<a class="code" href="tcp_8h.html#a13">TCP_ACK</a> | <a class="code" href="tcp_8h.html#a10">TCP_SYN</a>) &amp;&amp;
00489        ackno == <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno) + 1) {
00490       pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a> = seqno + 1;
00491       pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a> = ackno;
00492       pcb-&gt;<a class="code" href="structtcp__pcb.html#o28">snd_wnd</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o29">snd_wl1</a> = tcphdr-&gt;wnd;
00493       pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> = <a class="code" href="tcp_8h.html#a99a57">ESTABLISHED</a>;
00494       pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a>;
00495       --pcb-&gt;<a class="code" href="structtcp__pcb.html#o34">snd_queuelen</a>;
00496       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_QLEN_DEBUG, (<span class="stringliteral">"tcp_process: SYN-SENT --queuelen %u\n"</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)pcb-&gt;<a class="code" href="structtcp__pcb.html#o34">snd_queuelen</a>));
00497       rseg = pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>;
00498       pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> = rseg-&gt;<a class="code" href="structtcp__seg.html#o0">next</a>;
00499       <a class="code" href="tcp_8h.html#a91">tcp_seg_free</a>(rseg);
00500 
00501       <span class="comment">/* Parse any options in the SYNACK. */</span>
00502       tcp_parseopt(pcb);
00503 
00504       <span class="comment">/* Call the user specified function to call when sucessfully</span>
00505 <span class="comment">   connected. */</span>
00506       <a class="code" href="tcp_8h.html#a38">TCP_EVENT_CONNECTED</a>(pcb, ERR_OK, err);
00507       <a class="code" href="tcp_8h.html#a41">tcp_ack</a>(pcb);
00508     }
00509     <span class="keywordflow">break</span>;
00510   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a56">SYN_RCVD</a>:
00511     <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a13">TCP_ACK</a> &amp;&amp;
00512        !(flags &amp; <a class="code" href="tcp_8h.html#a11">TCP_RST</a>)) {
00513       <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a5">TCP_SEQ_LT</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a>, ackno) &amp;&amp;
00514    <a class="code" href="tcp_8h.html#a6">TCP_SEQ_LEQ</a>(ackno, pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a>)) {
00515         pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> = <a class="code" href="tcp_8h.html#a99a57">ESTABLISHED</a>;
00516         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(DEMO_DEBUG, (<span class="stringliteral">"TCP connection established %u -&gt; %u.\n"</span>, inseg.<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;src, inseg.<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;dest));
00517 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
00518 <span class="preprocessor"></span>  <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"pcb-&gt;accept != NULL"</span>, (pcb-&gt;accept != NULL));
00519 <span class="preprocessor">#endif</span>
00520 <span class="preprocessor"></span>  <span class="comment">/* Call the accept function. */</span>
00521   <a class="code" href="tcp_8h.html#a35">TCP_EVENT_ACCEPT</a>(pcb, ERR_OK, err);
00522   <span class="keywordflow">if</span> (err != <a class="code" href="err_8h.html#a0">ERR_OK</a>) {
00523     <span class="comment">/* If the accept function returns with an error, we abort</span>
00524 <span class="comment">       the connection. */</span>
00525     <a class="code" href="tcp_8h.html#a78">tcp_abort</a>(pcb);
00526     <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a3">ERR_ABRT</a>;
00527   }
00528   <span class="comment">/* If there was any data contained within this ACK,</span>
00529 <span class="comment">     we'd better pass it on to the application as well. */</span>
00530   tcp_receive(pcb);
00531   pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a>;
00532       }
00533     }
00534     <span class="keywordflow">break</span>;
00535   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a60">CLOSE_WAIT</a>:
00536     <span class="comment">/* FALLTHROUGH */</span>
00537   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a57">ESTABLISHED</a>:
00538     tcp_receive(pcb);
00539     <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a9">TCP_FIN</a>) {
00540       <a class="code" href="tcp_8h.html#a42">tcp_ack_now</a>(pcb);
00541       pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> = <a class="code" href="tcp_8h.html#a99a60">CLOSE_WAIT</a>;
00542     }
00543     <span class="keywordflow">break</span>;
00544   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a58">FIN_WAIT_1</a>:
00545     tcp_receive(pcb);
00546     <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a9">TCP_FIN</a>) {
00547       <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a13">TCP_ACK</a> &amp;&amp; ackno == pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a>) {
00548         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(DEMO_DEBUG,
00549          (<span class="stringliteral">"TCP connection closed %d -&gt; %d.\n"</span>, inseg.<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;src, inseg.<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;dest));
00550   <a class="code" href="tcp_8h.html#a42">tcp_ack_now</a>(pcb);
00551   <a class="code" href="tcp_8h.html#a88">tcp_pcb_purge</a>(pcb);
00552   <a class="code" href="tcp_8h.html#a45">TCP_RMV</a>(&amp;tcp_active_pcbs, pcb);
00553   pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> = <a class="code" href="tcp_8h.html#a99a63">TIME_WAIT</a>;
00554   <a class="code" href="tcp_8h.html#a44">TCP_REG</a>(&amp;tcp_tw_pcbs, pcb);
00555       } <span class="keywordflow">else</span> {
00556   <a class="code" href="tcp_8h.html#a42">tcp_ack_now</a>(pcb);
00557   pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> = <a class="code" href="fsm_8h.html#a12">CLOSING</a>;
00558       }
00559     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a13">TCP_ACK</a> &amp;&amp; ackno == pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a>) {
00560       pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> = <a class="code" href="tcp_8h.html#a99a59">FIN_WAIT_2</a>;
00561     }
00562     <span class="keywordflow">break</span>;
00563   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a59">FIN_WAIT_2</a>:
00564     tcp_receive(pcb);
00565     <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a9">TCP_FIN</a>) {
00566       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(DEMO_DEBUG, (<span class="stringliteral">"TCP connection closed %u -&gt; %u.\n"</span>, inseg.<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;src, inseg.<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;dest));
00567       <a class="code" href="tcp_8h.html#a42">tcp_ack_now</a>(pcb);
00568       <a class="code" href="tcp_8h.html#a88">tcp_pcb_purge</a>(pcb);
00569       <a class="code" href="tcp_8h.html#a45">TCP_RMV</a>(&amp;tcp_active_pcbs, pcb);
00570       pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> = <a class="code" href="tcp_8h.html#a99a63">TIME_WAIT</a>;
00571       <a class="code" href="tcp_8h.html#a44">TCP_REG</a>(&amp;tcp_tw_pcbs, pcb);
00572     }
00573     <span class="keywordflow">break</span>;
00574   <span class="keywordflow">case</span> <a class="code" href="fsm_8h.html#a12">CLOSING</a>:
00575     tcp_receive(pcb);
00576     <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a13">TCP_ACK</a> &amp;&amp; ackno == pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a>) {
00577       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(DEMO_DEBUG, (<span class="stringliteral">"TCP connection closed %u -&gt; %u.\n"</span>, inseg.<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;src, inseg.<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;dest));
00578       <a class="code" href="tcp_8h.html#a42">tcp_ack_now</a>(pcb);
00579       <a class="code" href="tcp_8h.html#a88">tcp_pcb_purge</a>(pcb);
00580       <a class="code" href="tcp_8h.html#a45">TCP_RMV</a>(&amp;tcp_active_pcbs, pcb);
00581       pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> = <a class="code" href="tcp_8h.html#a99a63">TIME_WAIT</a>;
00582       <a class="code" href="tcp_8h.html#a44">TCP_REG</a>(&amp;tcp_tw_pcbs, pcb);
00583     }
00584     <span class="keywordflow">break</span>;
00585   <span class="keywordflow">case</span> <a class="code" href="tcp_8h.html#a99a62">LAST_ACK</a>:
00586     tcp_receive(pcb);
00587     <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a13">TCP_ACK</a> &amp;&amp; ackno == pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a>) {
00588       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(DEMO_DEBUG, (<span class="stringliteral">"TCP connection closed %u -&gt; %u.\n"</span>, inseg.<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;src, inseg.<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;dest));
00589       pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> = <a class="code" href="fsm_8h.html#a10">CLOSED</a>;
00590       recv_flags = <a class="code" href="tcp_8h.html#a33">TF_CLOSED</a>;
00591     }
00592     <span class="keywordflow">break</span>;
00593   <span class="keywordflow">default</span>:
00594     <span class="keywordflow">break</span>;
00595   }
00596 
00597   <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00598 }
00599 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00600 <span class="comment">/* tcp_receive:</span>
00601 <span class="comment"> *</span>
00602 <span class="comment"> * Called by tcp_process. Checks if the given segment is an ACK for outstanding</span>
00603 <span class="comment"> * data, and if so frees the memory of the buffered data. Next, is places the</span>
00604 <span class="comment"> * segment on any of the receive queues (pcb-&gt;recved or pcb-&gt;ooseq). If the segment</span>
00605 <span class="comment"> * is buffered, the pbuf is referenced by pbuf_ref so that it will not be freed until</span>
00606 <span class="comment"> * i it has been removed from the buffer.</span>
00607 <span class="comment"> *</span>
00608 <span class="comment"> * If the incoming segment constitutes an ACK for a segment that was used for RTT</span>
00609 <span class="comment"> * estimation, the RTT is estimated here as well.</span>
00610 <span class="comment"> */</span>
00611 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00612 <span class="keyword">static</span> <span class="keywordtype">void</span>
00613 tcp_receive(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
00614 {
00615   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *next;
00616 <span class="preprocessor">#if TCP_QUEUE_OOSEQ</span>
00617 <span class="preprocessor"></span>  <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *prev, *cseg;
00618 <span class="preprocessor">#endif</span>
00619 <span class="preprocessor"></span>  <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p;
00620   s32_t off;
00621   <span class="keywordtype">int</span> m;
00622   u32_t right_wnd_edge;
00623 
00624 
00625   <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a13">TCP_ACK</a>) {
00626     right_wnd_edge = pcb-&gt;<a class="code" href="structtcp__pcb.html#o28">snd_wnd</a> + pcb-&gt;<a class="code" href="structtcp__pcb.html#o29">snd_wl1</a>;
00627 
00628     <span class="comment">/* Update window. */</span>
00629     <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a5">TCP_SEQ_LT</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o29">snd_wl1</a>, seqno) ||
00630        (pcb-&gt;<a class="code" href="structtcp__pcb.html#o29">snd_wl1</a> == seqno &amp;&amp; <a class="code" href="tcp_8h.html#a5">TCP_SEQ_LT</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o30">snd_wl2</a>, ackno)) ||
00631        (pcb-&gt;<a class="code" href="structtcp__pcb.html#o30">snd_wl2</a> == ackno &amp;&amp; tcphdr-&gt;wnd &gt; pcb-&gt;<a class="code" href="structtcp__pcb.html#o28">snd_wnd</a>)) {
00632       pcb-&gt;<a class="code" href="structtcp__pcb.html#o28">snd_wnd</a> = tcphdr-&gt;wnd;
00633       pcb-&gt;<a class="code" href="structtcp__pcb.html#o29">snd_wl1</a> = seqno;
00634       pcb-&gt;<a class="code" href="structtcp__pcb.html#o30">snd_wl2</a> = ackno;
00635       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_WND_DEBUG, (<span class="stringliteral">"tcp_receive: window update %lu\n"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o28">snd_wnd</a>));
00636 <span class="preprocessor">#if TCP_WND_DEBUG</span>
00637 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
00638       <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o28">snd_wnd</a> != tcphdr-&gt;wnd) {
00639         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_WND_DEBUG, (<span class="stringliteral">"tcp_receive: no window update lastack %lu snd_max %lu ackno %lu wl1 %lu seqno %lu wl2 %lu\n"</span>,
00640                                pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o27">snd_max</a>, ackno, pcb-&gt;<a class="code" href="structtcp__pcb.html#o29">snd_wl1</a>, seqno, pcb-&gt;<a class="code" href="structtcp__pcb.html#o30">snd_wl2</a>));
00641       }
00642 <span class="preprocessor">#endif </span><span class="comment">/* TCP_WND_DEBUG */</span>
00643     }
00644 
00645 
00646     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a> == ackno) {
00647       pcb-&gt;<a class="code" href="structtcp__pcb.html#o32">acked</a> = 0;
00648 
00649       <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o29">snd_wl1</a> + pcb-&gt;<a class="code" href="structtcp__pcb.html#o28">snd_wnd</a> == right_wnd_edge){
00650   ++pcb-&gt;<a class="code" href="structtcp__pcb.html#o23">dupacks</a>;
00651   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o23">dupacks</a> &gt;= 3 &amp;&amp; pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> != <a class="code" href="def_8h.html#a2">NULL</a>) {
00652     <span class="keywordflow">if</span> (!(pcb-&gt;<a class="code" href="structtcp__pcb.html#o15">flags</a> &amp; <a class="code" href="tcp_8h.html#a31">TF_INFR</a>)) {
00653       <span class="comment">/* This is fast retransmit. Retransmit the first unacked segment. */</span>
00654       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_FR_DEBUG, (<span class="stringliteral">"tcp_receive: dupacks %u (%lu), fast retransmit %lu\n"</span>,
00655           (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)pcb-&gt;<a class="code" href="structtcp__pcb.html#o23">dupacks</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a>,
00656           <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno)));
00657       <a class="code" href="tcp_8h.html#a86">tcp_rexmit</a>(pcb);
00658       <span class="comment">/* Set ssthresh to max (FlightSize / 2, 2*SMSS) */</span>
00659       pcb-&gt;<a class="code" href="structtcp__pcb.html#o25">ssthresh</a> = <a class="code" href="def_8h.html#a0">LWIP_MAX</a>((pcb-&gt;<a class="code" href="structtcp__pcb.html#o27">snd_max</a> -
00660           pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a>) / 2,
00661          2 * pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a>);
00662 
00663       pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o25">ssthresh</a> + 3 * pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a>;
00664       pcb-&gt;<a class="code" href="structtcp__pcb.html#o15">flags</a> |= <a class="code" href="tcp_8h.html#a31">TF_INFR</a>;
00665     } <span class="keywordflow">else</span> {
00666       <span class="comment">/* Inflate the congestion window, but not if it means that</span>
00667 <span class="comment">         the value overflows. */</span>
00668       <span class="keywordflow">if</span> ((u16_t)(pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a> + pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a>) &gt; pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a>) {
00669         pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a> += pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a>;
00670       }
00671     }
00672   }
00673       } <span class="keywordflow">else</span> {
00674   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_FR_DEBUG, (<span class="stringliteral">"tcp_receive: dupack averted %lu %lu\n"</span>,
00675             pcb-&gt;<a class="code" href="structtcp__pcb.html#o29">snd_wl1</a> + pcb-&gt;<a class="code" href="structtcp__pcb.html#o28">snd_wnd</a>, right_wnd_edge));
00676       }
00677     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a5">TCP_SEQ_LT</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a>, ackno) &amp;&amp;
00678               <a class="code" href="tcp_8h.html#a6">TCP_SEQ_LEQ</a>(ackno, pcb-&gt;<a class="code" href="structtcp__pcb.html#o27">snd_max</a>)) {
00679       <span class="comment">/* We come here when the ACK acknowledges new data. */</span>
00680 
00681       <span class="comment">/* Reset the "IN Fast Retransmit" flag, since we are no longer</span>
00682 <span class="comment">         in fast retransmit. Also reset the congestion window to the</span>
00683 <span class="comment">         slow start threshold. */</span>
00684       <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o15">flags</a> &amp; <a class="code" href="tcp_8h.html#a31">TF_INFR</a>) {
00685   pcb-&gt;<a class="code" href="structtcp__pcb.html#o15">flags</a> &amp;= ~<a class="code" href="tcp_8h.html#a31">TF_INFR</a>;
00686   pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o25">ssthresh</a>;
00687       }
00688 
00689       <span class="comment">/* Reset the number of retransmissions. */</span>
00690       pcb-&gt;<a class="code" href="structtcp__pcb.html#o21">nrtx</a> = 0;
00691 
00692       <span class="comment">/* Reset the retransmission time-out. */</span>
00693       pcb-&gt;<a class="code" href="structtcp__pcb.html#o20">rto</a> = (pcb-&gt;<a class="code" href="structtcp__pcb.html#o18">sa</a> &gt;&gt; 3) + pcb-&gt;<a class="code" href="structtcp__pcb.html#o19">sv</a>;
00694 
00695       <span class="comment">/* Update the send buffer space. */</span>
00696       pcb-&gt;<a class="code" href="structtcp__pcb.html#o32">acked</a> = ackno - pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a>;
00697       pcb-&gt;<a class="code" href="structtcp__pcb.html#o33">snd_buf</a> += pcb-&gt;<a class="code" href="structtcp__pcb.html#o32">acked</a>;
00698 
00699       <span class="comment">/* Reset the fast retransmit variables. */</span>
00700       pcb-&gt;<a class="code" href="structtcp__pcb.html#o23">dupacks</a> = 0;
00701       pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a> = ackno;
00702 
00703       <span class="comment">/* Update the congestion control variables (cwnd and</span>
00704 <span class="comment">         ssthresh). */</span>
00705       <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> &gt;= <a class="code" href="tcp_8h.html#a99a57">ESTABLISHED</a>) {
00706         <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a> &lt; pcb-&gt;<a class="code" href="structtcp__pcb.html#o25">ssthresh</a>) {
00707     <span class="keywordflow">if</span> ((u16_t)(pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a> + pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a>) &gt; pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a>) {
00708       pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a> += pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a>;
00709     }
00710           <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_CWND_DEBUG, (<span class="stringliteral">"tcp_receive: slow start cwnd %u\n"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a>));
00711         } <span class="keywordflow">else</span> {
00712     u16_t new_cwnd = (pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a> + pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a> * pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a> / pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a>);
00713     <span class="keywordflow">if</span> (new_cwnd &gt; pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a>) {
00714       pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a> = new_cwnd;
00715     }
00716           <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_CWND_DEBUG, (<span class="stringliteral">"tcp_receive: congestion avoidance cwnd %u\n"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a>));
00717         }
00718       }
00719       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_INPUT_DEBUG, (<span class="stringliteral">"tcp_receive: ACK for %lu, unacked-&gt;seqno %lu:%lu\n"</span>,
00720                                ackno,
00721                                pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> != NULL?
00722                                <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno): 0,
00723                                pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> != NULL?
00724                                <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno) + <a class="code" href="tcp_8h.html#a28">TCP_TCPLEN</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>): 0));
00725 
00726       <span class="comment">/* Remove segment from the unacknowledged list if the incoming</span>
00727 <span class="comment">   ACK acknowlegdes them. */</span>
00728       <span class="keywordflow">while</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> != <a class="code" href="def_8h.html#a2">NULL</a> &amp;&amp;
00729       <a class="code" href="tcp_8h.html#a6">TCP_SEQ_LEQ</a>(<a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno) +
00730       <a class="code" href="tcp_8h.html#a28">TCP_TCPLEN</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>), ackno)) {
00731   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_INPUT_DEBUG, (<span class="stringliteral">"tcp_receive: removing %lu:%lu from pcb-&gt;unacked\n"</span>,
00732          <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno),
00733          <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno) +
00734          <a class="code" href="tcp_8h.html#a28">TCP_TCPLEN</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>)));
00735 
00736   next = pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>;
00737   pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>-&gt;<a class="code" href="structtcp__seg.html#o0">next</a>;
00738 
00739   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_QLEN_DEBUG, (<span class="stringliteral">"tcp_receive: queuelen %u ... "</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)pcb-&gt;<a class="code" href="structtcp__pcb.html#o34">snd_queuelen</a>));
00740   pcb-&gt;<a class="code" href="structtcp__pcb.html#o34">snd_queuelen</a> -= <a class="code" href="pbuf_8c.html#a15">pbuf_clen</a>(next-&gt;p);
00741   <a class="code" href="tcp_8h.html#a91">tcp_seg_free</a>(next);
00742 
00743   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_QLEN_DEBUG, (<span class="stringliteral">"%u (after freeing unacked)\n"</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)pcb-&gt;<a class="code" href="structtcp__pcb.html#o34">snd_queuelen</a>));
00744   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o34">snd_queuelen</a> != 0) {
00745     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_receive: valid queue length"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> != NULL ||
00746      pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a> != NULL);
00747   }
00748       }
00749       pcb-&gt;<a class="code" href="structtcp__pcb.html#o11">polltmr</a> = 0;
00750     }
00751 
00752       <span class="comment">/* We go through the -&gt;unsent list to see if any of the segments</span>
00753 <span class="comment">         on the list are acknowledged by the ACK. This may seem</span>
00754 <span class="comment">         strange since an "unsent" segment shouldn't be acked. The</span>
00755 <span class="comment">         rationale is that lwIP puts all outstanding segments on the</span>
00756 <span class="comment">         -&gt;unsent list after a retransmission, so these segments may</span>
00757 <span class="comment">         in fact have been sent once. */</span>
00758       <span class="keywordflow">while</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a> != <a class="code" href="def_8h.html#a2">NULL</a> &amp;&amp;
00759       <a class="code" href="tcp_8h.html#a6">TCP_SEQ_LEQ</a>(<a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a>-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno) + <a class="code" href="tcp_8h.html#a28">TCP_TCPLEN</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a>),
00760                         ackno) &amp;&amp;
00761       <a class="code" href="tcp_8h.html#a6">TCP_SEQ_LEQ</a>(ackno, pcb-&gt;<a class="code" href="structtcp__pcb.html#o27">snd_max</a>)) {
00762   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_INPUT_DEBUG, (<span class="stringliteral">"tcp_receive: removing %lu:%lu from pcb-&gt;unsent\n"</span>,
00763          <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a>-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno),
00764          <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a>-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno) +
00765          <a class="code" href="tcp_8h.html#a28">TCP_TCPLEN</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a>)));
00766 
00767   next = pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a>;
00768   pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a>-&gt;<a class="code" href="structtcp__seg.html#o0">next</a>;
00769   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_QLEN_DEBUG, (<span class="stringliteral">"tcp_receive: queuelen %u ... "</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)pcb-&gt;<a class="code" href="structtcp__pcb.html#o34">snd_queuelen</a>));
00770   pcb-&gt;<a class="code" href="structtcp__pcb.html#o34">snd_queuelen</a> -= <a class="code" href="pbuf_8c.html#a15">pbuf_clen</a>(next-&gt;p);
00771   <a class="code" href="tcp_8h.html#a91">tcp_seg_free</a>(next);
00772   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_QLEN_DEBUG, (<span class="stringliteral">"%u (after freeing unsent)\n"</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)pcb-&gt;<a class="code" href="structtcp__pcb.html#o34">snd_queuelen</a>));
00773   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o34">snd_queuelen</a> != 0) {
00774     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_receive: valid queue length"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> != NULL ||
00775      pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a> != NULL);
00776   }
00777 
00778         <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a> != <a class="code" href="def_8h.html#a2">NULL</a>) {
00779           pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a> = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a>-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno);
00780         }
00781       }
00782 
00783     <span class="comment">/* End of ACK for new data processing. */</span>
00784 
00785     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_RTO_DEBUG, (<span class="stringliteral">"tcp_receive: pcb-&gt;rttest %u rtseq %lu ackno %lu\n"</span>,
00786      pcb-&gt;<a class="code" href="structtcp__pcb.html#o16">rttest</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o17">rtseq</a>, ackno));
00787 
00788     <span class="comment">/* RTT estimation calculations. This is done by checking if the</span>
00789 <span class="comment">       incoming segment acknowledges the segment we use to take a</span>
00790 <span class="comment">       round-trip time measurement. */</span>
00791     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o16">rttest</a> &amp;&amp; <a class="code" href="tcp_8h.html#a5">TCP_SEQ_LT</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o17">rtseq</a>, ackno)) {
00792       m = <a class="code" href="tcp_8h.html#a48">tcp_ticks</a> - pcb-&gt;<a class="code" href="structtcp__pcb.html#o16">rttest</a>;
00793 
00794       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_RTO_DEBUG, (<span class="stringliteral">"tcp_receive: experienced rtt %u ticks (%u msec).\n"</span>,
00795        m, m * TCP_SLOW_INTERVAL));
00796 
00797       <span class="comment">/* This is taken directly from VJs original code in his paper */</span>
00798       m = m - (pcb-&gt;<a class="code" href="structtcp__pcb.html#o18">sa</a> &gt;&gt; 3);
00799       pcb-&gt;<a class="code" href="structtcp__pcb.html#o18">sa</a> += m;
00800       <span class="keywordflow">if</span> (m &lt; 0) {
00801   m = -m;
00802       }
00803       m = m - (pcb-&gt;<a class="code" href="structtcp__pcb.html#o19">sv</a> &gt;&gt; 2);
00804       pcb-&gt;<a class="code" href="structtcp__pcb.html#o19">sv</a> += m;
00805       pcb-&gt;<a class="code" href="structtcp__pcb.html#o20">rto</a> = (pcb-&gt;<a class="code" href="structtcp__pcb.html#o18">sa</a> &gt;&gt; 3) + pcb-&gt;<a class="code" href="structtcp__pcb.html#o19">sv</a>;
00806 
00807       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_RTO_DEBUG, (<span class="stringliteral">"tcp_receive: RTO %u (%u miliseconds)\n"</span>,
00808            pcb-&gt;<a class="code" href="structtcp__pcb.html#o20">rto</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o20">rto</a> * TCP_SLOW_INTERVAL));
00809 
00810       pcb-&gt;<a class="code" href="structtcp__pcb.html#o16">rttest</a> = 0;
00811     }
00812   }
00813 
00814   <span class="comment">/* If the incoming segment contains data, we must process it</span>
00815 <span class="comment">     further. */</span>
00816   <span class="keywordflow">if</span> (tcplen &gt; 0) {
00817     <span class="comment">/* This code basically does three things:</span>
00818 <span class="comment"></span>
00819 <span class="comment">     +) If the incoming segment contains data that is the next</span>
00820 <span class="comment">        in-sequence data, this data is passed to the application. This</span>
00821 <span class="comment">        might involve trimming the first edge of the data. The rcv_nxt</span>
00822 <span class="comment">        variable and the advertised window are adjusted.</span>
00823 <span class="comment"></span>
00824 <span class="comment">     +) If the incoming segment has data that is above the next</span>
00825 <span class="comment">        sequence number expected (-&gt;rcv_nxt), the segment is placed on</span>
00826 <span class="comment">        the -&gt;ooseq queue. This is done by finding the appropriate</span>
00827 <span class="comment">        place in the -&gt;ooseq queue (which is ordered by sequence</span>
00828 <span class="comment">        number) and trim the segment in both ends if needed. An</span>
00829 <span class="comment">        immediate ACK is sent to indicate that we received an</span>
00830 <span class="comment">        out-of-sequence segment.</span>
00831 <span class="comment"></span>
00832 <span class="comment">     +) Finally, we check if the first segment on the -&gt;ooseq queue</span>
00833 <span class="comment">        now is in sequence (i.e., if rcv_nxt &gt;= ooseq-&gt;seqno). If</span>
00834 <span class="comment">        rcv_nxt &gt; ooseq-&gt;seqno, we must trim the first edge of the</span>
00835 <span class="comment">        segment on -&gt;ooseq before we adjust rcv_nxt. The data in the</span>
00836 <span class="comment">        segments that are now on sequence are chained onto the</span>
00837 <span class="comment">        incoming segment so that we only need to call the application</span>
00838 <span class="comment">        once.</span>
00839 <span class="comment">    */</span>
00840 
00841     <span class="comment">/* First, we check if we must trim the first edge. We have to do</span>
00842 <span class="comment">       this if the sequence number of the incoming segment is less</span>
00843 <span class="comment">       than rcv_nxt, and the sequence number plus the length of the</span>
00844 <span class="comment">       segment is larger than rcv_nxt. */</span>
00845     <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a5">TCP_SEQ_LT</a>(seqno, pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>)){
00846       <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a5">TCP_SEQ_LT</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>, seqno + tcplen)) {
00847   <span class="comment">/* Trimming the first edge is done by pushing the payload</span>
00848 <span class="comment">     pointer in the pbuf downwards. This is somewhat tricky since</span>
00849 <span class="comment">     we do not want to discard the full contents of the pbuf up to</span>
00850 <span class="comment">     the new starting point of the data since we have to keep the</span>
00851 <span class="comment">     TCP header which is present in the first pbuf in the chain.</span>
00852 <span class="comment"></span>
00853 <span class="comment">     What is done is really quite a nasty hack: the first pbuf in</span>
00854 <span class="comment">     the pbuf chain is pointed to by inseg.p. Since we need to be</span>
00855 <span class="comment">     able to deallocate the whole pbuf, we cannot change this</span>
00856 <span class="comment">     inseg.p pointer to point to any of the later pbufs in the</span>
00857 <span class="comment">     chain. Instead, we point the -&gt;payload pointer in the first</span>
00858 <span class="comment">     pbuf to data in one of the later pbufs. We also set the</span>
00859 <span class="comment">     inseg.data pointer to point to the right place. This way, the</span>
00860 <span class="comment">     -&gt;p pointer will still point to the first pbuf, but the</span>
00861 <span class="comment">     -&gt;p-&gt;payload pointer will point to data in another pbuf.</span>
00862 <span class="comment"></span>
00863 <span class="comment">     After we are done with adjusting the pbuf pointers we must</span>
00864 <span class="comment">     adjust the -&gt;data pointer in the seg and the segment</span>
00865 <span class="comment">     length.*/</span>
00866   off = pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a> - seqno;
00867   <span class="keywordflow">if</span> (inseg.<a class="code" href="structtcp__seg.html#o1">p</a>-&gt;<a class="code" href="structpbuf.html#o3">len</a> &lt; off) {
00868     p = inseg.<a class="code" href="structtcp__seg.html#o1">p</a>;
00869     <span class="keywordflow">while</span> (p-&gt;<a class="code" href="structpbuf.html#o3">len</a> &lt; off) {
00870       off -= p-&gt;<a class="code" href="structpbuf.html#o3">len</a>;
00871       inseg.<a class="code" href="structtcp__seg.html#o1">p</a>-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a> -= p-&gt;<a class="code" href="structpbuf.html#o3">len</a>;
00872       p-&gt;<a class="code" href="structpbuf.html#o3">len</a> = 0;
00873       p = p-&gt;<a class="code" href="structpbuf.html#o0">next</a>;
00874     }
00875     <a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(p, -off);
00876   } <span class="keywordflow">else</span> {
00877     <a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(inseg.<a class="code" href="structtcp__seg.html#o1">p</a>, -off);
00878   }
00879   inseg.<a class="code" href="structtcp__seg.html#o2">dataptr</a> = inseg.<a class="code" href="structtcp__seg.html#o1">p</a>-&gt;<a class="code" href="structpbuf.html#o1">payload</a>;
00880   inseg.<a class="code" href="structtcp__seg.html#o3">len</a> -= pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a> - seqno;
00881   inseg.<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno = seqno = pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>;
00882       }
00883       <span class="keywordflow">else</span>{
00884   <span class="comment">/* the whole segment is &lt; rcv_nxt */</span>
00885   <span class="comment">/* must be a duplicate of a packet that has already been correctly handled */</span>
00886 
00887   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_INPUT_DEBUG, (<span class="stringliteral">"tcp_receive: duplicate seqno %lu\n"</span>, seqno));
00888   <a class="code" href="tcp_8h.html#a42">tcp_ack_now</a>(pcb);
00889       }
00890     }
00891 
00892     <span class="comment">/* The sequence number must be within the window (above rcv_nxt</span>
00893 <span class="comment">       and below rcv_nxt + rcv_wnd) in order to be further</span>
00894 <span class="comment">       processed. */</span>
00895     <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a8">TCP_SEQ_GEQ</a>(seqno, pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>) &amp;&amp;
00896        <a class="code" href="tcp_8h.html#a5">TCP_SEQ_LT</a>(seqno, pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a> + pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a>)) {
00897       <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a> == seqno) {
00898   <span class="comment">/* The incoming segment is the next in sequence. We check if</span>
00899 <span class="comment">           we have to trim the end of the segment and update rcv_nxt</span>
00900 <span class="comment">           and pass the data to the application. */</span>
00901 <span class="preprocessor">#if TCP_QUEUE_OOSEQ</span>
00902 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (pcb-&gt;ooseq != <a class="code" href="def_8h.html#a2">NULL</a> &amp;&amp;
00903      <a class="code" href="tcp_8h.html#a6">TCP_SEQ_LEQ</a>(pcb-&gt;ooseq-&gt;tcphdr-&gt;seqno, seqno + inseg.<a class="code" href="structtcp__seg.html#o3">len</a>)) {
00904     <span class="comment">/* We have to trim the second edge of the incoming</span>
00905 <span class="comment">             segment. */</span>
00906     inseg.<a class="code" href="structtcp__seg.html#o3">len</a> = pcb-&gt;ooseq-&gt;tcphdr-&gt;seqno - seqno;
00907     <a class="code" href="pbuf_8c.html#a12">pbuf_realloc</a>(inseg.<a class="code" href="structtcp__seg.html#o1">p</a>, inseg.<a class="code" href="structtcp__seg.html#o3">len</a>);
00908   }
00909 <span class="preprocessor">#endif </span><span class="comment">/* TCP_QUEUE_OOSEQ */</span>
00910 
00911   tcplen = <a class="code" href="tcp_8h.html#a28">TCP_TCPLEN</a>(&amp;inseg);
00912 
00913   pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a> += tcplen;
00914 
00915   <span class="comment">/* Update the receiver's (our) window. */</span>
00916   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a> &lt; tcplen) {
00917     pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a> = 0;
00918   } <span class="keywordflow">else</span> {
00919     pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a> -= tcplen;
00920   }
00921 
00922   <span class="comment">/* If there is data in the segment, we make preparations to</span>
00923 <span class="comment">     pass this up to the application. The -&gt;recv_data variable</span>
00924 <span class="comment">     is used for holding the pbuf that goes to the</span>
00925 <span class="comment">     application. The code for reassembling out-of-sequence data</span>
00926 <span class="comment">     chains its data on this pbuf as well.</span>
00927 <span class="comment"></span>
00928 <span class="comment">     If the segment was a FIN, we set the TF_GOT_FIN flag that will</span>
00929 <span class="comment">     be used to indicate to the application that the remote side has</span>
00930 <span class="comment">     closed its end of the connection. */</span>
00931   <span class="keywordflow">if</span> (inseg.<a class="code" href="structtcp__seg.html#o1">p</a>-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a> &gt; 0) {
00932     recv_data = inseg.<a class="code" href="structtcp__seg.html#o1">p</a>;
00933     <span class="comment">/* Since this pbuf now is the responsibility of the</span>
00934 <span class="comment">       application, we delete our reference to it so that we won't</span>
00935 <span class="comment">       (mistakingly) deallocate it. */</span>
00936     inseg.<a class="code" href="structtcp__seg.html#o1">p</a> = <a class="code" href="def_8h.html#a2">NULL</a>;
00937   }
00938   <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a25">TCPH_FLAGS</a>(inseg.<a class="code" href="structtcp__seg.html#o4">tcphdr</a>) &amp; <a class="code" href="tcp_8h.html#a9">TCP_FIN</a>) {
00939     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_INPUT_DEBUG, (<span class="stringliteral">"tcp_receive: received FIN."</span>));
00940     recv_flags = <a class="code" href="tcp_8h.html#a34">TF_GOT_FIN</a>;
00941   }
00942 
00943 <span class="preprocessor">#if TCP_QUEUE_OOSEQ</span>
00944 <span class="preprocessor"></span>  <span class="comment">/* We now check if we have segments on the -&gt;ooseq queue that</span>
00945 <span class="comment">           is now in sequence. */</span>
00946   <span class="keywordflow">while</span> (pcb-&gt;ooseq != <a class="code" href="def_8h.html#a2">NULL</a> &amp;&amp;
00947         pcb-&gt;ooseq-&gt;tcphdr-&gt;seqno == pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>) {
00948 
00949     cseg = pcb-&gt;ooseq;
00950     seqno = pcb-&gt;ooseq-&gt;tcphdr-&gt;seqno;
00951 
00952     pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a> += <a class="code" href="tcp_8h.html#a28">TCP_TCPLEN</a>(cseg);
00953     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a> &lt; <a class="code" href="tcp_8h.html#a28">TCP_TCPLEN</a>(cseg)) {
00954       pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a> = 0;
00955     } <span class="keywordflow">else</span> {
00956       pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a> -= <a class="code" href="tcp_8h.html#a28">TCP_TCPLEN</a>(cseg);
00957     }
00958     <span class="keywordflow">if</span> (cseg-&gt;p-&gt;tot_len &gt; 0) {
00959       <span class="comment">/* Chain this pbuf onto the pbuf that we will pass to</span>
00960 <span class="comment">         the application. */</span>
00961       <span class="keywordflow">if</span> (recv_data) {
00962               <a class="code" href="pbuf_8c.html#a17">pbuf_chain</a>(recv_data, cseg-&gt;p);
00963               <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(cseg-&gt;p);
00964             } <span class="keywordflow">else</span> {
00965         recv_data = cseg-&gt;p;
00966       }
00967       cseg-&gt;p = <a class="code" href="def_8h.html#a2">NULL</a>;
00968     }
00969     <span class="keywordflow">if</span> (flags &amp; <a class="code" href="tcp_8h.html#a9">TCP_FIN</a>) {
00970       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_INPUT_DEBUG, (<span class="stringliteral">"tcp_receive: dequeued FIN."</span>));
00971       recv_flags = <a class="code" href="tcp_8h.html#a34">TF_GOT_FIN</a>;
00972     }
00973 
00974 
00975     pcb-&gt;ooseq = cseg-&gt;<a class="code" href="structtcp__pcb.html#o0">next</a>;
00976     <a class="code" href="tcp_8h.html#a91">tcp_seg_free</a>(cseg);
00977   }
00978 <span class="preprocessor">#endif </span><span class="comment">/* TCP_QUEUE_OOSEQ */</span>
00979 
00980 
00981   <span class="comment">/* Acknowledge the segment(s). */</span>
00982   <a class="code" href="tcp_8h.html#a41">tcp_ack</a>(pcb);
00983 
00984       } <span class="keywordflow">else</span> {
00985   <span class="comment">/* We get here if the incoming segment is out-of-sequence. */</span>
00986   <a class="code" href="tcp_8h.html#a42">tcp_ack_now</a>(pcb);
00987 <span class="preprocessor">#if TCP_QUEUE_OOSEQ</span>
00988 <span class="preprocessor"></span>  <span class="comment">/* We queue the segment on the -&gt;ooseq queue. */</span>
00989   <span class="keywordflow">if</span> (pcb-&gt;ooseq == <a class="code" href="def_8h.html#a2">NULL</a>) {
00990     pcb-&gt;ooseq = <a class="code" href="tcp_8h.html#a92">tcp_seg_copy</a>(&amp;inseg);
00991   } <span class="keywordflow">else</span> {
00992     <span class="comment">/* If the queue is not empty, we walk through the queue and</span>
00993 <span class="comment">    try to find a place where the sequence number of the</span>
00994 <span class="comment">    incoming segment is between the sequence numbers of the</span>
00995 <span class="comment">    previous and the next segment on the -&gt;ooseq queue. That is</span>
00996 <span class="comment">    the place where we put the incoming segment. If needed, we</span>
00997 <span class="comment">    trim the second edges of the previous and the incoming</span>
00998 <span class="comment">    segment so that it will fit into the sequence.</span>
00999 <span class="comment"></span>
01000 <span class="comment">    If the incoming segment has the same sequence number as a</span>
01001 <span class="comment">    segment on the -&gt;ooseq queue, we discard the segment that</span>
01002 <span class="comment">    contains less data. */</span>
01003 
01004     prev = <a class="code" href="def_8h.html#a2">NULL</a>;
01005     <span class="keywordflow">for</span>(next = pcb-&gt;ooseq; next != <a class="code" href="def_8h.html#a2">NULL</a>; next = next-&gt;next) {
01006       <span class="keywordflow">if</span> (seqno == next-&gt;tcphdr-&gt;seqno) {
01007         <span class="comment">/* The sequence number of the incoming segment is the</span>
01008 <span class="comment">                 same as the sequence number of the segment on</span>
01009 <span class="comment">                 -&gt;ooseq. We check the lengths to see which one to</span>
01010 <span class="comment">                 discard. */</span>
01011         <span class="keywordflow">if</span> (inseg.<a class="code" href="structtcp__seg.html#o3">len</a> &gt; next-&gt;len) {
01012     <span class="comment">/* The incoming segment is larger than the old</span>
01013 <span class="comment">                   segment. We replace the old segment with the new</span>
01014 <span class="comment">                   one. */</span>
01015     cseg = <a class="code" href="tcp_8h.html#a92">tcp_seg_copy</a>(&amp;inseg);
01016     <span class="keywordflow">if</span> (cseg != <a class="code" href="def_8h.html#a2">NULL</a>) {
01017       cseg-&gt;next = next-&gt;next;
01018       <span class="keywordflow">if</span> (prev != <a class="code" href="def_8h.html#a2">NULL</a>) {
01019         prev-&gt;next = cseg;
01020       } <span class="keywordflow">else</span> {
01021         pcb-&gt;ooseq = cseg;
01022       }
01023     }
01024     <span class="keywordflow">break</span>;
01025         } <span class="keywordflow">else</span> {
01026     <span class="comment">/* Either the lenghts are the same or the incoming</span>
01027 <span class="comment">                   segment was smaller than the old one; in either</span>
01028 <span class="comment">                   case, we ditch the incoming segment. */</span>
01029     <span class="keywordflow">break</span>;
01030         }
01031       } <span class="keywordflow">else</span> {
01032         <span class="keywordflow">if</span> (prev == <a class="code" href="def_8h.html#a2">NULL</a>) {
01033     <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a5">TCP_SEQ_LT</a>(seqno, next-&gt;tcphdr-&gt;seqno)) {
01034       <span class="comment">/* The sequence number of the incoming segment is lower</span>
01035 <span class="comment">         than the sequence number of the first segment on the</span>
01036 <span class="comment">         queue. We put the incoming segment first on the</span>
01037 <span class="comment">         queue. */</span>
01038 
01039       <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a7">TCP_SEQ_GT</a>(seqno + inseg.<a class="code" href="structtcp__seg.html#o3">len</a>, next-&gt;tcphdr-&gt;seqno)) {
01040         <span class="comment">/* We need to trim the incoming segment. */</span>
01041         inseg.<a class="code" href="structtcp__seg.html#o3">len</a> = next-&gt;tcphdr-&gt;seqno - seqno;
01042         <a class="code" href="pbuf_8c.html#a12">pbuf_realloc</a>(inseg.<a class="code" href="structtcp__seg.html#o1">p</a>, inseg.<a class="code" href="structtcp__seg.html#o3">len</a>);
01043       }
01044       cseg = <a class="code" href="tcp_8h.html#a92">tcp_seg_copy</a>(&amp;inseg);
01045       <span class="keywordflow">if</span> (cseg != <a class="code" href="def_8h.html#a2">NULL</a>) {
01046         cseg-&gt;next = next;
01047         pcb-&gt;ooseq = cseg;
01048       }
01049       <span class="keywordflow">break</span>;
01050     }
01051         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a5">TCP_SEQ_LT</a>(prev-&gt;tcphdr-&gt;seqno, seqno) &amp;&amp;
01052      <a class="code" href="tcp_8h.html#a5">TCP_SEQ_LT</a>(seqno, next-&gt;tcphdr-&gt;seqno)) {
01053     <span class="comment">/* The sequence number of the incoming segment is in</span>
01054 <span class="comment">                   between the sequence numbers of the previous and</span>
01055 <span class="comment">                   the next segment on -&gt;ooseq. We trim and insert the</span>
01056 <span class="comment">                   incoming segment and trim the previous segment, if</span>
01057 <span class="comment">                   needed. */</span>
01058     <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a7">TCP_SEQ_GT</a>(seqno + inseg.<a class="code" href="structtcp__seg.html#o3">len</a>, next-&gt;tcphdr-&gt;seqno)) {
01059       <span class="comment">/* We need to trim the incoming segment. */</span>
01060       inseg.<a class="code" href="structtcp__seg.html#o3">len</a> = next-&gt;tcphdr-&gt;seqno - seqno;
01061       <a class="code" href="pbuf_8c.html#a12">pbuf_realloc</a>(inseg.<a class="code" href="structtcp__seg.html#o1">p</a>, inseg.<a class="code" href="structtcp__seg.html#o3">len</a>);
01062     }
01063 
01064     cseg = <a class="code" href="tcp_8h.html#a92">tcp_seg_copy</a>(&amp;inseg);
01065     <span class="keywordflow">if</span> (cseg != <a class="code" href="def_8h.html#a2">NULL</a>) {
01066       cseg-&gt;next = next;
01067       prev-&gt;next = cseg;
01068       <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a7">TCP_SEQ_GT</a>(prev-&gt;tcphdr-&gt;seqno + prev-&gt;len, seqno)) {
01069         <span class="comment">/* We need to trim the prev segment. */</span>
01070         prev-&gt;len = seqno - prev-&gt;tcphdr-&gt;seqno;
01071         <a class="code" href="pbuf_8c.html#a12">pbuf_realloc</a>(prev-&gt;p, prev-&gt;len);
01072       }
01073     }
01074     <span class="keywordflow">break</span>;
01075     }
01076         <span class="comment">/* If the "next" segment is the last segment on the</span>
01077 <span class="comment">                 ooseq queue, we add the incoming segment to the end</span>
01078 <span class="comment">                 of the list. */</span>
01079         <span class="keywordflow">if</span> (next-&gt;next == <a class="code" href="def_8h.html#a2">NULL</a> &amp;&amp;
01080      <a class="code" href="tcp_8h.html#a7">TCP_SEQ_GT</a>(seqno, next-&gt;tcphdr-&gt;seqno)) {
01081     next-&gt;next = <a class="code" href="tcp_8h.html#a92">tcp_seg_copy</a>(&amp;inseg);
01082     <span class="keywordflow">if</span> (next-&gt;next != <a class="code" href="def_8h.html#a2">NULL</a>) {
01083       <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a7">TCP_SEQ_GT</a>(next-&gt;tcphdr-&gt;seqno + next-&gt;len, seqno)) {
01084         <span class="comment">/* We need to trim the last segment. */</span>
01085         next-&gt;len = seqno - next-&gt;tcphdr-&gt;seqno;
01086         <a class="code" href="pbuf_8c.html#a12">pbuf_realloc</a>(next-&gt;p, next-&gt;len);
01087       }
01088     }
01089     <span class="keywordflow">break</span>;
01090         }
01091       }
01092       prev = next;
01093     }
01094   }
01095 <span class="preprocessor">#endif </span><span class="comment">/* TCP_QUEUE_OOSEQ */</span>
01096 
01097       }
01098     }
01099   } <span class="keywordflow">else</span> {
01100     <span class="comment">/* Segments with length 0 is taken care of here. Segments that</span>
01101 <span class="comment">       fall out of the window are ACKed. */</span>
01102     <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a7">TCP_SEQ_GT</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>, seqno) ||
01103        <a class="code" href="tcp_8h.html#a8">TCP_SEQ_GEQ</a>(seqno, pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a> + pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a>)) {
01104       <a class="code" href="tcp_8h.html#a42">tcp_ack_now</a>(pcb);
01105     }
01106   }
01107 }
01108 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
01109 <span class="comment">/*</span>
01110 <span class="comment"> * tcp_parseopt:</span>
01111 <span class="comment"> *</span>
01112 <span class="comment"> * Parses the options contained in the incoming segment. (Code taken</span>
01113 <span class="comment"> * from uIP with only small changes.)</span>
01114 <span class="comment"> *</span>
01115 <span class="comment"> */</span>
01116 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
01117 <span class="keyword">static</span> <span class="keywordtype">void</span>
01118 tcp_parseopt(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
01119 {
01120   u8_t c;
01121   u8_t *opts, opt;
01122   u16_t mss;
01123 
01124   opts = (u8_t *)tcphdr + <a class="code" href="tcp_8h.html#a16">TCP_HLEN</a>;
01125 
01126   <span class="comment">/* Parse the TCP MSS option, if present. */</span>
01127   <span class="keywordflow">if</span> ((<a class="code" href="tcp_8h.html#a24">TCPH_OFFSET</a>(tcphdr) &amp; 0xf0) &gt; 0x50) {
01128     <span class="keywordflow">for</span>(c = 0; c &lt; ((TCPH_OFFSET(tcphdr) &gt;&gt; 4) - 5) &lt;&lt; 2 ;) {
01129       opt = opts[c];
01130       <span class="keywordflow">if</span> (opt == 0x00) {
01131         <span class="comment">/* End of options. */</span>
01132   <span class="keywordflow">break</span>;
01133       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opt == 0x01) {
01134         ++c;
01135         <span class="comment">/* NOP option. */</span>
01136       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opt == 0x02 &amp;&amp;
01137                 opts[c + 1] == 0x04) {
01138         <span class="comment">/* An MSS option with the right option length. */</span>
01139         mss = (opts[c + 2] &lt;&lt; 8) | opts[c + 3];
01140         pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a> = mss &gt; <a class="code" href="opt_8h.html#a36">TCP_MSS</a>? <a class="code" href="opt_8h.html#a36">TCP_MSS</a>: mss;
01141 
01142         <span class="comment">/* And we are done processing options. */</span>
01143         <span class="keywordflow">break</span>;
01144       } <span class="keywordflow">else</span> {
01145   <span class="keywordflow">if</span> (opts[c + 1] == 0) {
01146           <span class="comment">/* If the length field is zero, the options are malformed</span>
01147 <span class="comment">             and we don't process them further. */</span>
01148           <span class="keywordflow">break</span>;
01149         }
01150         <span class="comment">/* All other options have a length field, so that we easily</span>
01151 <span class="comment">           can skip past them. */</span>
01152         c += opts[c + 1];
01153       }
01154     }
01155   }
01156 }
01157 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_TCP */</span>
01158 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
01159 
</pre></div>	</td>
  </tr>
</table>
<hr>
<div align="center">Copyright (c) 2001-2003 Swedish Institute of Computer Science</div>
</html>
