
<html>
<head>
<title>lwIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="doxygen.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<table width="98%" border="0" align="center">
  <tr>
    <td>
      <h2>lwIP code documentation</h2>
<hr>

<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>udp.c</h1><a href="udp_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00006 <span class="comment">/*</span>
00007 <span class="comment"> * Copyright (c) 2001-2003 Swedish Institute of Computer Science.</span>
00008 <span class="comment"> * All rights reserved.</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> * Redistribution and use in source and binary forms, with or without modification,</span>
00011 <span class="comment"> * are permitted provided that the following conditions are met:</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span>
00014 <span class="comment"> *    this list of conditions and the following disclaimer.</span>
00015 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
00016 <span class="comment"> *    this list of conditions and the following disclaimer in the documentation</span>
00017 <span class="comment"> *    and/or other materials provided with the distribution.</span>
00018 <span class="comment"> * 3. The name of the author may not be used to endorse or promote products</span>
00019 <span class="comment"> *    derived from this software without specific prior written permission.</span>
00020 <span class="comment"> *</span>
00021 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED</span>
00022 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
00023 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT</span>
00024 <span class="comment"> * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
00025 <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT</span>
00026 <span class="comment"> * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
00027 <span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
00028 <span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
00029 <span class="comment"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY</span>
00030 <span class="comment"> * OF SUCH DAMAGE.</span>
00031 <span class="comment"> *</span>
00032 <span class="comment"> * This file is part of the lwIP TCP/IP stack.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Author: Adam Dunkels &lt;adam@sics.se&gt;</span>
00035 <span class="comment"> *</span>
00036 <span class="comment"> */</span>
00037 
00038 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00039 <span class="comment">/* udp.c</span>
00040 <span class="comment"> *</span>
00041 <span class="comment"> * The code for the User Datagram Protocol UDP.</span>
00042 <span class="comment"> *</span>
00043 <span class="comment"> */</span>
00044 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00045 <span class="preprocessor">#include "<a class="code" href="opt_8h.html">lwip/opt.h</a>"</span>
00046 
00047 <span class="preprocessor">#include "<a class="code" href="def_8h.html">lwip/def.h</a>"</span>
00048 <span class="preprocessor">#include "<a class="code" href="memp_8h.html">lwip/memp.h</a>"</span>
00049 <span class="preprocessor">#include "lwip/inet.h"</span>
00050 <span class="preprocessor">#include "<a class="code" href="netif_8h.html">lwip/netif.h</a>"</span>
00051 <span class="preprocessor">#include "<a class="code" href="udp_8h.html">lwip/udp.h</a>"</span>
00052 <span class="preprocessor">#include "lwip/icmp.h"</span>
00053 <span class="preprocessor">#include "lwip/ip_addr.h"</span>
00054 
00055 <span class="preprocessor">#include "<a class="code" href="stats_8h.html">lwip/stats.h</a>"</span>
00056 
00057 <span class="preprocessor">#include "arch/perf.h"</span>
00058 <span class="preprocessor">#include "<a class="code" href="snmp_8h.html">lwip/snmp.h</a>"</span>
00059 
00060 <span class="comment">/* The list of UDP PCBs */</span>
00061 <span class="preprocessor">#if LWIP_UDP</span>
00062 <span class="preprocessor"></span><span class="comment">/* was static, but we may want to access this from a socket layer */</span>
00063 <span class="keyword">struct </span><a class="code" href="structudp__pcb.html">udp_pcb</a> *udp_pcbs = <a class="code" href="def_8h.html#a2">NULL</a>;
00064 
00065 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structudp__pcb.html">udp_pcb</a> *pcb_cache = <a class="code" href="def_8h.html#a2">NULL</a>;
00066 
00067 <span class="preprocessor">#if UDP_DEBUG</span>
00068 <span class="preprocessor"></span><span class="keywordtype">int</span> udp_debug_print(<span class="keyword">struct</span> <a class="code" href="structudp__hdr.html">udp_hdr</a> *udphdr);
00069 <span class="preprocessor">#endif </span><span class="comment">/* UDP_DEBUG */</span>
00070 
00071 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00072 <span class="keywordtype">void</span>
00073 <a class="code" href="udp_8h.html#a16">udp_init</a>(<span class="keywordtype">void</span>)
00074 {
00075   udp_pcbs = pcb_cache = <a class="code" href="def_8h.html#a2">NULL</a>;
00076 }
00077 
00078 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00079 <span class="comment">/* udp_lookup:</span>
00080 <span class="comment"> *</span>
00081 <span class="comment"> * An experimental feature that will be changed in future versions. Do</span>
00082 <span class="comment"> * not depend on it yet...</span>
00083 <span class="comment"> */</span>
00084 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00085 <span class="preprocessor">#ifdef LWIP_DEBUG</span>
00086 <span class="preprocessor"></span>u8_t
00087 <a class="code" href="udp_8h.html#a14">udp_lookup</a>(<span class="keyword">struct</span> <a class="code" href="structip__hdr.html">ip_hdr</a> *iphdr, <span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *inp)
00088 {
00089   <span class="keyword">struct </span><a class="code" href="structudp__pcb.html">udp_pcb</a> *pcb;
00090   <span class="keyword">struct </span><a class="code" href="structudp__hdr.html">udp_hdr</a> *udphdr;
00091   u16_t src, dest;
00092 
00093     PERF_START;
00094   (<span class="keywordtype">void</span>)inp;
00095 
00096     udphdr = (<span class="keyword">struct </span><a class="code" href="structudp__hdr.html">udp_hdr</a> *)(u8_t *)iphdr + <a class="code" href="ipv4_2lwip_2ip_8h.html#a11">IPH_HL</a>(iphdr) * 4;
00097 
00098   src = <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(udphdr-&gt;src);
00099   dest = <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(udphdr-&gt;dest);
00100 
00101     pcb = pcb_cache;
00102   <span class="keywordflow">if</span> (pcb != <a class="code" href="def_8h.html#a2">NULL</a> &amp;&amp;
00103     pcb-&gt;remote_port == src &amp;&amp;
00104     pcb-&gt;local_port == dest &amp;&amp;
00105     (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;pcb-&gt;remote_ip) ||
00106     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(pcb-&gt;remote_ip), &amp;(iphdr-&gt;src))) &amp;&amp;
00107     (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;pcb-&gt;local_ip) ||
00108     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(pcb-&gt;local_ip), &amp;(iphdr-&gt;<a class="code" href="structip__hdr.html#o8">dest</a>)))) {
00109     <span class="keywordflow">return</span> 1;
00110   }
00111   <span class="keywordflow">else</span> {
00112     <span class="keywordflow">for</span>(pcb = udp_pcbs; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;next) {
00113       <span class="keywordflow">if</span> (pcb-&gt;remote_port == src &amp;&amp;
00114    pcb-&gt;local_port == dest &amp;&amp;
00115    (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;pcb-&gt;remote_ip) ||
00116     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(pcb-&gt;remote_ip), &amp;(iphdr-&gt;src))) &amp;&amp;
00117    (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;pcb-&gt;local_ip) ||
00118     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(pcb-&gt;local_ip), &amp;(iphdr-&gt;<a class="code" href="structip__hdr.html#o8">dest</a>)))) {
00119   pcb_cache = pcb;
00120         <span class="keywordflow">break</span>;
00121         }
00122     }
00123 
00124     <span class="keywordflow">if</span> (pcb == <a class="code" href="def_8h.html#a2">NULL</a>) {
00125       <span class="keywordflow">for</span>(pcb = udp_pcbs; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;next) {
00126   <span class="keywordflow">if</span> (pcb-&gt;remote_port == 0 &amp;&amp;
00127      pcb-&gt;local_port == dest &amp;&amp;
00128      (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;pcb-&gt;remote_ip) ||
00129       <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(pcb-&gt;remote_ip), &amp;(iphdr-&gt;src))) &amp;&amp;
00130      (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;pcb-&gt;local_ip) ||
00131       <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(pcb-&gt;local_ip), &amp;(iphdr-&gt;<a class="code" href="structip__hdr.html#o8">dest</a>)))) {
00132         <span class="keywordflow">break</span>;
00133         }
00134       }
00135     }
00136   }
00137 
00138   PERF_STOP(<span class="stringliteral">"udp_lookup"</span>);
00139 
00140   <span class="keywordflow">if</span> (pcb != <a class="code" href="def_8h.html#a2">NULL</a>) {
00141     <span class="keywordflow">return</span> 1;
00142   }
00143   <span class="keywordflow">else</span> {
00144     <span class="keywordflow">return</span> 1;
00145   }
00146 }
00147 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_DEBUG */</span>
00148 
00158 <span class="keywordtype">void</span>
00159 <a class="code" href="udp_8h.html#a15">udp_input</a>(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p, <span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *inp)
00160 {
00161   <span class="keyword">struct </span><a class="code" href="structudp__hdr.html">udp_hdr</a> *udphdr;
00162   <span class="keyword">struct </span><a class="code" href="structudp__pcb.html">udp_pcb</a> *pcb;
00163   <span class="keyword">struct </span><a class="code" href="structip__hdr.html">ip_hdr</a> *iphdr;
00164   u16_t src, dest;
00165 
00166   PERF_START;
00167 
00168 <span class="preprocessor">#ifdef UDP_STATS</span>
00169 <span class="preprocessor"></span>  ++lwip_stats.udp.recv;
00170 <span class="preprocessor">#endif </span><span class="comment">/* UDP_STATS */</span>
00171 
00172   iphdr = p-&gt;<a class="code" href="structpbuf.html#o1">payload</a>;
00173 
00174   <span class="keywordflow">if</span> (<a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(p, -((s16_t)(UDP_HLEN + <a class="code" href="ipv4_2lwip_2ip_8h.html#a11">IPH_HL</a>(iphdr) * 4)))) {
00175     <span class="comment">/* drop short packets */</span>
00176     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"udp_input: short UDP datagram (%u bytes) discarded\n"</span>, p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a>));
00177 <span class="preprocessor">#ifdef UDP_STATS</span>
00178 <span class="preprocessor"></span>    ++lwip_stats.udp.lenerr;
00179     ++lwip_stats.udp.drop;
00180 <span class="preprocessor">#endif </span><span class="comment">/* UDP_STATS */</span>
00181     <a class="code" href="snmp_8h.html#a54">snmp_inc_udpinerrors</a>();
00182     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00183     <span class="keywordflow">goto</span> end;
00184   }
00185 
00186   udphdr = (<span class="keyword">struct </span><a class="code" href="structudp__hdr.html">udp_hdr</a> *)((u8_t *)p-&gt;<a class="code" href="structpbuf.html#o1">payload</a> - <a class="code" href="udp_8h.html#a0">UDP_HLEN</a>);
00187 
00188   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"udp_input: received datagram of length %u\n"</span>, p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a>));
00189 
00190   src = <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(udphdr-&gt;src);
00191   dest = <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(udphdr-&gt;dest);
00192 
00193 <span class="preprocessor">#if UDP_DEBUG</span>
00194 <span class="preprocessor"></span>  udp_debug_print(udphdr);
00195 <span class="preprocessor">#endif </span><span class="comment">/* UDP_DEBUG */</span>
00196 
00197   <span class="comment">/* print the UDP source and destination */</span>
00198   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"udp (%u.%u.%u.%u, %u) &lt;-- (%u.%u.%u.%u, %u)\n"</span>,
00199     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a34">ip4_addr1</a>(&amp;iphdr-&gt;<a class="code" href="structip__hdr.html#o8">dest</a>), <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a35">ip4_addr2</a>(&amp;iphdr-&gt;<a class="code" href="structip__hdr.html#o8">dest</a>),
00200     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a36">ip4_addr3</a>(&amp;iphdr-&gt;<a class="code" href="structip__hdr.html#o8">dest</a>), <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a37">ip4_addr4</a>(&amp;iphdr-&gt;<a class="code" href="structip__hdr.html#o8">dest</a>), <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(udphdr-&gt;dest),
00201     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a34">ip4_addr1</a>(&amp;iphdr-&gt;src), <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a35">ip4_addr2</a>(&amp;iphdr-&gt;src),
00202     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a36">ip4_addr3</a>(&amp;iphdr-&gt;src), <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a37">ip4_addr4</a>(&amp;iphdr-&gt;src), <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(udphdr-&gt;src)));
00203   <span class="comment">/* Iterate through the UDP pcb list for a fully matching pcb */</span>
00204   <span class="keywordflow">for</span>(pcb = udp_pcbs; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;next) {
00205     <span class="comment">/* print the PCB local and remote address */</span>
00206     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"pcb (%u.%u.%u.%u, %u) --- (%u.%u.%u.%u, %u)\n"</span>,
00207       <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a34">ip4_addr1</a>(&amp;pcb-&gt;local_ip), <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a35">ip4_addr2</a>(&amp;pcb-&gt;local_ip),
00208       <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a36">ip4_addr3</a>(&amp;pcb-&gt;local_ip), <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a37">ip4_addr4</a>(&amp;pcb-&gt;local_ip), pcb-&gt;local_port,
00209       <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a34">ip4_addr1</a>(&amp;pcb-&gt;remote_ip), <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a35">ip4_addr2</a>(&amp;pcb-&gt;remote_ip),
00210       <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a36">ip4_addr3</a>(&amp;pcb-&gt;remote_ip), <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a37">ip4_addr4</a>(&amp;pcb-&gt;remote_ip), pcb-&gt;remote_port));
00211 
00212        <span class="comment">/* PCB remote port matches UDP source port? */</span>
00213     <span class="keywordflow">if</span> ((pcb-&gt;remote_port == src) &amp;&amp;
00214        <span class="comment">/* PCB local port matches UDP destination port? */</span>
00215        (pcb-&gt;local_port == dest) &amp;&amp;
00216        <span class="comment">/* accepting from any remote (source) IP address? or... */</span>
00217        (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;pcb-&gt;remote_ip) ||
00218        <span class="comment">/* PCB remote IP address matches UDP source IP address? */</span>
00219         <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(pcb-&gt;remote_ip), &amp;(iphdr-&gt;src))) &amp;&amp;
00220        <span class="comment">/* accepting on any local (netif) IP address? or... */</span>
00221        (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;pcb-&gt;local_ip) ||
00222        <span class="comment">/* PCB local IP address matches UDP destination IP address? */</span>
00223         <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(pcb-&gt;local_ip), &amp;(iphdr-&gt;<a class="code" href="structip__hdr.html#o8">dest</a>)))) {
00224       <span class="keywordflow">break</span>;
00225     }
00226   }
00227   <span class="comment">/* no fully matching pcb found? then look for an unconnected pcb */</span>
00228   <span class="keywordflow">if</span> (pcb == <a class="code" href="def_8h.html#a2">NULL</a>) {
00229     <span class="comment">/* Iterate through the UDP PCB list for a pcb that matches</span>
00230 <span class="comment">       the local address. */</span>
00231     <span class="keywordflow">for</span>(pcb = udp_pcbs; pcb != <a class="code" href="def_8h.html#a2">NULL</a>; pcb = pcb-&gt;next) {
00232       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"pcb (%u.%u.%u.%u, %u) --- (%u.%u.%u.%u, %u)\n"</span>,
00233         <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a34">ip4_addr1</a>(&amp;pcb-&gt;local_ip), <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a35">ip4_addr2</a>(&amp;pcb-&gt;local_ip),
00234         <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a36">ip4_addr3</a>(&amp;pcb-&gt;local_ip), <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a37">ip4_addr4</a>(&amp;pcb-&gt;local_ip), pcb-&gt;local_port,
00235         <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a34">ip4_addr1</a>(&amp;pcb-&gt;remote_ip), <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a35">ip4_addr2</a>(&amp;pcb-&gt;remote_ip),
00236         <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a36">ip4_addr3</a>(&amp;pcb-&gt;remote_ip), <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a37">ip4_addr4</a>(&amp;pcb-&gt;remote_ip), pcb-&gt;remote_port));
00237       <span class="comment">/* unconnected? */</span>
00238       <span class="keywordflow">if</span> (((pcb-&gt;flags &amp; <a class="code" href="udp_8h.html#a3">UDP_FLAGS_CONNECTED</a>) == 0) &amp;&amp;
00239          <span class="comment">/* destination port matches? */</span>
00240         (pcb-&gt;local_port == dest) &amp;&amp;
00241         <span class="comment">/* not bound to a specific (local) interface address? or... */</span>
00242         (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;pcb-&gt;local_ip) ||
00243         <span class="comment">/* ...matching interface address? */</span>
00244         <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(pcb-&gt;local_ip), &amp;(iphdr-&gt;<a class="code" href="structip__hdr.html#o8">dest</a>)))) {
00245          <span class="keywordflow">break</span>;
00246       }
00247     }
00248   }
00249 
00250   <span class="comment">/* Check checksum if this is a match or if it was directed at us. */</span>
00251   <span class="keywordflow">if</span> (pcb != <a class="code" href="def_8h.html#a2">NULL</a>  || <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;inp-&gt;<a class="code" href="structnetif.html#o1">ip_addr</a>, &amp;iphdr-&gt;<a class="code" href="structip__hdr.html#o8">dest</a>))
00252     {
00253     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG | DBG_TRACE, (<span class="stringliteral">"udp_input: calculating checksum\n"</span>));
00254     <a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(p, UDP_HLEN);
00255 <span class="preprocessor">#ifdef IPv6</span>
00256 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (iphdr-&gt;<a class="code" href="structip__hdr.html#o6">nexthdr</a> == <a class="code" href="ipv4_2lwip_2ip_8h.html#a3">IP_PROTO_UDPLITE</a>) {
00257 <span class="preprocessor">#else</span>
00258 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip_8h.html#a17">IPH_PROTO</a>(iphdr) == <a class="code" href="ipv4_2lwip_2ip_8h.html#a3">IP_PROTO_UDPLITE</a>) {
00259 <span class="preprocessor">#endif </span><span class="comment">/* IPv4 */</span>
00260       <span class="comment">/* Do the UDP Lite checksum */</span>
00261       <span class="keywordflow">if</span> (<a class="code" href="inet6_8c.html#a1">inet_chksum_pseudo</a>(p, (<span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *)&amp;(iphdr-&gt;src),
00262          (<span class="keyword">struct</span> ip_addr *)&amp;(iphdr-&gt;<a class="code" href="structip__hdr.html#o8">dest</a>),
00263          IP_PROTO_UDPLITE, <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(udphdr-&gt;len)) != 0) {
00264   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG | 2, (<span class="stringliteral">"udp_input: UDP Lite datagram discarded due to failing checksum\n"</span>));
00265 <span class="preprocessor">#ifdef UDP_STATS</span>
00266 <span class="preprocessor"></span>  ++lwip_stats.udp.chkerr;
00267   ++lwip_stats.udp.drop;
00268 <span class="preprocessor">#endif </span><span class="comment">/* UDP_STATS */</span>
00269   <a class="code" href="snmp_8h.html#a54">snmp_inc_udpinerrors</a>();
00270   <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00271   <span class="keywordflow">goto</span> end;
00272       }
00273     } <span class="keywordflow">else</span> {
00274       <span class="keywordflow">if</span> (udphdr-&gt;chksum != 0) {
00275   <span class="keywordflow">if</span> (<a class="code" href="inet6_8c.html#a1">inet_chksum_pseudo</a>(p, (<span class="keyword">struct</span> ip_addr *)&amp;(iphdr-&gt;src),
00276        (<span class="keyword">struct</span> ip_addr *)&amp;(iphdr-&gt;<a class="code" href="structip__hdr.html#o8">dest</a>),
00277         IP_PROTO_UDP, p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a>) != 0) {
00278     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG | 2, (<span class="stringliteral">"udp_input: UDP datagram discarded due to failing checksum\n"</span>));
00279 
00280 <span class="preprocessor">#ifdef UDP_STATS</span>
00281 <span class="preprocessor"></span>    ++lwip_stats.udp.chkerr;
00282     ++lwip_stats.udp.drop;
00283 <span class="preprocessor">#endif </span><span class="comment">/* UDP_STATS */</span>
00284     <a class="code" href="snmp_8h.html#a54">snmp_inc_udpinerrors</a>();
00285     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00286     <span class="keywordflow">goto</span> end;
00287   }
00288       }
00289     }
00290     <a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(p, -UDP_HLEN);
00291     <span class="keywordflow">if</span> (pcb != <a class="code" href="def_8h.html#a2">NULL</a>) {
00292       <a class="code" href="snmp_8h.html#a52">snmp_inc_udpindatagrams</a>();
00293       pcb-&gt;recv(pcb-&gt;recv_arg, pcb, p, &amp;(iphdr-&gt;src), src);
00294     } <span class="keywordflow">else</span> {
00295       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG | DBG_TRACE, (<span class="stringliteral">"udp_input: not for us.\n"</span>));
00296 
00297       <span class="comment">/* No match was found, send ICMP destination port unreachable unless</span>
00298 <span class="comment">   destination address was broadcast/multicast. */</span>
00299 
00300       <span class="keywordflow">if</span> (!<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a31">ip_addr_isbroadcast</a>(&amp;iphdr-&gt;<a class="code" href="structip__hdr.html#o8">dest</a>, &amp;inp-&gt;<a class="code" href="structnetif.html#o2">netmask</a>) &amp;&amp;
00301    !<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a32">ip_addr_ismulticast</a>(&amp;iphdr-&gt;<a class="code" href="structip__hdr.html#o8">dest</a>)) {
00302 
00303   <span class="comment">/* adjust pbuf pointer */</span>
00304   p-&gt;<a class="code" href="structpbuf.html#o1">payload</a> = iphdr;
00305   <a class="code" href="icmp_8c.html#a1">icmp_dest_unreach</a>(p, ICMP_DUR_PORT);
00306       }
00307 <span class="preprocessor">#ifdef UDP_STATS</span>
00308 <span class="preprocessor"></span>      ++lwip_stats.udp.proterr;
00309       ++lwip_stats.udp.drop;
00310 <span class="preprocessor">#endif </span><span class="comment">/* UDP_STATS */</span>
00311     <a class="code" href="snmp_8h.html#a53">snmp_inc_udpnoports</a>();
00312       <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00313     }
00314   } <span class="keywordflow">else</span> {
00315     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00316   }
00317   end:
00318 
00319   PERF_STOP(<span class="stringliteral">"udp_input"</span>);
00320 }
00335 <a class="code" href="err_8h.html#a13">err_t</a>
00336 <a class="code" href="udp_8h.html#a13">udp_send</a>(<span class="keyword">struct</span> <a class="code" href="structudp__pcb.html">udp_pcb</a> *pcb, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p)
00337 {
00338   <span class="keyword">struct </span><a class="code" href="structudp__hdr.html">udp_hdr</a> *udphdr;
00339   <span class="keyword">struct </span><a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>;
00340   <span class="keyword">struct </span>ip_addr *src_ip;
00341   <a class="code" href="err_8h.html#a13">err_t</a> err;
00342   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *q; <span class="comment">/* q will be sent down the stack */</span>
00343 
00344   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG | DBG_TRACE | 3, (<span class="stringliteral">"udp_send\n"</span>));
00345 
00346   <span class="comment">/* if the PCB is not yet bound to a port, bind it here */</span>
00347   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structudp__pcb.html#o2">local_port</a> == 0) {
00348     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG | DBG_TRACE | 2, (<span class="stringliteral">"udp_send: not yet bound to a port, binding now\n"</span>));
00349     err = <a class="code" href="udp_8h.html#a9">udp_bind</a>(pcb, &amp;pcb-&gt;local_ip, pcb-&gt;<a class="code" href="structudp__pcb.html#o2">local_port</a>);
00350     <span class="keywordflow">if</span> (err != <a class="code" href="err_8h.html#a0">ERR_OK</a>) {
00351       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG | DBG_TRACE | 2, (<span class="stringliteral">"udp_send: forced port bind failed\n"</span>));
00352       <span class="keywordflow">return</span> err;
00353     }
00354   }
00355 
00356   <span class="comment">/* not enough space to add an UDP header to first pbuf in given p chain? */</span>
00357   <span class="keywordflow">if</span> (<a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(p, UDP_HLEN)) {
00358     <span class="comment">/* allocate header in new pbuf */</span>
00359     q = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(PBUF_IP, UDP_HLEN, PBUF_RAM);
00360     <span class="comment">/* new header pbuf could not be allocated? */</span>
00361     <span class="keywordflow">if</span> (q == <a class="code" href="def_8h.html#a2">NULL</a>) {
00362       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG | DBG_TRACE | 2, (<span class="stringliteral">"udp_send: could not allocate header\n"</span>));
00363       <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a1">ERR_MEM</a>;
00364     }
00365     <span class="comment">/* chain header q in front of given pbuf p */</span>
00366     <a class="code" href="pbuf_8c.html#a17">pbuf_chain</a>(q, p);
00367     <span class="comment">/* { first pbuf q points to header pbuf } */</span>
00368     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"udp_send: added header pbuf %p before given pbuf %p\n"</span>, (<span class="keywordtype">void</span> *)q, (<span class="keywordtype">void</span> *)p));
00369   <span class="comment">/* adding a header within p succeeded */</span>
00370   }  <span class="keywordflow">else</span> {
00371     <span class="comment">/* first pbuf q equals given pbuf */</span>
00372     q = p;
00373     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"udp_send: added header in given pbuf %p\n"</span>, (<span class="keywordtype">void</span> *)p));
00374   }
00375 
00376   udphdr = q-&gt;payload;
00377   udphdr-&gt;src = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(pcb-&gt;<a class="code" href="structudp__pcb.html#o2">local_port</a>);
00378   udphdr-&gt;dest = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(pcb-&gt;<a class="code" href="structudp__pcb.html#o3">remote_port</a>);
00379   udphdr-&gt;chksum = 0x0000;
00380 
00381   <span class="keywordflow">if</span> ((<a class="code" href="structnetif.html">netif</a> = <a class="code" href="ip_8c.html#a1">ip_route</a>(&amp;(pcb-&gt;<a class="code" href="structudp__pcb.html#o1">remote_ip</a>))) == <a class="code" href="def_8h.html#a2">NULL</a>) {
00382     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG | 1, (<span class="stringliteral">"udp_send: No route to 0x%lx\n"</span>, pcb-&gt;<a class="code" href="structudp__pcb.html#o1">remote_ip</a>.<a class="code" href="structip__addr.html#o0">addr</a>));
00383 <span class="preprocessor">#ifdef UDP_STATS</span>
00384 <span class="preprocessor"></span>    ++lwip_stats.udp.rterr;
00385 <span class="preprocessor">#endif </span><span class="comment">/* UDP_STATS */</span>
00386     <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a9">ERR_RTE</a>;
00387   }
00388   <span class="comment">/* using IP_ANY_ADDR? */</span>
00389   <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;pcb-&gt;local_ip)) {
00390     <span class="comment">/* use outgoing network interface IP address as source address */</span>
00391     src_ip = &amp;(<a class="code" href="structnetif.html">netif</a>-&gt;ip_addr);
00392   } <span class="keywordflow">else</span> {
00393     <span class="comment">/* use UDP PCB local IP address as source address */</span>
00394     src_ip = &amp;(pcb-&gt;local_ip);
00395   }
00396 
00397   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"udp_send: sending datagram of length %u\n"</span>, q-&gt;tot_len));
00398 
00399   <span class="comment">/* UDP Lite protocol? */</span>
00400   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structudp__pcb.html#o4">flags</a> &amp; <a class="code" href="udp_8h.html#a2">UDP_FLAGS_UDPLITE</a>) {
00401     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"udp_send: UDP LITE packet length %u\n"</span>, q-&gt;tot_len));
00402     <span class="comment">/* set UDP message length in UDP header */</span>
00403     udphdr-&gt;len = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(pcb-&gt;<a class="code" href="structudp__pcb.html#o5">chksum_len</a>);
00404     <span class="comment">/* calculate checksum */</span>
00405     udphdr-&gt;chksum = <a class="code" href="inet6_8c.html#a1">inet_chksum_pseudo</a>(q, src_ip, &amp;(pcb-&gt;<a class="code" href="structudp__pcb.html#o1">remote_ip</a>),
00406           IP_PROTO_UDP, pcb-&gt;<a class="code" href="structudp__pcb.html#o5">chksum_len</a>);
00407     <span class="comment">/* chksum zero must become 0xffff, as zero means 'no checksum' */</span>
00408     <span class="keywordflow">if</span> (udphdr-&gt;chksum == 0x0000) udphdr-&gt;chksum = 0xffff;
00409     <span class="comment">/* output to IP */</span>
00410     err = <a class="code" href="ipv6_2lwip_2ip_8h.html#a10">ip_output_if</a> (q, src_ip, &amp;pcb-&gt;<a class="code" href="structudp__pcb.html#o1">remote_ip</a>, UDP_TTL, IP_PROTO_UDPLITE, <a class="code" href="structnetif.html">netif</a>);
00411     <a class="code" href="snmp_8h.html#a55">snmp_inc_udpoutdatagrams</a>();
00412   } <span class="keywordflow">else</span> {
00413     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"udp_send: UDP packet length %u\n"</span>, q-&gt;tot_len));
00414     udphdr-&gt;len = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(q-&gt;tot_len);
00415     <span class="comment">/* calculate checksum */</span>
00416     <span class="keywordflow">if</span> ((pcb-&gt;<a class="code" href="structudp__pcb.html#o4">flags</a> &amp; <a class="code" href="udp_8h.html#a1">UDP_FLAGS_NOCHKSUM</a>) == 0) {
00417       udphdr-&gt;chksum = <a class="code" href="inet6_8c.html#a1">inet_chksum_pseudo</a>(q, src_ip, &amp;pcb-&gt;<a class="code" href="structudp__pcb.html#o1">remote_ip</a>, IP_PROTO_UDP, q-&gt;tot_len);
00418       <span class="comment">/* chksum zero must become 0xffff, as zero means 'no checksum' */</span>
00419       <span class="keywordflow">if</span> (udphdr-&gt;chksum == 0x0000) udphdr-&gt;chksum = 0xffff;
00420     }
00421     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"udp_send: UDP checksum 0x%04x\n"</span>, udphdr-&gt;chksum));
00422     <a class="code" href="snmp_8h.html#a55">snmp_inc_udpoutdatagrams</a>();
00423     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"</span>));
00424     <span class="comment">/* output to IP */</span>
00425     err = <a class="code" href="ipv6_2lwip_2ip_8h.html#a10">ip_output_if</a> (q, src_ip, &amp;pcb-&gt;<a class="code" href="structudp__pcb.html#o1">remote_ip</a>, UDP_TTL, IP_PROTO_UDP, <a class="code" href="structnetif.html">netif</a>);
00426   }
00427 
00428   <span class="comment">/* did we chain a header earlier? */</span>
00429   <span class="keywordflow">if</span> (q != p) {
00430     <span class="comment">/* free the header */</span>
00431     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(q);
00432   }
00433 
00434 <span class="preprocessor">#ifdef UDP_STATS</span>
00435 <span class="preprocessor"></span>  ++lwip_stats.udp.xmit;
00436 <span class="preprocessor">#endif </span><span class="comment">/* UDP_STATS */</span>
00437   <span class="keywordflow">return</span> err;
00438 }
00439 
00455 <a class="code" href="err_8h.html#a13">err_t</a>
00456 <a class="code" href="udp_8h.html#a9">udp_bind</a>(<span class="keyword">struct</span> <a class="code" href="structudp__pcb.html">udp_pcb</a> *pcb, <span class="keyword">struct</span> ip_addr *ipaddr, u16_t port)
00457 {
00458   <span class="keyword">struct </span><a class="code" href="structudp__pcb.html">udp_pcb</a> *ipcb;
00459   u8_t rebind;
00460   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG | DBG_TRACE | 3, (<span class="stringliteral">"udp_bind(ipaddr = "</span>));
00461   <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a33">ip_addr_debug_print</a>(UDP_DEBUG, ipaddr);
00462   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG | DBG_TRACE | 3, (<span class="stringliteral">", port = %u)\n"</span>, port));
00463   rebind = 0;
00464   <span class="comment">/* Check for double bind and rebind of the same pcb */</span>
00465   <span class="keywordflow">for</span> (ipcb = udp_pcbs; ipcb != <a class="code" href="def_8h.html#a2">NULL</a>; ipcb = ipcb-&gt;next) {
00466     <span class="comment">/* is this UDP PCB already on active list? */</span>
00467     <span class="keywordflow">if</span> (pcb == ipcb) {
00468       <span class="comment">/* pcb may occur at most once in active list */</span>
00469       <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"rebind == 0"</span>, rebind == 0);
00470       <span class="comment">/* pcb already in list, just rebind */</span>
00471       rebind = 1;
00472     }
00473 <span class="comment">/* this code does not allow upper layer to share a UDP port for</span>
00474 <span class="comment">   listening to broadcast or multicast traffic (See SO_REUSE_ADDR and</span>
00475 <span class="comment">   SO_REUSE_PORT under *BSD). TODO: See where it fits instead, OR</span>
00476 <span class="comment">   combine with implementation of UDP PCB flags. Leon Woestenberg. */</span>
00477 <span class="preprocessor">#if 0</span>
00478 <span class="preprocessor"></span>    <span class="comment">/* port matches that of PCB in list? */</span>
00479     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((ipcb-&gt;local_port == port) &amp;&amp;
00480        <span class="comment">/* IP address matches, or one is IP_ADDR_ANY? */</span>
00481        (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;(ipcb-&gt;local_ip)) ||
00482        <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(ipaddr) ||
00483        <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a29">ip_addr_cmp</a>(&amp;(ipcb-&gt;local_ip), ipaddr))) {
00484       <span class="comment">/* other PCB already binds to this local IP and port */</span>
00485       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"udp_bind: local port %u already bound by another pcb\n"</span>, port));
00486       <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a10">ERR_USE</a>;
00487     }
00488 <span class="preprocessor">#endif</span>
00489 <span class="preprocessor"></span>  }
00490   <span class="comment">/* bind local address */</span>
00491   <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a27">ip_addr_set</a>(&amp;pcb-&gt;local_ip, ipaddr);
00492   <span class="comment">/* no port specified? */</span>
00493   <span class="keywordflow">if</span> (port == 0) {
00494 <span class="preprocessor">#ifndef UDP_LOCAL_PORT_RANGE_START</span>
00495 <span class="preprocessor"></span><span class="preprocessor">#define UDP_LOCAL_PORT_RANGE_START 4096</span>
00496 <span class="preprocessor"></span><span class="preprocessor">#define UDP_LOCAL_PORT_RANGE_END   0x7fff</span>
00497 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00498 <span class="preprocessor"></span>    port = UDP_LOCAL_PORT_RANGE_START;
00499     ipcb = udp_pcbs;
00500     <span class="keywordflow">while</span> ((ipcb != <a class="code" href="def_8h.html#a2">NULL</a>) &amp;&amp; (port != UDP_LOCAL_PORT_RANGE_END)) {
00501       <span class="keywordflow">if</span> (ipcb-&gt;local_port == port) {
00502         port++;
00503         ipcb = udp_pcbs;
00504       } <span class="keywordflow">else</span>
00505         ipcb = ipcb-&gt;next;
00506     }
00507     <span class="keywordflow">if</span> (ipcb != <a class="code" href="def_8h.html#a2">NULL</a>) {
00508       <span class="comment">/* no more ports available in local range */</span>
00509       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"udp_bind: out of free UDP ports\n"</span>));
00510       <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a10">ERR_USE</a>;
00511     }
00512   }
00513   pcb-&gt;<a class="code" href="structudp__pcb.html#o2">local_port</a> = port;
00514   <span class="comment">/* pcb not active yet? */</span>
00515   <span class="keywordflow">if</span> (rebind == 0) {
00516     <span class="comment">/* place the PCB on the active list if not already there */</span>
00517     pcb-&gt;<a class="code" href="structudp__pcb.html#o0">next</a> = udp_pcbs;
00518     udp_pcbs = pcb;
00519   }
00520   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG | DBG_TRACE | DBG_STATE, (<span class="stringliteral">"udp_bind: bound to %u.%u.%u.%u, port %u\n"</span>,
00521    (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(<a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;local_ip.addr) &gt;&gt; 24 &amp; 0xff),
00522    (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(<a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;local_ip.addr) &gt;&gt; 16 &amp; 0xff),
00523    (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(<a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;local_ip.addr) &gt;&gt; 8 &amp; 0xff),
00524    (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(<a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;local_ip.addr) &amp; 0xff), pcb-&gt;<a class="code" href="structudp__pcb.html#o2">local_port</a>));
00525   <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00526 }
00540 <a class="code" href="err_8h.html#a13">err_t</a>
00541 <a class="code" href="udp_8h.html#a10">udp_connect</a>(<span class="keyword">struct</span> <a class="code" href="structudp__pcb.html">udp_pcb</a> *pcb, <span class="keyword">struct</span> ip_addr *ipaddr, u16_t port)
00542 {
00543   <span class="keyword">struct </span><a class="code" href="structudp__pcb.html">udp_pcb</a> *ipcb;
00544 
00545   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structudp__pcb.html#o2">local_port</a> == 0) {
00546     <a class="code" href="err_8h.html#a13">err_t</a> err = <a class="code" href="udp_8h.html#a9">udp_bind</a>(pcb, &amp;pcb-&gt;local_ip, pcb-&gt;<a class="code" href="structudp__pcb.html#o2">local_port</a>);
00547     <span class="keywordflow">if</span> (err != <a class="code" href="err_8h.html#a0">ERR_OK</a>)
00548       <span class="keywordflow">return</span> err;
00549   }
00550 
00551   <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a27">ip_addr_set</a>(&amp;pcb-&gt;<a class="code" href="structudp__pcb.html#o1">remote_ip</a>, ipaddr);
00552   pcb-&gt;<a class="code" href="structudp__pcb.html#o3">remote_port</a> = port;
00553   pcb-&gt;<a class="code" href="structudp__pcb.html#o4">flags</a> |= <a class="code" href="udp_8h.html#a3">UDP_FLAGS_CONNECTED</a>;
00555 <span class="preprocessor">#if 0</span>
00556 <span class="preprocessor"></span>  <span class="comment">/* Nail down local IP for netconn_addr()/getsockname() */</span>
00557   <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;pcb-&gt;local_ip) &amp;&amp; !<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;pcb-&gt;<a class="code" href="structudp__pcb.html#o1">remote_ip</a>)) {
00558     <span class="keyword">struct </span><a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>;
00559 
00560     <span class="keywordflow">if</span> ((<a class="code" href="structnetif.html">netif</a> = <a class="code" href="ip_8c.html#a1">ip_route</a>(&amp;(pcb-&gt;<a class="code" href="structudp__pcb.html#o1">remote_ip</a>))) == <a class="code" href="def_8h.html#a2">NULL</a>) {
00561       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"udp_connect: No route to 0x%lx\n"</span>, pcb-&gt;<a class="code" href="structudp__pcb.html#o1">remote_ip</a>.<a class="code" href="structip__addr.html#o0">addr</a>));
00562 <span class="preprocessor">#ifdef UDP_STATS</span>
00563 <span class="preprocessor"></span>        ++lwip_stats.udp.rterr;
00564 <span class="preprocessor">#endif </span><span class="comment">/* UDP_STATS */</span>
00565       <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a9">ERR_RTE</a>;
00566     }
00570     pcb-&gt;local_ip = <a class="code" href="structnetif.html">netif</a>-&gt;ip_addr;
00571   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;pcb-&gt;<a class="code" href="structudp__pcb.html#o1">remote_ip</a>)) {
00572     pcb-&gt;local_ip.addr = 0;
00573   }
00574 <span class="preprocessor">#endif</span>
00575 <span class="preprocessor"></span>  <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG | DBG_TRACE | DBG_STATE, (<span class="stringliteral">"udp_connect: connected to %u.%u.%u.%u, port %u\n"</span>,
00576    (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(<a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structudp__pcb.html#o1">remote_ip</a>.<a class="code" href="structip__addr.html#o0">addr</a>) &gt;&gt; 24 &amp; 0xff),
00577    (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(<a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structudp__pcb.html#o1">remote_ip</a>.<a class="code" href="structip__addr.html#o0">addr</a>) &gt;&gt; 16 &amp; 0xff),
00578    (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(<a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structudp__pcb.html#o1">remote_ip</a>.<a class="code" href="structip__addr.html#o0">addr</a>) &gt;&gt; 8 &amp; 0xff),
00579    (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(<a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structudp__pcb.html#o1">remote_ip</a>.<a class="code" href="structip__addr.html#o0">addr</a>) &amp; 0xff), pcb-&gt;<a class="code" href="structudp__pcb.html#o3">remote_port</a>));
00580 
00581   <span class="comment">/* Insert UDP PCB into the list of active UDP PCBs. */</span>
00582   <span class="keywordflow">for</span>(ipcb = udp_pcbs; ipcb != <a class="code" href="def_8h.html#a2">NULL</a>; ipcb = ipcb-&gt;next) {
00583     <span class="keywordflow">if</span> (pcb == ipcb) {
00584       <span class="comment">/* already on the list, just return */</span>
00585       <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00586     }
00587   }
00588   <span class="comment">/* PCB not yet on the list, add PCB now */</span>
00589   pcb-&gt;<a class="code" href="structudp__pcb.html#o0">next</a> = udp_pcbs;
00590   udp_pcbs = pcb;
00591   <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00592 }
00593 
00594 <span class="keywordtype">void</span>
00595 <a class="code" href="udp_8h.html#a11">udp_disconnect</a>(<span class="keyword">struct</span> <a class="code" href="structudp__pcb.html">udp_pcb</a> *pcb)
00596 {
00597   pcb-&gt;<a class="code" href="structudp__pcb.html#o4">flags</a> &amp;= ~<a class="code" href="udp_8h.html#a3">UDP_FLAGS_CONNECTED</a>;
00598 }
00599 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00600 <span class="keywordtype">void</span>
00601 <a class="code" href="udp_8h.html#a12">udp_recv</a>(<span class="keyword">struct</span> <a class="code" href="structudp__pcb.html">udp_pcb</a> *pcb,
00602    <span class="keywordtype">void</span> (* recv)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structudp__pcb.html">udp_pcb</a> *upcb, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p,
00603            <span class="keyword">struct</span> ip_addr *addr, u16_t port),
00604    <span class="keywordtype">void</span> *recv_arg)
00605 {
00606   <span class="comment">/* remember recv() callback and user data */</span>
00607   pcb-&gt;<a class="code" href="structudp__pcb.html#o6">recv</a> = recv;
00608   pcb-&gt;<a class="code" href="structudp__pcb.html#o7">recv_arg</a> = recv_arg;
00609 }
00618 <span class="keywordtype">void</span>
00619 <a class="code" href="udp_8h.html#a8">udp_remove</a>(<span class="keyword">struct</span> <a class="code" href="structudp__pcb.html">udp_pcb</a> *pcb)
00620 {
00621   <span class="keyword">struct </span><a class="code" href="structudp__pcb.html">udp_pcb</a> *pcb2;
00622   <span class="comment">/* pcb to be removed is first in list? */</span>
00623   <span class="keywordflow">if</span> (udp_pcbs == pcb) {
00624     <span class="comment">/* make list start at 2nd pcb */</span>
00625     udp_pcbs = udp_pcbs-&gt;next;
00626   <span class="comment">/* pcb not 1st in list */</span>
00627   } <span class="keywordflow">else</span> <span class="keywordflow">for</span>(pcb2 = udp_pcbs; pcb2 != <a class="code" href="def_8h.html#a2">NULL</a>; pcb2 = pcb2-&gt;next) {
00628     <span class="comment">/* find pcb in udp_pcbs list */</span>
00629     <span class="keywordflow">if</span> (pcb2-&gt;next != <a class="code" href="def_8h.html#a2">NULL</a> &amp;&amp; pcb2-&gt;next == pcb) {
00630       <span class="comment">/* remove pcb from list */</span>
00631       pcb2-&gt;next = pcb-&gt;<a class="code" href="structudp__pcb.html#o0">next</a>;
00632     }
00633   }
00634   <a class="code" href="memp_8c.html#a8">memp_free</a>(MEMP_UDP_PCB, pcb);
00635 }
00644 <span class="keyword">struct </span><a class="code" href="structudp__pcb.html">udp_pcb</a> *
00645 <a class="code" href="udp_8h.html#a7">udp_new</a>(<span class="keywordtype">void</span>) {
00646   <span class="keyword">struct </span><a class="code" href="structudp__pcb.html">udp_pcb</a> *pcb;
00647   pcb = <a class="code" href="memp_8c.html#a6">memp_malloc</a>(MEMP_UDP_PCB);
00648   <span class="comment">/* could allocate UDP PCB? */</span>
00649   <span class="keywordflow">if</span> (pcb != <a class="code" href="def_8h.html#a2">NULL</a>) {
00650     <span class="comment">/* initialize PCB to all zeroes */</span>
00651     memset(pcb, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structudp__pcb.html">udp_pcb</a>));
00652   }
00653   <span class="keywordflow">return</span> pcb;
00654 }
00655 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00656 <span class="preprocessor">#if UDP_DEBUG</span>
00657 <span class="preprocessor"></span><span class="keywordtype">int</span>
00658 udp_debug_print(<span class="keyword">struct</span> <a class="code" href="structudp__hdr.html">udp_hdr</a> *udphdr)
00659 {
00660   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"UDP header:\n"</span>));
00661   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"+-------------------------------+\n"</span>));
00662   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"|     %5u     |     %5u     | (src port, dest port)\n"</span>,
00663          <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(udphdr-&gt;src), <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(udphdr-&gt;dest)));
00664   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"+-------------------------------+\n"</span>));
00665   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"|     %5u     |     0x%04x    | (len, chksum)\n"</span>,
00666          <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(udphdr-&gt;len), <a class="code" href="ipv4_2lwip_2inet_8h.html#a1">ntohs</a>(udphdr-&gt;chksum)));
00667   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(UDP_DEBUG, (<span class="stringliteral">"+-------------------------------+\n"</span>));
00668   <span class="keywordflow">return</span> 0;
00669 }
00670 <span class="preprocessor">#endif </span><span class="comment">/* UDP_DEBUG */</span>
00671 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00672 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_UDP */</span>
00673 
00674 
00675 
00676 
00677 
00678 
00679 
00680 
00681 
</pre></div>	</td>
  </tr>
</table>
<hr>
<div align="center">Copyright (c) 2001-2003 Swedish Institute of Computer Science</div>
</html>
