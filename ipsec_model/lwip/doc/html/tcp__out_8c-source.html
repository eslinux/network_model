
<html>
<head>
<title>lwIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="doxygen.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<table width="98%" border="0" align="center">
  <tr>
    <td>
      <h2>lwIP code documentation</h2>
<hr>

<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>tcp_out.c</h1><a href="tcp__out_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00006 <span class="comment">/*</span>
00007 <span class="comment"> * Copyright (c) 2001-2003 Swedish Institute of Computer Science.</span>
00008 <span class="comment"> * All rights reserved.</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> * Redistribution and use in source and binary forms, with or without modification,</span>
00011 <span class="comment"> * are permitted provided that the following conditions are met:</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span>
00014 <span class="comment"> *    this list of conditions and the following disclaimer.</span>
00015 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
00016 <span class="comment"> *    this list of conditions and the following disclaimer in the documentation</span>
00017 <span class="comment"> *    and/or other materials provided with the distribution.</span>
00018 <span class="comment"> * 3. The name of the author may not be used to endorse or promote products</span>
00019 <span class="comment"> *    derived from this software without specific prior written permission.</span>
00020 <span class="comment"> *</span>
00021 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED</span>
00022 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
00023 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT</span>
00024 <span class="comment"> * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
00025 <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT</span>
00026 <span class="comment"> * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
00027 <span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
00028 <span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
00029 <span class="comment"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY</span>
00030 <span class="comment"> * OF SUCH DAMAGE.</span>
00031 <span class="comment"> *</span>
00032 <span class="comment"> * This file is part of the lwIP TCP/IP stack.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Author: Adam Dunkels &lt;adam@sics.se&gt;</span>
00035 <span class="comment"> *</span>
00036 <span class="comment"> */</span>
00037 
00038 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00039 <span class="comment">/* tcp_output.c</span>
00040 <span class="comment"> *</span>
00041 <span class="comment"> * The output functions of TCP.</span>
00042 <span class="comment"> *</span>
00043 <span class="comment"> */</span>
00044 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00045 
00046 
00047 <span class="preprocessor">#include "<a class="code" href="def_8h.html">lwip/def.h</a>"</span>
00048 <span class="preprocessor">#include "<a class="code" href="opt_8h.html">lwip/opt.h</a>"</span>
00049 
00050 <span class="preprocessor">#include "<a class="code" href="mem_8h.html">lwip/mem.h</a>"</span>
00051 <span class="preprocessor">#include "<a class="code" href="memp_8h.html">lwip/memp.h</a>"</span>
00052 <span class="preprocessor">#include "<a class="code" href="sys_8h.html">lwip/sys.h</a>"</span>
00053 
00054 <span class="preprocessor">#include "<a class="code" href="netif_8h.html">lwip/netif.h</a>"</span>
00055 
00056 <span class="preprocessor">#include "lwip/inet.h"</span>
00057 <span class="preprocessor">#include "<a class="code" href="tcp_8h.html">lwip/tcp.h</a>"</span>
00058 
00059 <span class="preprocessor">#include "<a class="code" href="stats_8h.html">lwip/stats.h</a>"</span>
00060 
00061 <span class="preprocessor">#if LWIP_TCP</span>
00062 <span class="preprocessor"></span>
00063 <span class="comment">/* Forward declarations.*/</span>
00064 <span class="keyword">static</span> <span class="keywordtype">void</span> tcp_output_segment(<span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a> *seg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
00065 
00066 
00067 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00068 <a class="code" href="err_8h.html#a13">err_t</a>
00069 <a class="code" href="tcp_8h.html#a93">tcp_send_ctrl</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t flags)
00070 {
00071   <span class="keywordflow">return</span> <a class="code" href="tcp_8h.html#a94">tcp_enqueue</a>(pcb, NULL, 0, flags, 1, NULL, 0);
00072 
00073 }
00074 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00075 <a class="code" href="err_8h.html#a13">err_t</a>
00076 <a class="code" href="tcp_8h.html#a80">tcp_write</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">const</span> <span class="keywordtype">void</span> *arg, u16_t len, u8_t copy)
00077 {
00078   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG, (<span class="stringliteral">"tcp_write(pcb=%p, arg=%p, len=%u, copy=%d)\n"</span>, (<span class="keywordtype">void</span> *)pcb,
00079     arg, len, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)copy));
00080   <span class="keywordflow">if</span> (pcb-&gt;state == <a class="code" href="tcp_8h.html#a99a55">SYN_SENT</a> ||
00081      pcb-&gt;state == <a class="code" href="tcp_8h.html#a99a56">SYN_RCVD</a> ||
00082      pcb-&gt;state == <a class="code" href="tcp_8h.html#a99a57">ESTABLISHED</a> ||
00083      pcb-&gt;state == <a class="code" href="tcp_8h.html#a99a60">CLOSE_WAIT</a>) {
00084     <span class="keywordflow">if</span> (len &gt; 0) {
00085       <span class="keywordflow">return</span> <a class="code" href="tcp_8h.html#a94">tcp_enqueue</a>(pcb, (<span class="keywordtype">void</span> *)arg, len, 0, copy, NULL, 0);
00086     }
00087     <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00088   } <span class="keywordflow">else</span> {
00089     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG | DBG_STATE | 3, (<span class="stringliteral">"tcp_write() called in invalid state\n"</span>));
00090     <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a6">ERR_CONN</a>;
00091   }
00092 }
00093 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00094 <a class="code" href="err_8h.html#a13">err_t</a>
00095 <a class="code" href="tcp_8h.html#a94">tcp_enqueue</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keywordtype">void</span> *arg, u16_t len,
00096       u8_t flags, u8_t copy,
00097             u8_t *optdata, u8_t optlen)
00098 {
00099   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p;
00100   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *seg, *useg, *queue;
00101   u32_t left, seqno;
00102   u16_t seglen;
00103   <span class="keywordtype">void</span> *ptr;
00104   u8_t queuelen;
00105 
00106   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG, (<span class="stringliteral">"tcp_enqueue(pcb=%p, arg=%p, len=%u, flags=%x, copy=%u)\n"</span>,
00107     (<span class="keywordtype">void</span> *)pcb, arg, len, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)flags, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)copy));
00108   left = len;
00109   ptr = arg;
00110   <span class="comment">/* fail on too much data */</span>
00111   <span class="keywordflow">if</span> (len &gt; pcb-&gt;snd_buf) {
00112     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG | 3, (<span class="stringliteral">"tcp_enqueue: too much data (len=%u &gt; snd_buf=%u)\n"</span>, len, pcb-&gt;snd_buf));
00113     <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a1">ERR_MEM</a>;
00114   }
00115 
00116   <span class="comment">/* seqno will be the sequence number of the first segment enqueued</span>
00117 <span class="comment">   * by the call to this function. */</span>
00118   seqno = pcb-&gt;snd_lbb;
00119 
00120   queue = <a class="code" href="def_8h.html#a2">NULL</a>;
00121   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_QLEN_DEBUG, (<span class="stringliteral">"tcp_enqueue: queuelen: %u\n"</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)pcb-&gt;snd_queuelen));
00122 
00123   <span class="comment">/* Check if the queue length exceeds the configured maximum queue</span>
00124 <span class="comment">   * length. If so, we return an error. */</span>
00125   queuelen = pcb-&gt;snd_queuelen;
00126   <span class="keywordflow">if</span> (queuelen &gt;= <a class="code" href="opt_8h.html#a38">TCP_SND_QUEUELEN</a>) {
00127     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG | 3, (<span class="stringliteral">"tcp_enqueue: too long queue %u (max %u)\n"</span>, queuelen, TCP_SND_QUEUELEN));
00128     <span class="keywordflow">goto</span> memerr;
00129   }
00130 
00131   <span class="keywordflow">if</span> (pcb-&gt;snd_queuelen != 0) {
00132     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_enqueue: valid queue length"</span>, pcb-&gt;unacked != NULL ||
00133     pcb-&gt;unsent != NULL);
00134   }
00135 
00136   seg = <a class="code" href="def_8h.html#a2">NULL</a>;
00137   seglen = 0;
00138 
00139   <span class="comment">/* First, break up the data into segments and tuck them together in</span>
00140 <span class="comment">   * the local "queue" variable. */</span>
00141   <span class="keywordflow">while</span> (queue == <a class="code" href="def_8h.html#a2">NULL</a> || left &gt; 0) {
00142 
00143     <span class="comment">/* The segment length should be the MSS if the data to be enqueued</span>
00144 <span class="comment">     * is larger than the MSS. */</span>
00145     seglen = left &gt; pcb-&gt;mss? pcb-&gt;mss: left;
00146 
00147     <span class="comment">/* Allocate memory for tcp_seg, and fill in fields. */</span>
00148     seg = <a class="code" href="memp_8c.html#a6">memp_malloc</a>(MEMP_TCP_SEG);
00149     <span class="keywordflow">if</span> (seg == <a class="code" href="def_8h.html#a2">NULL</a>) {
00150       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG | 2, (<span class="stringliteral">"tcp_enqueue: could not allocate memory for tcp_seg\n"</span>));
00151       <span class="keywordflow">goto</span> memerr;
00152     }
00153     seg-&gt;next = <a class="code" href="def_8h.html#a2">NULL</a>;
00154     seg-&gt;p = <a class="code" href="def_8h.html#a2">NULL</a>;
00155 
00156     <span class="keywordflow">if</span> (queue == <a class="code" href="def_8h.html#a2">NULL</a>) {
00157       queue = seg;
00158     }
00159     <span class="keywordflow">else</span> {
00160       <span class="comment">/* Attach the segment to the end of the queued segments. */</span>
00161       <span class="keywordflow">for</span> (useg = queue; useg-&gt;next != <a class="code" href="def_8h.html#a2">NULL</a>; useg = useg-&gt;next);
00162       useg-&gt;next = seg;
00163     }
00164 
00165     <span class="comment">/* If copy is set, memory should be allocated</span>
00166 <span class="comment">     * and data copied into pbuf, otherwise data comes from</span>
00167 <span class="comment">     * ROM or other static memory, and need not be copied. If</span>
00168 <span class="comment">     * optdata is != NULL, we have options instead of data. */</span>
00169     <span class="keywordflow">if</span> (optdata != <a class="code" href="def_8h.html#a2">NULL</a>) {
00170       <span class="keywordflow">if</span> ((seg-&gt;p = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(PBUF_TRANSPORT, optlen, PBUF_RAM)) == <a class="code" href="def_8h.html#a2">NULL</a>) {
00171         <span class="keywordflow">goto</span> memerr;
00172       }
00173       ++queuelen;
00174       seg-&gt;dataptr = seg-&gt;p-&gt;payload;
00175     }
00176     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (copy) {
00177       <span class="keywordflow">if</span> ((seg-&gt;p = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(PBUF_TRANSPORT, seglen, PBUF_RAM)) == <a class="code" href="def_8h.html#a2">NULL</a>) {
00178         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG | 2, (<span class="stringliteral">"tcp_enqueue : could not allocate memory for pbuf copy size %u\n"</span>, seglen));
00179         <span class="keywordflow">goto</span> memerr;
00180       }
00181       ++queuelen;
00182       <span class="keywordflow">if</span> (arg != <a class="code" href="def_8h.html#a2">NULL</a>) {
00183         memcpy(seg-&gt;p-&gt;payload, ptr, seglen);
00184       }
00185       seg-&gt;dataptr = seg-&gt;p-&gt;payload;
00186     }
00187     <span class="comment">/* do not copy data */</span>
00188     <span class="keywordflow">else</span> {
00189 
00190       <span class="comment">/* first, allocate a pbuf for holding the data.</span>
00191 <span class="comment">       * since the referenced data is available at least until it is sent out on the</span>
00192 <span class="comment">       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM</span>
00193 <span class="comment">       * instead of PBUF_REF here.</span>
00194 <span class="comment">       */</span>
00195       <span class="keywordflow">if</span> ((p = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(PBUF_TRANSPORT, seglen, PBUF_ROM)) == <a class="code" href="def_8h.html#a2">NULL</a>) {
00196         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG | 2, (<span class="stringliteral">"tcp_enqueue: could not allocate memory for zero-copy pbuf\n"</span>));
00197         <span class="keywordflow">goto</span> memerr;
00198       }
00199       ++queuelen;
00200       p-&gt;payload = ptr;
00201       seg-&gt;dataptr = ptr;
00202 
00203       <span class="comment">/* Second, allocate a pbuf for the headers. */</span>
00204       <span class="keywordflow">if</span> ((seg-&gt;p = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(PBUF_TRANSPORT, 0, PBUF_RAM)) == <a class="code" href="def_8h.html#a2">NULL</a>) {
00205         <span class="comment">/* If allocation fails, we have to deallocate the data pbuf as</span>
00206 <span class="comment">         * well. */</span>
00207         <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00208         <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG | 2, (<span class="stringliteral">"tcp_enqueue: could not allocate memory for header pbuf\n"</span>));
00209         <span class="keywordflow">goto</span> memerr;
00210       }
00211       ++queuelen;
00212 
00213       <span class="comment">/* Chain the headers and data pbufs together. */</span>
00214       <a class="code" href="pbuf_8c.html#a17">pbuf_chain</a>(seg-&gt;p, p);
00215       <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00216       p = <a class="code" href="def_8h.html#a2">NULL</a>;
00217     }
00218 
00219     <span class="comment">/* Now that there are more segments queued, we check again if the</span>
00220 <span class="comment">    length of the queue exceeds the configured maximum. */</span>
00221     <span class="keywordflow">if</span> (queuelen &gt; <a class="code" href="opt_8h.html#a38">TCP_SND_QUEUELEN</a>) {
00222       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG | 2, (<span class="stringliteral">"tcp_enqueue: queue too long %u (%u)\n"</span>, queuelen, TCP_SND_QUEUELEN));
00223       <span class="keywordflow">goto</span> memerr;
00224     }
00225 
00226     seg-&gt;len = seglen;
00227 <span class="preprocessor">#if 0 </span><span class="comment">/* Was commented out. TODO: can someone say why this is here? */</span>
00228     <span class="keywordflow">if</span> ((flags &amp; <a class="code" href="tcp_8h.html#a10">TCP_SYN</a>) || (flags &amp; <a class="code" href="tcp_8h.html#a9">TCP_FIN</a>)) {
00229       ++seg-&gt;len;
00230     }
00231 <span class="preprocessor">#endif</span>
00232 <span class="preprocessor"></span>    <span class="comment">/* Build TCP header. */</span>
00233     <span class="keywordflow">if</span> (<a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(seg-&gt;p, TCP_HLEN)) {
00234 
00235       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG | 2, (<span class="stringliteral">"tcp_enqueue: no room for TCP header in pbuf.\n"</span>));
00236 
00237 <span class="preprocessor">#ifdef TCP_STATS</span>
00238 <span class="preprocessor"></span>      ++lwip_stats.tcp.err;
00239 <span class="preprocessor">#endif </span><span class="comment">/* TCP_STATS */</span>
00240       <span class="keywordflow">goto</span> memerr;
00241     }
00242     seg-&gt;tcphdr = seg-&gt;p-&gt;payload;
00243     seg-&gt;tcphdr-&gt;src = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(pcb-&gt;local_port);
00244     seg-&gt;tcphdr-&gt;dest = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(pcb-&gt;remote_port);
00245     seg-&gt;tcphdr-&gt;seqno = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(seqno);
00246     seg-&gt;tcphdr-&gt;urgp = 0;
00247     <a class="code" href="tcp_8h.html#a27">TCPH_FLAGS_SET</a>(seg-&gt;tcphdr, flags);
00248     <span class="comment">/* don't fill in tcphdr-&gt;ackno and tcphdr-&gt;wnd until later */</span>
00249 
00250     <span class="comment">/* Copy the options into the header, if they are present. */</span>
00251     <span class="keywordflow">if</span> (optdata == <a class="code" href="def_8h.html#a2">NULL</a>) {
00252       <a class="code" href="tcp_8h.html#a26">TCPH_OFFSET_SET</a>(seg-&gt;tcphdr, 5 &lt;&lt; 4);
00253     }
00254     <span class="keywordflow">else</span> {
00255       <a class="code" href="tcp_8h.html#a26">TCPH_OFFSET_SET</a>(seg-&gt;tcphdr, (5 + optlen / 4) &lt;&lt; 4);
00256       <span class="comment">/* Copy options into data portion of segment.</span>
00257 <span class="comment">       Options can thus only be sent in non data carrying</span>
00258 <span class="comment">       segments such as SYN|ACK. */</span>
00259       memcpy(seg-&gt;dataptr, optdata, optlen);
00260     }
00261     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG | DBG_TRACE, (<span class="stringliteral">"tcp_enqueue: queueing %lu:%lu (0x%x)\n"</span>,
00262       <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(seg-&gt;tcphdr-&gt;seqno),
00263       <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(seg-&gt;tcphdr-&gt;seqno) + <a class="code" href="tcp_8h.html#a28">TCP_TCPLEN</a>(seg),
00264       flags));
00265 
00266     left -= seglen;
00267     seqno += seglen;
00268     ptr = (<span class="keywordtype">void</span> *)((<span class="keywordtype">char</span> *)ptr + seglen);
00269   }
00270 
00271 
00272   <span class="comment">/* Now that the data to be enqueued has been broken up into TCP</span>
00273 <span class="comment">  segments in the queue variable, we add them to the end of the</span>
00274 <span class="comment">  pcb-&gt;unsent queue. */</span>
00275   <span class="keywordflow">if</span> (pcb-&gt;unsent == <a class="code" href="def_8h.html#a2">NULL</a>) {
00276     useg = <a class="code" href="def_8h.html#a2">NULL</a>;
00277   }
00278   <span class="keywordflow">else</span> {
00279     <span class="keywordflow">for</span> (useg = pcb-&gt;unsent; useg-&gt;next != <a class="code" href="def_8h.html#a2">NULL</a>; useg = useg-&gt;next);
00280   }
00281 
00282   <span class="comment">/* If there is room in the last pbuf on the unsent queue,</span>
00283 <span class="comment">  chain the first pbuf on the queue together with that. */</span>
00284   <span class="keywordflow">if</span> (useg != <a class="code" href="def_8h.html#a2">NULL</a> &amp;&amp;
00285     <a class="code" href="tcp_8h.html#a28">TCP_TCPLEN</a>(useg) != 0 &amp;&amp;
00286     !(<a class="code" href="tcp_8h.html#a25">TCPH_FLAGS</a>(useg-&gt;tcphdr) &amp; (<a class="code" href="tcp_8h.html#a10">TCP_SYN</a> | <a class="code" href="tcp_8h.html#a9">TCP_FIN</a>)) &amp;&amp;
00287     !(flags &amp; (<a class="code" href="tcp_8h.html#a10">TCP_SYN</a> | <a class="code" href="tcp_8h.html#a9">TCP_FIN</a>)) &amp;&amp;
00288     useg-&gt;len + queue-&gt;len &lt;= pcb-&gt;mss) {
00289     <span class="comment">/* Remove TCP header from first segment. */</span>
00290     <a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(queue-&gt;p, -TCP_HLEN);
00291     <a class="code" href="pbuf_8c.html#a17">pbuf_chain</a>(useg-&gt;p, queue-&gt;p);
00292     <span class="comment">/* Free buffer which was merged. Note that the previous pbuf_chain call</span>
00293 <span class="comment">     * will have incremented the ref count, so here the ref count will still</span>
00294 <span class="comment">     * be 1 for the 1 pointer still being used on this buffer. */</span>
00295     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(queue-&gt;p);
00296     useg-&gt;len += queue-&gt;len;
00297     useg-&gt;next = queue-&gt;next;
00298 
00299     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG | DBG_TRACE | DBG_STATE, (<span class="stringliteral">"tcp_enqueue: chaining, new len %u\n"</span>, useg-&gt;len));
00300     <span class="keywordflow">if</span> (seg == queue) {
00301       seg = <a class="code" href="def_8h.html#a2">NULL</a>;
00302     }
00303     <a class="code" href="memp_8c.html#a8">memp_free</a>(MEMP_TCP_SEG, queue);
00304   }
00305   <span class="keywordflow">else</span> {
00306     <span class="keywordflow">if</span> (useg == <a class="code" href="def_8h.html#a2">NULL</a>) {
00307       pcb-&gt;unsent = queue;
00308 
00309     }
00310     <span class="keywordflow">else</span> {
00311       useg-&gt;next = queue;
00312     }
00313   }
00314   <span class="keywordflow">if</span> ((flags &amp; <a class="code" href="tcp_8h.html#a10">TCP_SYN</a>) || (flags &amp; <a class="code" href="tcp_8h.html#a9">TCP_FIN</a>)) {
00315     ++len;
00316   }
00317   pcb-&gt;snd_lbb += len;
00318   pcb-&gt;snd_buf -= len;
00319   pcb-&gt;snd_queuelen = queuelen;
00320   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_QLEN_DEBUG, (<span class="stringliteral">"tcp_enqueue: %d (after enqueued)\n"</span>, pcb-&gt;snd_queuelen));
00321   <span class="keywordflow">if</span> (pcb-&gt;snd_queuelen != 0) {
00322     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_enqueue: valid queue length"</span>, pcb-&gt;unacked != NULL ||
00323       pcb-&gt;unsent != NULL);
00324 
00325   }
00326 
00327   <span class="comment">/* Set the PSH flag in the last segment that we enqueued, but only</span>
00328 <span class="comment">  if the segment has data (indicated by seglen &gt; 0). */</span>
00329   <span class="keywordflow">if</span> (seg != <a class="code" href="def_8h.html#a2">NULL</a> &amp;&amp; seglen &gt; 0 &amp;&amp; seg-&gt;tcphdr != <a class="code" href="def_8h.html#a2">NULL</a>) {
00330     <a class="code" href="tcp_8h.html#a27">TCPH_FLAGS_SET</a>(seg-&gt;tcphdr, <a class="code" href="tcp_8h.html#a25">TCPH_FLAGS</a>(seg-&gt;tcphdr) | TCP_PSH);
00331   }
00332 
00333   <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00334   memerr:
00335 <span class="preprocessor">#ifdef TCP_STATS</span>
00336 <span class="preprocessor"></span>  ++lwip_stats.tcp.memerr;
00337 <span class="preprocessor">#endif </span><span class="comment">/* TCP_STATS */</span>
00338 
00339   <span class="keywordflow">if</span> (queue != <a class="code" href="def_8h.html#a2">NULL</a>) {
00340     <a class="code" href="tcp_8h.html#a90">tcp_segs_free</a>(queue);
00341   }
00342   <span class="keywordflow">if</span> (pcb-&gt;snd_queuelen != 0) {
00343     <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"tcp_enqueue: valid queue length"</span>, pcb-&gt;unacked != NULL ||
00344       pcb-&gt;unsent != NULL);
00345 
00346   }
00347   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_QLEN_DEBUG | DBG_STATE, (<span class="stringliteral">"tcp_enqueue: %d (with mem err)\n"</span>, pcb-&gt;snd_queuelen));
00348   <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a1">ERR_MEM</a>;
00349 }
00350 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00351 <span class="comment">/* find out what we can send and send it */</span>
00352 <a class="code" href="err_8h.html#a13">err_t</a>
00353 <a class="code" href="tcp_8h.html#a85">tcp_output</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
00354 {
00355   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p;
00356   <span class="keyword">struct </span><a class="code" href="structtcp__hdr.html">tcp_hdr</a> *<a class="code" href="structtcphdr.html">tcphdr</a>;
00357   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *seg, *useg;
00358   u32_t wnd;
00359 <span class="preprocessor">#if TCP_CWND_DEBUG</span>
00360 <span class="preprocessor"></span>  <span class="keywordtype">int</span> i = 0;
00361 <span class="preprocessor">#endif </span><span class="comment">/* TCP_CWND_DEBUG */</span>
00362 
00363   <span class="comment">/* First, check if we are invoked by the TCP input processing</span>
00364 <span class="comment">     code. If so, we do not output anything. Instead, we rely on the</span>
00365 <span class="comment">     input processing code to call us when input processing is done</span>
00366 <span class="comment">     with. */</span>
00367   <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a47">tcp_input_pcb</a> == pcb) {
00368     <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00369   }
00370 
00371   wnd = <a class="code" href="def_8h.html#a1">LWIP_MIN</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o28">snd_wnd</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a>);
00372 
00373 
00374   seg = pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a>;
00375 
00376   <span class="comment">/* If the TF_ACK_NOW flag is set, we check if there is data that is</span>
00377 <span class="comment">     to be sent. If data is to be sent out, we'll just piggyback our</span>
00378 <span class="comment">     acknowledgement with the outgoing segment. If no data will be</span>
00379 <span class="comment">     sent (either because the -&gt;unsent queue is empty or because the</span>
00380 <span class="comment">     window doesn't allow it) we'll have to construct an empty ACK</span>
00381 <span class="comment">     segment and send it. */</span>
00382   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o15">flags</a> &amp; <a class="code" href="tcp_8h.html#a30">TF_ACK_NOW</a> &amp;&amp;
00383      (seg == <a class="code" href="def_8h.html#a2">NULL</a> ||
00384       <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a> + seg-&gt;len &gt; wnd)) {
00385     pcb-&gt;<a class="code" href="structtcp__pcb.html#o15">flags</a> &amp;= ~(<a class="code" href="tcp_8h.html#a29">TF_ACK_DELAY</a> | <a class="code" href="tcp_8h.html#a30">TF_ACK_NOW</a>);
00386     p = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(PBUF_IP, TCP_HLEN, PBUF_RAM);
00387     <span class="keywordflow">if</span> (p == <a class="code" href="def_8h.html#a2">NULL</a>) {
00388       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG, (<span class="stringliteral">"tcp_output: (ACK) could not allocate pbuf\n"</span>));
00389       <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a2">ERR_BUF</a>;
00390     }
00391     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG, (<span class="stringliteral">"tcp_output: sending ACK for %lu\n"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>));
00392 
00393     <a class="code" href="structtcphdr.html">tcphdr</a> = p-&gt;payload;
00394     <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;src = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o4">local_port</a>);
00395     <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;dest = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o7">remote_port</a>);
00396     <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;seqno = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a>);
00397     <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;ackno = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>);
00398     <a class="code" href="tcp_8h.html#a27">TCPH_FLAGS_SET</a>(<a class="code" href="structtcphdr.html">tcphdr</a>, TCP_ACK);
00399     <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;wnd = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a>);
00400     <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;urgp = 0;
00401     <a class="code" href="tcp_8h.html#a26">TCPH_OFFSET_SET</a>(<a class="code" href="structtcphdr.html">tcphdr</a>, 5 &lt;&lt; 4);
00402 
00403     <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;chksum = 0;
00404     <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;chksum = <a class="code" href="inet6_8c.html#a1">inet_chksum_pseudo</a>(p, &amp;(pcb-&gt;<a class="code" href="structtcp__pcb.html#o3">local_ip</a>), &amp;(pcb-&gt;<a class="code" href="structtcp__pcb.html#o6">remote_ip</a>),
00405           IP_PROTO_TCP, p-&gt;tot_len);
00406 
00407     <a class="code" href="ipv6_2lwip_2ip_8h.html#a9">ip_output</a>(p, &amp;(pcb-&gt;<a class="code" href="structtcp__pcb.html#o3">local_ip</a>), &amp;(pcb-&gt;<a class="code" href="structtcp__pcb.html#o6">remote_ip</a>), TCP_TTL,
00408         IP_PROTO_TCP);
00409     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00410 
00411     <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00412   }
00413 
00414 <span class="preprocessor">#if TCP_OUTPUT_DEBUG</span>
00415 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (seg == <a class="code" href="def_8h.html#a2">NULL</a>) {
00416     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG, (<span class="stringliteral">"tcp_output: nothing to send (%p)\n"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a>));
00417   }
00418 <span class="preprocessor">#endif </span><span class="comment">/* TCP_OUTPUT_DEBUG */</span>
00419 <span class="preprocessor">#if TCP_CWND_DEBUG</span>
00420 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (seg == <a class="code" href="def_8h.html#a2">NULL</a>) {
00421     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_CWND_DEBUG, (<span class="stringliteral">"tcp_output: snd_wnd %lu, cwnd %lu, wnd %lu, seg == NULL, ack %lu\n"</span>,
00422                             pcb-&gt;<a class="code" href="structtcp__pcb.html#o28">snd_wnd</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a>, wnd,
00423                             pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a>));
00424   } <span class="keywordflow">else</span> {
00425     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_CWND_DEBUG, (<span class="stringliteral">"tcp_output: snd_wnd %lu, cwnd %lu, wnd %lu, effwnd %lu, seq %lu, ack %lu\n"</span>,
00426                             pcb-&gt;<a class="code" href="structtcp__pcb.html#o28">snd_wnd</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a>, wnd,
00427                             <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a> + seg-&gt;len,
00428                             <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(seg-&gt;tcphdr-&gt;seqno), pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a>));
00429   }
00430 <span class="preprocessor">#endif </span><span class="comment">/* TCP_CWND_DEBUG */</span>
00431 
00432   <span class="keywordflow">while</span> (seg != <a class="code" href="def_8h.html#a2">NULL</a> &amp;&amp;
00433   <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a> + seg-&gt;len &lt;= wnd) {
00434 <span class="preprocessor">#if TCP_CWND_DEBUG</span>
00435 <span class="preprocessor"></span>    <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_CWND_DEBUG, (<span class="stringliteral">"tcp_output: snd_wnd %lu, cwnd %lu, wnd %lu, effwnd %lu, seq %lu, ack %lu, i%d\n"</span>,
00436                             pcb-&gt;<a class="code" href="structtcp__pcb.html#o28">snd_wnd</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o24">cwnd</a>, wnd,
00437                             <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(seg-&gt;tcphdr-&gt;seqno) + seg-&gt;len -
00438                             pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a>,
00439                             <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(seg-&gt;tcphdr-&gt;seqno), pcb-&gt;<a class="code" href="structtcp__pcb.html#o22">lastack</a>, i));
00440     ++i;
00441 <span class="preprocessor">#endif </span><span class="comment">/* TCP_CWND_DEBUG */</span>
00442 
00443     pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a> = seg-&gt;<a class="code" href="structtcp__seg.html#o0">next</a>;
00444 
00445     <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o5">state</a> != <a class="code" href="tcp_8h.html#a99a55">SYN_SENT</a>) {
00446       <a class="code" href="tcp_8h.html#a27">TCPH_FLAGS_SET</a>(seg-&gt;tcphdr, <a class="code" href="tcp_8h.html#a25">TCPH_FLAGS</a>(seg-&gt;tcphdr) | TCP_ACK);
00447       pcb-&gt;<a class="code" href="structtcp__pcb.html#o15">flags</a> &amp;= ~(<a class="code" href="tcp_8h.html#a29">TF_ACK_DELAY</a> | <a class="code" href="tcp_8h.html#a30">TF_ACK_NOW</a>);
00448     }
00449 
00450     tcp_output_segment(seg, pcb);
00451     pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a> = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(seg-&gt;tcphdr-&gt;seqno) + <a class="code" href="tcp_8h.html#a28">TCP_TCPLEN</a>(seg);
00452     <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a5">TCP_SEQ_LT</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o27">snd_max</a>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a>)) {
00453       pcb-&gt;<a class="code" href="structtcp__pcb.html#o27">snd_max</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a>;
00454     }
00455     <span class="comment">/* put segment on unacknowledged list if length &gt; 0 */</span>
00456     <span class="keywordflow">if</span> (<a class="code" href="tcp_8h.html#a28">TCP_TCPLEN</a>(seg) &gt; 0) {
00457       seg-&gt;next = <a class="code" href="def_8h.html#a2">NULL</a>;
00458       <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> == <a class="code" href="def_8h.html#a2">NULL</a>) {
00459         pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> = seg;
00460 
00461 
00462       } <span class="keywordflow">else</span> {
00463         <span class="keywordflow">for</span> (useg = pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>; useg-&gt;<a class="code" href="structtcp__seg.html#o0">next</a> != <a class="code" href="def_8h.html#a2">NULL</a>; useg = useg-&gt;next);
00464         useg-&gt;<a class="code" href="structtcp__seg.html#o0">next</a> = seg;
00465       }
00466     } <span class="keywordflow">else</span> {
00467       <a class="code" href="tcp_8h.html#a91">tcp_seg_free</a>(seg);
00468     }
00469     seg = pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a>;
00470   }
00471   <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00472 }
00473 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00474 <span class="keyword">static</span> <span class="keywordtype">void</span>
00475 tcp_output_segment(<span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a> *seg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
00476 {
00477   u16_t len;
00478   <span class="keyword">struct </span><a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>;
00479 
00480   <span class="comment">/* The TCP header has already been constructed, but the ackno and</span>
00481 <span class="comment">   wnd fields remain. */</span>
00482   seg-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;ackno = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o8">rcv_nxt</a>);
00483 
00484   <span class="comment">/* silly window avoidance */</span>
00485   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a> &lt; pcb-&gt;<a class="code" href="structtcp__pcb.html#o14">mss</a>) {
00486     seg-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;wnd = 0;
00487   } <span class="keywordflow">else</span> {
00488     <span class="comment">/* advertise our receive window size in this TCP segment */</span>
00489     seg-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;wnd = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o9">rcv_wnd</a>);
00490   }
00491 
00492   <span class="comment">/* If we don't have a local IP address, we get one by</span>
00493 <span class="comment">     calling ip_route(). */</span>
00494   <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a30">ip_addr_isany</a>(&amp;(pcb-&gt;<a class="code" href="structtcp__pcb.html#o3">local_ip</a>))) {
00495     <a class="code" href="structnetif.html">netif</a> = <a class="code" href="ip_8c.html#a1">ip_route</a>(&amp;(pcb-&gt;<a class="code" href="structtcp__pcb.html#o6">remote_ip</a>));
00496     <span class="keywordflow">if</span> (<a class="code" href="structnetif.html">netif</a> == <a class="code" href="def_8h.html#a2">NULL</a>) {
00497       <span class="keywordflow">return</span>;
00498     }
00499     <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a27">ip_addr_set</a>(&amp;(pcb-&gt;<a class="code" href="structtcp__pcb.html#o3">local_ip</a>), &amp;(<a class="code" href="structnetif.html">netif</a>-&gt;ip_addr));
00500   }
00501 
00502   pcb-&gt;<a class="code" href="structtcp__pcb.html#o13">rtime</a> = 0;
00503 
00504   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o16">rttest</a> == 0) {
00505     pcb-&gt;<a class="code" href="structtcp__pcb.html#o16">rttest</a> = <a class="code" href="tcp_8h.html#a48">tcp_ticks</a>;
00506     pcb-&gt;<a class="code" href="structtcp__pcb.html#o17">rtseq</a> = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(seg-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno);
00507 
00508     <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_RTO_DEBUG, (<span class="stringliteral">"tcp_output_segment: rtseq %lu\n"</span>, pcb-&gt;<a class="code" href="structtcp__pcb.html#o17">rtseq</a>));
00509   }
00510   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_OUTPUT_DEBUG, (<span class="stringliteral">"tcp_output_segment: %lu:%lu\n"</span>,
00511           <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(seg-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno), <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(seg-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno) +
00512           seg-&gt;<a class="code" href="structtcp__seg.html#o3">len</a>));
00513 
00514   len = (u16_t)((u8_t *)seg-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a> - (u8_t *)seg-&gt;<a class="code" href="structtcp__seg.html#o1">p</a>-&gt;<a class="code" href="structpbuf.html#o1">payload</a>);
00515 
00516   seg-&gt;<a class="code" href="structtcp__seg.html#o1">p</a>-&gt;<a class="code" href="structpbuf.html#o3">len</a> -= len;
00517   seg-&gt;<a class="code" href="structtcp__seg.html#o1">p</a>-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a> -= len;
00518 
00519   seg-&gt;<a class="code" href="structtcp__seg.html#o1">p</a>-&gt;<a class="code" href="structpbuf.html#o1">payload</a> = seg-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>;
00520 
00521   seg-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;chksum = 0;
00522   seg-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;chksum = <a class="code" href="inet6_8c.html#a1">inet_chksum_pseudo</a>(seg-&gt;<a class="code" href="structtcp__seg.html#o1">p</a>,
00523              &amp;(pcb-&gt;<a class="code" href="structtcp__pcb.html#o3">local_ip</a>),
00524              &amp;(pcb-&gt;<a class="code" href="structtcp__pcb.html#o6">remote_ip</a>),
00525              IP_PROTO_TCP, seg-&gt;<a class="code" href="structtcp__seg.html#o1">p</a>-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a>);
00526 <span class="preprocessor">#ifdef TCP_STATS</span>
00527 <span class="preprocessor"></span>  ++lwip_stats.tcp.xmit;
00528 <span class="preprocessor">#endif </span><span class="comment">/* TCP_STATS */</span>
00529 
00530   <a class="code" href="ipv6_2lwip_2ip_8h.html#a9">ip_output</a>(seg-&gt;<a class="code" href="structtcp__seg.html#o1">p</a>, &amp;(pcb-&gt;<a class="code" href="structtcp__pcb.html#o3">local_ip</a>), &amp;(pcb-&gt;<a class="code" href="structtcp__pcb.html#o6">remote_ip</a>), TCP_TTL,
00531       IP_PROTO_TCP);
00532 }
00533 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00534 <span class="keywordtype">void</span>
00535 <a class="code" href="tcp_8h.html#a96">tcp_rst</a>(u32_t seqno, u32_t ackno,
00536   <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *local_ip, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *remote_ip,
00537   u16_t local_port, u16_t remote_port)
00538 {
00539   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p;
00540   <span class="keyword">struct </span><a class="code" href="structtcp__hdr.html">tcp_hdr</a> *<a class="code" href="structtcphdr.html">tcphdr</a>;
00541   p = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(PBUF_IP, TCP_HLEN, PBUF_RAM);
00542   <span class="keywordflow">if</span> (p == <a class="code" href="def_8h.html#a2">NULL</a>) {
00543       <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_DEBUG, (<span class="stringliteral">"tcp_rst: could not allocate memory for pbuf\n"</span>));
00544       <span class="keywordflow">return</span>;
00545   }
00546 
00547   <a class="code" href="structtcphdr.html">tcphdr</a> = p-&gt;payload;
00548   <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;src = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(local_port);
00549   <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;dest = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(remote_port);
00550   <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;seqno = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(seqno);
00551   <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;ackno = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(ackno);
00552   <a class="code" href="tcp_8h.html#a27">TCPH_FLAGS_SET</a>(<a class="code" href="structtcphdr.html">tcphdr</a>, TCP_RST | TCP_ACK);
00553   <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;wnd = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(TCP_WND);
00554   <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;urgp = 0;
00555   <a class="code" href="tcp_8h.html#a26">TCPH_OFFSET_SET</a>(<a class="code" href="structtcphdr.html">tcphdr</a>, 5 &lt;&lt; 4);
00556 
00557   <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;chksum = 0;
00558   <a class="code" href="structtcphdr.html">tcphdr</a>-&gt;chksum = <a class="code" href="inet6_8c.html#a1">inet_chksum_pseudo</a>(p, local_ip, remote_ip,
00559               IP_PROTO_TCP, p-&gt;tot_len);
00560 
00561 <span class="preprocessor">#ifdef TCP_STATS</span>
00562 <span class="preprocessor"></span>  ++lwip_stats.tcp.xmit;
00563 <span class="preprocessor">#endif </span><span class="comment">/* TCP_STATS */</span>
00564   <a class="code" href="ipv6_2lwip_2ip_8h.html#a9">ip_output</a>(p, local_ip, remote_ip, TCP_TTL, IP_PROTO_TCP);
00565   <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
00566   <a class="code" href="debug_8h.html#a12">LWIP_DEBUGF</a>(TCP_RST_DEBUG, (<span class="stringliteral">"tcp_rst: seqno %lu ackno %lu.\n"</span>, seqno, ackno));
00567 }
00568 <span class="comment">/*-----------------------------------------------------------------------------------*/</span>
00569 <span class="keywordtype">void</span>
00570 <a class="code" href="tcp_8h.html#a86">tcp_rexmit</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
00571 {
00572   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *seg;
00573 
00574   <span class="keywordflow">if</span> (pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> == <a class="code" href="def_8h.html#a2">NULL</a>) {
00575     <span class="keywordflow">return</span>;
00576   }
00577 
00578   <span class="comment">/* Move all unacked segments to the unsent queue. */</span>
00579   <span class="keywordflow">for</span> (seg = pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>; seg-&gt;<a class="code" href="structtcp__seg.html#o0">next</a> != <a class="code" href="def_8h.html#a2">NULL</a>; seg = seg-&gt;<a class="code" href="structtcp__seg.html#o0">next</a>);
00580 
00581   seg-&gt;<a class="code" href="structtcp__seg.html#o0">next</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a>;
00582   pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a> = pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a>;
00583 
00584   pcb-&gt;<a class="code" href="structtcp__pcb.html#o36">unacked</a> = <a class="code" href="def_8h.html#a2">NULL</a>;
00585 
00586 
00587   pcb-&gt;<a class="code" href="structtcp__pcb.html#o26">snd_nxt</a> = <a class="code" href="ipv4_2lwip_2inet_8h.html#a3">ntohl</a>(pcb-&gt;<a class="code" href="structtcp__pcb.html#o35">unsent</a>-&gt;<a class="code" href="structtcp__seg.html#o4">tcphdr</a>-&gt;seqno);
00588 
00589   ++pcb-&gt;<a class="code" href="structtcp__pcb.html#o21">nrtx</a>;
00590 
00591   <span class="comment">/* Don't take any rtt measurements after retransmitting. */</span>
00592   pcb-&gt;<a class="code" href="structtcp__pcb.html#o16">rttest</a> = 0;
00593 
00594   <span class="comment">/* Do the actual retransmission. */</span>
00595   <a class="code" href="tcp_8h.html#a85">tcp_output</a>(pcb);
00596 
00597 }
00598 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_TCP */</span>
00599 
00600 
00601 
00602 
00603 
00604 
00605 
00606 
00607 
</pre></div>	</td>
  </tr>
</table>
<hr>
<div align="center">Copyright (c) 2001-2003 Swedish Institute of Computer Science</div>
</html>
