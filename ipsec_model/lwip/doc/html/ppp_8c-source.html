
<html>
<head>
<title>lwIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="doxygen.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<table width="98%" border="0" align="center">
  <tr>
    <td>
      <h2>lwIP code documentation</h2>
<hr>

<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>ppp.c</h1><a href="ppp_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*****************************************************************************</span>
00002 <span class="comment">* ppp.c - Network Point to Point Protocol program file.</span>
00003 <span class="comment">*</span>
00004 <span class="comment">* Copyright (c) 2003 by Marc Boucher, Services Informatiques (MBSI) inc.</span>
00005 <span class="comment">* portions Copyright (c) 1997 by Global Election Systems Inc.</span>
00006 <span class="comment">*</span>
00007 <span class="comment">* The authors hereby grant permission to use, copy, modify, distribute,</span>
00008 <span class="comment">* and license this software and its documentation for any purpose, provided</span>
00009 <span class="comment">* that existing copyright notices are retained in all copies and that this</span>
00010 <span class="comment">* notice and the following disclaimer are included verbatim in any </span>
00011 <span class="comment">* distributions. No written agreement, license, or royalty fee is required</span>
00012 <span class="comment">* for any of the authorized uses.</span>
00013 <span class="comment">*</span>
00014 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS *AS IS* AND ANY EXPRESS OR</span>
00015 <span class="comment">* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
00016 <span class="comment">* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. </span>
00017 <span class="comment">* IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
00018 <span class="comment">* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
00019 <span class="comment">* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
00020 <span class="comment">* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
00021 <span class="comment">* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
00022 <span class="comment">* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
00023 <span class="comment">* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00024 <span class="comment">*</span>
00025 <span class="comment">******************************************************************************</span>
00026 <span class="comment">* REVISION HISTORY</span>
00027 <span class="comment">*</span>
00028 <span class="comment">* 03-01-01 Marc Boucher &lt;marc@mbsi.ca&gt;</span>
00029 <span class="comment">*   Ported to lwIP.</span>
00030 <span class="comment">* 97-11-05 Guy Lancaster &lt;lancasterg@acm.org&gt;, Global Election Systems Inc.</span>
00031 <span class="comment">*   Original.</span>
00032 <span class="comment">*****************************************************************************/</span>
00033 
00034 <span class="comment">/*</span>
00035 <span class="comment"> * ppp_defs.h - PPP definitions.</span>
00036 <span class="comment"> *</span>
00037 <span class="comment"> * if_pppvar.h - private structures and declarations for PPP.</span>
00038 <span class="comment"> *</span>
00039 <span class="comment"> * Copyright (c) 1994 The Australian National University.</span>
00040 <span class="comment"> * All rights reserved.</span>
00041 <span class="comment"> *</span>
00042 <span class="comment"> * Permission to use, copy, modify, and distribute this software and its</span>
00043 <span class="comment"> * documentation is hereby granted, provided that the above copyright</span>
00044 <span class="comment"> * notice appears in all copies.  This software is provided without any</span>
00045 <span class="comment"> * warranty, express or implied. The Australian National University</span>
00046 <span class="comment"> * makes no representations about the suitability of this software for</span>
00047 <span class="comment"> * any purpose.</span>
00048 <span class="comment"> *</span>
00049 <span class="comment"> * IN NO EVENT SHALL THE AUSTRALIAN NATIONAL UNIVERSITY BE LIABLE TO ANY</span>
00050 <span class="comment"> * PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES</span>
00051 <span class="comment"> * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF</span>
00052 <span class="comment"> * THE AUSTRALIAN NATIONAL UNIVERSITY HAVE BEEN ADVISED OF THE POSSIBILITY</span>
00053 <span class="comment"> * OF SUCH DAMAGE.</span>
00054 <span class="comment"> *</span>
00055 <span class="comment"> * THE AUSTRALIAN NATIONAL UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,</span>
00056 <span class="comment"> * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY</span>
00057 <span class="comment"> * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS</span>
00058 <span class="comment"> * ON AN "AS IS" BASIS, AND THE AUSTRALIAN NATIONAL UNIVERSITY HAS NO</span>
00059 <span class="comment"> * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,</span>
00060 <span class="comment"> * OR MODIFICATIONS.</span>
00061 <span class="comment"> */</span>
00062 
00063 <span class="comment">/*</span>
00064 <span class="comment"> * if_ppp.h - Point-to-Point Protocol definitions.</span>
00065 <span class="comment"> *</span>
00066 <span class="comment"> * Copyright (c) 1989 Carnegie Mellon University.</span>
00067 <span class="comment"> * All rights reserved.</span>
00068 <span class="comment"> *</span>
00069 <span class="comment"> * Redistribution and use in source and binary forms are permitted</span>
00070 <span class="comment"> * provided that the above copyright notice and this paragraph are</span>
00071 <span class="comment"> * duplicated in all such forms and that any documentation,</span>
00072 <span class="comment"> * advertising materials, and other materials related to such</span>
00073 <span class="comment"> * distribution and use acknowledge that the software was developed</span>
00074 <span class="comment"> * by Carnegie Mellon University.  The name of the</span>
00075 <span class="comment"> * University may not be used to endorse or promote products derived</span>
00076 <span class="comment"> * from this software without specific prior written permission.</span>
00077 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR</span>
00078 <span class="comment"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
00079 <span class="comment"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
00080 <span class="comment"> */</span>
00081 <span class="preprocessor">#include "<a class="code" href="ppp_8h.html">ppp.h</a>"</span>
00082 <span class="preprocessor">#if PPP_SUPPORT &gt; 0</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="randm_8h.html">randm.h</a>"</span>
00084 <span class="preprocessor">#include "<a class="code" href="fsm_8h.html">fsm.h</a>"</span>
00085 <span class="preprocessor">#if PAP_SUPPORT &gt; 0</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="pap_8h.html">pap.h</a>"</span>
00087 <span class="preprocessor">#endif</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#if CHAP_SUPPORT &gt; 0</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="chap_8h.html">chap.h</a>"</span>
00090 <span class="preprocessor">#endif</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="ipcp_8h.html">ipcp.h</a>"</span>
00092 <span class="preprocessor">#include "<a class="code" href="lcp_8h.html">lcp.h</a>"</span>
00093 <span class="preprocessor">#include "<a class="code" href="magic_8h.html">magic.h</a>"</span>
00094 <span class="preprocessor">#include "<a class="code" href="auth_8h.html">auth.h</a>"</span>
00095 <span class="preprocessor">#if VJ_SUPPORT &gt; 0</span>
00096 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="vj_8h.html">vj.h</a>"</span>
00097 <span class="preprocessor">#endif</span>
00098 <span class="preprocessor"></span>
00099 <span class="preprocessor">#include "<a class="code" href="pppdebug_8h.html">pppdebug.h</a>"</span>
00100 
00101 <span class="comment">/*************************/</span>
00102 <span class="comment">/*** LOCAL DEFINITIONS ***/</span>
00103 <span class="comment">/*************************/</span>
00104 
00105 <span class="comment">/*</span>
00106 <span class="comment"> * The basic PPP frame.</span>
00107 <span class="comment"> */</span>
00108 <span class="preprocessor">#define PPP_ADDRESS(p)  (((u_char *)(p))[0])</span>
00109 <span class="preprocessor"></span><span class="preprocessor">#define PPP_CONTROL(p)  (((u_char *)(p))[1])</span>
00110 <span class="preprocessor"></span><span class="preprocessor">#define PPP_PROTOCOL(p) ((((u_char *)(p))[2] &lt;&lt; 8) + ((u_char *)(p))[3])</span>
00111 <span class="preprocessor"></span>
00112 <span class="comment">/* PPP packet parser states.  Current state indicates operation yet to be</span>
00113 <span class="comment"> * completed. */</span>
00114 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
00115     PDIDLE = 0,                 <span class="comment">/* Idle state - waiting. */</span>
00116     PDSTART,                    <span class="comment">/* Process start flag. */</span>
00117     PDADDRESS,                  <span class="comment">/* Process address field. */</span>
00118     PDCONTROL,                  <span class="comment">/* Process control field. */</span>
00119     PDPROTOCOL1,                <span class="comment">/* Process protocol field 1. */</span>
00120     PDPROTOCOL2,                <span class="comment">/* Process protocol field 2. */</span>
00121     PDDATA                      <span class="comment">/* Process data byte. */</span>
00122 } PPPDevStates;
00123 
00124 <span class="preprocessor">#define ESCAPE_P(accm, c) ((accm)[(c) &gt;&gt; 3] &amp; pppACCMMask[c &amp; 0x07])</span>
00125 <span class="preprocessor"></span>
00126 <span class="comment">/************************/</span>
00127 <span class="comment">/*** LOCAL DATA TYPES ***/</span>
00128 <span class="comment">/************************/</span>
00129 <span class="comment">/*</span>
00130 <span class="comment"> * PPP interface control block.</span>
00131 <span class="comment"> */</span>
00132 <span class="keyword">typedef</span> <span class="keyword">struct </span>PPPControl_s {
00133     <span class="keywordtype">char</span> openFlag;                      <span class="comment">/* True when in use. */</span>
00134     <span class="keywordtype">char</span> oldFrame;                      <span class="comment">/* Old framing character for fd. */</span>
00135     <a class="code" href="sio_8h.html#a0">sio_fd_t</a> fd;                    <span class="comment">/* File device ID of port. */</span>
00136     <span class="keywordtype">int</span>  kill_link;                     <span class="comment">/* Shut the link down. */</span>
00137     <span class="keywordtype">int</span>  sig_hup;                       <span class="comment">/* Carrier lost. */</span>
00138     <span class="keywordtype">int</span>  if_up;                         <span class="comment">/* True when the interface is up. */</span>
00139     <span class="keywordtype">int</span>  errCode;                       <span class="comment">/* Code indicating why interface is down. */</span>
00140     <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *inHead, *inTail;       <span class="comment">/* The input packet. */</span>
00141     PPPDevStates inState;               <span class="comment">/* The input process state. */</span>
00142     <span class="keywordtype">char</span> inEscaped;                     <span class="comment">/* Escape next character. */</span>
00143     u16_t inProtocol;                   <span class="comment">/* The input protocol code. */</span>
00144     u16_t inFCS;                        <span class="comment">/* Input Frame Check Sequence value. */</span>
00145     <span class="keywordtype">int</span>  mtu;                           <span class="comment">/* Peer's mru */</span>
00146     <span class="keywordtype">int</span>  pcomp;                         <span class="comment">/* Does peer accept protocol compression? */</span>
00147     <span class="keywordtype">int</span>  accomp;                        <span class="comment">/* Does peer accept addr/ctl compression? */</span>
00148     u_long lastXMit;                    <span class="comment">/* Time of last transmission. */</span>
00149     ext_accm inACCM;                    <span class="comment">/* Async-Ctl-Char-Map for input. */</span>
00150     ext_accm outACCM;                   <span class="comment">/* Async-Ctl-Char-Map for output. */</span>
00151 <span class="preprocessor">#if VJ_SUPPORT &gt; 0</span>
00152 <span class="preprocessor"></span>    <span class="keywordtype">int</span>  vjEnabled;                     <span class="comment">/* Flag indicating VJ compression enabled. */</span>
00153     <span class="keyword">struct </span><a class="code" href="structvjcompress.html">vjcompress</a> vjComp;           <span class="comment">/* Van Jabobsen compression header. */</span>
00154 <span class="preprocessor">#endif</span>
00155 <span class="preprocessor"></span>
00156     <span class="keyword">struct </span><a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>;
00157 
00158     <span class="keyword">struct </span>ppp_addrs addrs;
00159 
00160     void (*linkStatusCB)(<span class="keywordtype">void</span> *ctx, <span class="keywordtype">int</span> errCode, <span class="keywordtype">void</span> *arg);
00161     <span class="keywordtype">void</span> *linkStatusCtx;
00162 
00163 } PPPControl;
00164 
00165 
00166 <span class="comment">/*</span>
00167 <span class="comment"> * Ioctl definitions.</span>
00168 <span class="comment"> */</span>
00169 
00170 <span class="keyword">struct </span>npioctl {
00171     <span class="keywordtype">int</span>     protocol;           <span class="comment">/* PPP procotol, e.g. PPP_IP */</span>
00172     <span class="keyword">enum</span> NPmode mode;
00173 };
00174 
00175 
00176 
00177 <span class="comment">/***********************************/</span>
00178 <span class="comment">/*** LOCAL FUNCTION DECLARATIONS ***/</span>
00179 <span class="comment">/***********************************/</span>
00180 <span class="keyword">static</span> <span class="keywordtype">void</span> pppMain(<span class="keywordtype">void</span> *pd);
00181 <span class="keyword">static</span> <span class="keywordtype">void</span> pppDrop(PPPControl *pc);
00182 <span class="keyword">static</span> <span class="keywordtype">void</span> pppInProc(<span class="keywordtype">int</span> pd, u_char *s, <span class="keywordtype">int</span> l);
00183 
00184 
00185 <span class="comment">/******************************/</span>
00186 <span class="comment">/*** PUBLIC DATA STRUCTURES ***/</span>
00187 <span class="comment">/******************************/</span>
00188 u_long subnetMask;
00189 
00190 <span class="keyword">static</span> PPPControl pppControl[NUM_PPP]; <span class="comment">/* The PPP interface control blocks. */</span>
00191 
00192 <span class="comment">/*</span>
00193 <span class="comment"> * PPP Data Link Layer "protocol" table.</span>
00194 <span class="comment"> * One entry per supported protocol.</span>
00195 <span class="comment"> * The last entry must be NULL.</span>
00196 <span class="comment"> */</span>
00197 <span class="keyword">struct </span>protent *ppp_protocols[] = {
00198     &amp;<a class="code" href="lcp_8h.html#a24">lcp_protent</a>,
00199 <span class="preprocessor">#if PAP_SUPPORT &gt; 0</span>
00200 <span class="preprocessor"></span>    &amp;<a class="code" href="pap_8h.html#a18">pap_protent</a>,
00201 <span class="preprocessor">#endif</span>
00202 <span class="preprocessor"></span><span class="preprocessor">#if CHAP_SUPPORT &gt; 0</span>
00203 <span class="preprocessor"></span>    &amp;<a class="code" href="chap_8h.html#a27">chap_protent</a>,
00204 <span class="preprocessor">#endif</span>
00205 <span class="preprocessor"></span><span class="preprocessor">#if CBCP_SUPPORT &gt; 0</span>
00206 <span class="preprocessor"></span>    &amp;cbcp_protent,
00207 <span class="preprocessor">#endif</span>
00208 <span class="preprocessor"></span>    &amp;<a class="code" href="ipcp_8h.html#a18">ipcp_protent</a>,
00209 <span class="preprocessor">#if CCP_SUPPORT &gt; 0</span>
00210 <span class="preprocessor"></span>    &amp;ccp_protent,
00211 <span class="preprocessor">#endif</span>
00212 <span class="preprocessor"></span>    <a class="code" href="def_8h.html#a2">NULL</a>
00213 };
00214 
00215 
00216 <span class="comment">/*</span>
00217 <span class="comment"> * Buffers for outgoing packets.  This must be accessed only from the appropriate</span>
00218 <span class="comment"> * PPP task so that it doesn't need to be protected to avoid collisions.</span>
00219 <span class="comment"> */</span>
00220 u_char outpacket_buf[NUM_PPP][PPP_MRU+PPP_HDRLEN];  
00221 
00222 
00223 <span class="comment">/*****************************/</span>
00224 <span class="comment">/*** LOCAL DATA STRUCTURES ***/</span>
00225 <span class="comment">/*****************************/</span>
00226 
00227 <span class="comment">/*</span>
00228 <span class="comment"> * FCS lookup table as calculated by genfcstab.</span>
00229 <span class="comment"> */</span>
00230 <span class="keyword">static</span> <span class="keyword">const</span> u_short fcstab[256] = {
00231     0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
00232     0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
00233     0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
00234     0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
00235     0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
00236     0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
00237     0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
00238     0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
00239     0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
00240     0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
00241     0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
00242     0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
00243     0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
00244     0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
00245     0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
00246     0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
00247     0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
00248     0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
00249     0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
00250     0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
00251     0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
00252     0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
00253     0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
00254     0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
00255     0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
00256     0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
00257     0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
00258     0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
00259     0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
00260     0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
00261     0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
00262     0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
00263 };
00264 
00265 <span class="comment">/* PPP's Asynchronous-Control-Character-Map.  The mask array is used</span>
00266 <span class="comment"> * to select the specific bit for a character. */</span>
00267 <span class="keyword">static</span> u_char pppACCMMask[] = {
00268     0x01,
00269     0x02,
00270     0x04,
00271     0x08,
00272     0x10,
00273     0x20,
00274     0x40,
00275     0x80
00276 };
00277 
00278 
00279 <span class="comment">/***********************************/</span>
00280 <span class="comment">/*** PUBLIC FUNCTION DEFINITIONS ***/</span>
00281 <span class="comment">/***********************************/</span>
00282 <span class="comment">/* Initialize the PPP subsystem. */</span>
00283 
00284 <span class="keyword">struct </span>ppp_settings ppp_settings;
00285 
00286 <span class="keywordtype">void</span> pppInit(<span class="keywordtype">void</span>)
00287 {
00288     <span class="keyword">struct </span>protent *protp;
00289     <span class="keywordtype">int</span> i, j;
00290     
00291         memset(&amp;ppp_settings, 0, <span class="keyword">sizeof</span>(ppp_settings));
00292         ppp_settings.usepeerdns = 1;
00293         ppp_settings.refuse_chap = (CHAP_SUPPORT == 0);
00294 
00295         <a class="code" href="magic_8c.html#a0">magicInit</a>();
00296 
00297     <span class="keywordflow">for</span> (i = 0; i &lt; NUM_PPP; i++) {
00298         pppControl[i].openFlag = 0;
00299         pppControl[i].netif = <a class="code" href="def_8h.html#a2">NULL</a>;
00300 
00301                 subnetMask = <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(0xffffff00);
00302     
00303         <span class="comment">/*</span>
00304 <span class="comment">         * Initialize to the standard option set.</span>
00305 <span class="comment">         */</span>
00306         <span class="keywordflow">for</span> (j = 0; (protp = ppp_protocols[j]) != <a class="code" href="def_8h.html#a2">NULL</a>; ++j)
00307             (*protp-&gt;init)(i);
00308     }
00309 
00310 <span class="preprocessor">#ifdef LINK_STATS</span>
00311 <span class="preprocessor"></span>    <span class="comment">/* Clear the statistics. */</span>
00312     memset(&amp;lwip_stats.link, 0, <span class="keyword">sizeof</span>(lwip_stats.link));
00313 <span class="preprocessor">#endif</span>
00314 <span class="preprocessor"></span>}
00315 
00316 <span class="keywordtype">void</span> pppSetAuth(<span class="keyword">const</span> <span class="keywordtype">char</span> *user, <span class="keyword">const</span> <span class="keywordtype">char</span> *passwd)
00317 {
00318         <span class="keywordflow">if</span>(user) {
00319                 strncpy(ppp_settings.user, user, <span class="keyword">sizeof</span>(ppp_settings.user)-1);
00320                 ppp_settings.user[<span class="keyword">sizeof</span>(ppp_settings.user)-1] = <span class="charliteral">'\0'</span>;
00321         } <span class="keywordflow">else</span>
00322                 ppp_settings.user[0] = <span class="charliteral">'\0'</span>;
00323 
00324         <span class="keywordflow">if</span>(passwd) {
00325                 strncpy(ppp_settings.passwd, passwd, <span class="keyword">sizeof</span>(ppp_settings.passwd)-1);
00326                 ppp_settings.passwd[<span class="keyword">sizeof</span>(ppp_settings.passwd)-1] = <span class="charliteral">'\0'</span>;
00327         } <span class="keywordflow">else</span>
00328                 ppp_settings.passwd[0] = <span class="charliteral">'\0'</span>;
00329 }
00330 
00331 <span class="comment">/* Open a new PPP connection using the given I/O device.</span>
00332 <span class="comment"> * This initializes the PPP control block but does not</span>
00333 <span class="comment"> * attempt to negotiate the LCP session.  If this port</span>
00334 <span class="comment"> * connects to a modem, the modem connection must be</span>
00335 <span class="comment"> * established before calling this.</span>
00336 <span class="comment"> * Return a new PPP connection descriptor on success or</span>
00337 <span class="comment"> * an error code (negative) on failure. */</span>
00338 <span class="keywordtype">int</span> pppOpen(<a class="code" href="sio_8h.html#a0">sio_fd_t</a> fd, <span class="keywordtype">void</span> (*linkStatusCB)(<span class="keywordtype">void</span> *ctx, <span class="keywordtype">int</span> errCode, <span class="keywordtype">void</span> *arg), <span class="keywordtype">void</span> *linkStatusCtx)
00339 {
00340     PPPControl *pc;
00341     <span class="keywordtype">int</span> pd;
00342 
00343     <span class="comment">/* Find a free PPP session descriptor. Critical region? */</span>
00344     <span class="keywordflow">for</span> (pd = 0; pd &lt; NUM_PPP &amp;&amp; pppControl[pd].openFlag != 0; pd++);
00345     <span class="keywordflow">if</span> (pd &gt;= NUM_PPP)
00346         pd = PPPERR_OPEN;
00347     <span class="keywordflow">else</span>
00348         pppControl[pd].openFlag = !0;
00349 
00350     <span class="comment">/* Launch a deamon thread. */</span>
00351     <span class="keywordflow">if</span> (pd &gt;= 0) {
00352 
00353         pppControl[pd].openFlag = 1;
00354 
00355         <a class="code" href="lcp_8h.html#a32">lcp_init</a>(pd);
00356         pc = &amp;pppControl[pd];
00357         pc-&gt;fd = fd;
00358         pc-&gt;kill_link = 0;
00359         pc-&gt;sig_hup = 0;
00360         pc-&gt;if_up = 0;
00361         pc-&gt;errCode = 0;
00362         pc-&gt;inState = PDIDLE;
00363         pc-&gt;inHead = <a class="code" href="def_8h.html#a2">NULL</a>;
00364         pc-&gt;inTail = <a class="code" href="def_8h.html#a2">NULL</a>;
00365         pc-&gt;inEscaped = 0;
00366         pc-&gt;lastXMit = 0;
00367 
00368 <span class="preprocessor">#if VJ_SUPPORT &gt; 0</span>
00369 <span class="preprocessor"></span>        pc-&gt;vjEnabled = 0;
00370         <a class="code" href="vj_8h.html#a19">vj_compress_init</a>(&amp;pc-&gt;vjComp);
00371 <span class="preprocessor">#endif</span>
00372 <span class="preprocessor"></span>
00373         <span class="comment">/* </span>
00374 <span class="comment">         * Default the in and out accm so that escape and flag characters</span>
00375 <span class="comment">         * are always escaped. </span>
00376 <span class="comment">         */</span>
00377         memset(pc-&gt;inACCM, 0, <span class="keyword">sizeof</span>(ext_accm));
00378         pc-&gt;inACCM[15] = 0x60;
00379         memset(pc-&gt;outACCM, 0, <span class="keyword">sizeof</span>(ext_accm));
00380         pc-&gt;outACCM[15] = 0x60;
00381 
00382         pc-&gt;linkStatusCB = linkStatusCB;
00383         pc-&gt;linkStatusCtx = linkStatusCtx;
00384 
00385         <a class="code" href="sys_8h.html#a22">sys_thread_new</a>(pppMain, (<span class="keywordtype">void</span>*)pd, PPP_THREAD_PRIO);
00386         <span class="keywordflow">if</span>(!linkStatusCB) {
00387                 <span class="keywordflow">while</span>(pd &gt;= 0 &amp;&amp; !pc-&gt;if_up) {
00388                         <a class="code" href="sys_8c.html#a6">sys_msleep</a>(500);
00389                         <span class="keywordflow">if</span> (<a class="code" href="lcp_8h.html#a18">lcp_phase</a>[pd] == <a class="code" href="lcp_8h.html#a38a25">PHASE_DEAD</a>) {
00390                                 pppClose(pd);
00391                                 <span class="keywordflow">if</span> (pc-&gt;errCode)
00392                                         pd = pc-&gt;errCode;
00393                                 <span class="keywordflow">else</span>
00394                                         pd = PPPERR_CONNECT;
00395                         }
00396                 }
00397         }
00398     }
00399     <span class="keywordflow">return</span> pd;
00400 }
00401 
00402 <span class="comment">/* Close a PPP connection and release the descriptor. </span>
00403 <span class="comment"> * Any outstanding packets in the queues are dropped.</span>
00404 <span class="comment"> * Return 0 on success, an error code on failure. */</span>
00405 <span class="keywordtype">int</span> pppClose(<span class="keywordtype">int</span> pd)
00406 {
00407     PPPControl *pc = &amp;pppControl[pd];
00408     <span class="keywordtype">int</span> st = 0;
00409 
00410     <span class="comment">/* Disconnect */</span>
00411     pc-&gt;kill_link = !0;
00412     pppMainWakeup(pd);
00413     
00414     <span class="keywordflow">if</span>(!pc-&gt;linkStatusCB) {
00415             <span class="keywordflow">while</span>(st &gt;= 0 &amp;&amp; <a class="code" href="lcp_8h.html#a18">lcp_phase</a>[pd] != <a class="code" href="lcp_8h.html#a38a25">PHASE_DEAD</a>) {
00416                     <a class="code" href="sys_8c.html#a6">sys_msleep</a>(500);
00417                     <span class="keywordflow">break</span>;
00418             }
00419     }
00420     <span class="keywordflow">return</span> st;
00421 }
00422 
00423 <span class="comment">/* This function is called when carrier is lost on the PPP channel. */</span>
00424 <span class="keywordtype">void</span> pppSigHUP(<span class="keywordtype">int</span> pd)
00425 {
00426     PPPControl *pc = &amp;pppControl[pd];
00427 
00428     pc-&gt;sig_hup = 1;
00429     pppMainWakeup(pd);
00430 }
00431 
00432 <span class="keyword">static</span> <span class="keywordtype">void</span> nPut(PPPControl *pc, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *nb)
00433 {
00434         <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *b;
00435         <span class="keywordtype">int</span> c;
00436 
00437         <span class="keywordflow">for</span>(b = nb; b != <a class="code" href="def_8h.html#a2">NULL</a>; b = b-&gt;next) {
00438             <span class="keywordflow">if</span>((c = <a class="code" href="sio_8h.html#a5">sio_write</a>(pc-&gt;fd, b-&gt;payload, b-&gt;len)) != b-&gt;len) {
00439                 <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING,
00440                             <span class="stringliteral">"PPP nPut: incomplete sio_write(%d,, %u) = %d\n"</span>, pc-&gt;fd, b-&gt;len, c));
00441 <span class="preprocessor">#ifdef LINK_STATS</span>
00442 <span class="preprocessor"></span>                lwip_stats.link.err++;
00443 <span class="preprocessor">#endif </span><span class="comment">/* LINK_STATS */</span>
00444                 pc-&gt;lastXMit = 0; <span class="comment">/* prepend PPP_FLAG to next packet */</span>
00445                 <span class="keywordflow">break</span>;
00446             }
00447         }
00448         <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(nb);
00449 
00450 <span class="preprocessor">#ifdef LINK_STATS</span>
00451 <span class="preprocessor"></span>        lwip_stats.link.xmit++;
00452 <span class="preprocessor">#endif </span><span class="comment">/* LINK_STATS */</span>
00453 }
00454 
00455 <span class="comment">/* </span>
00456 <span class="comment"> * pppAppend - append given character to end of given pbuf.  If outACCM</span>
00457 <span class="comment"> * is not NULL and the character needs to be escaped, do so.</span>
00458 <span class="comment"> * If pbuf is full, append another.</span>
00459 <span class="comment"> * Return the current pbuf.</span>
00460 <span class="comment"> */</span>
00461 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *pppAppend(u_char c, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *nb, ext_accm *outACCM)
00462 {
00463     <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *tb = nb;
00464     
00465     <span class="comment">/* Make sure there is room for the character and an escape code.</span>
00466 <span class="comment">     * Sure we don't quite fill the buffer if the character doesn't</span>
00467 <span class="comment">     * get escaped but is one character worth complicating this? */</span>
00468     <span class="comment">/* Note: We assume no packet header. */</span>
00469     <span class="keywordflow">if</span> (nb &amp;&amp; (<a class="code" href="opt_8h.html#a15">PBUF_POOL_BUFSIZE</a> - nb-&gt;len) &lt; 2) {
00470         tb = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(PBUF_RAW, 0, PBUF_POOL);
00471         <span class="keywordflow">if</span> (tb) {
00472             nb-&gt;next = tb;
00473         }
00474 <span class="preprocessor">#ifdef LINK_STATS</span>
00475 <span class="preprocessor"></span>        <span class="keywordflow">else</span> {
00476             lwip_stats.link.memerr++;
00477         }
00478 <span class="preprocessor">#endif </span><span class="comment">/* LINK_STATS */</span>
00479         nb = tb;
00480     }
00481     <span class="keywordflow">if</span> (nb) {
00482         <span class="keywordflow">if</span> (outACCM &amp;&amp; ESCAPE_P(*outACCM, c)) {
00483             *((u_char*)nb-&gt;payload + nb-&gt;len++) = PPP_ESCAPE;
00484             *((u_char*)nb-&gt;payload + nb-&gt;len++) = c ^ PPP_TRANS;
00485         }
00486         <span class="keywordflow">else</span>
00487             *((u_char*)nb-&gt;payload + nb-&gt;len++) = c;
00488     }
00489         
00490     <span class="keywordflow">return</span> tb;
00491 }
00492 
00493 <span class="comment">/* Send a packet on the given connection. */</span>
00494 <span class="keyword">static</span> <a class="code" href="err_8h.html#a13">err_t</a> pppifOutput(<span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *pb, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *ipaddr)
00495 {
00496         <span class="keywordtype">int</span> pd = (<span class="keywordtype">int</span>)netif-&gt;<a class="code" href="structnetif.html#o7">state</a>;
00497         u_short protocol = PPP_IP;
00498     PPPControl *pc = &amp;pppControl[pd];
00499     u_int fcsOut = PPP_INITFCS;
00500     <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *headMB = <a class="code" href="def_8h.html#a2">NULL</a>, *tailMB = <a class="code" href="def_8h.html#a2">NULL</a>, *p;
00501     u_char c;
00502 
00503         (<span class="keywordtype">void</span>)ipaddr;
00504 
00505     <span class="comment">/* Validate parameters. */</span>
00506     <span class="comment">/* We let any protocol value go through - it can't hurt us</span>
00507 <span class="comment">     * and the peer will just drop it if it's not accepting it. */</span>
00508         <span class="keywordflow">if</span> (pd &lt; 0 || pd &gt;= NUM_PPP || !pc-&gt;openFlag || !pb) {
00509         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"pppifOutput[%d]: bad parms prot=%d pb=%p\n"</span>,
00510                     pd, protocol, pb));
00511 <span class="preprocessor">#ifdef LINK_STATS</span>
00512 <span class="preprocessor"></span>                lwip_stats.link.opterr++;
00513                 lwip_stats.link.drop++;
00514 <span class="preprocessor">#endif</span>
00515 <span class="preprocessor"></span>                <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a8">ERR_ARG</a>;
00516         }
00517 
00518     <span class="comment">/* Check that the link is up. */</span>
00519         <span class="keywordflow">if</span> (<a class="code" href="lcp_8h.html#a18">lcp_phase</a>[pd] == <a class="code" href="lcp_8h.html#a38a25">PHASE_DEAD</a>) {
00520         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_ERR, <span class="stringliteral">"pppifOutput[%d]: link not up\n"</span>, pd));
00521 <span class="preprocessor">#ifdef LINK_STATS</span>
00522 <span class="preprocessor"></span>                lwip_stats.link.rterr++;
00523                 lwip_stats.link.drop++;
00524 <span class="preprocessor">#endif</span>
00525 <span class="preprocessor"></span>                <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a9">ERR_RTE</a>;
00526         }
00527 
00528     <span class="comment">/* Grab an output buffer. */</span>
00529         headMB = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(PBUF_RAW, 0, PBUF_POOL);
00530     <span class="keywordflow">if</span> (headMB == <a class="code" href="def_8h.html#a2">NULL</a>) {
00531         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"pppifOutput[%d]: first alloc fail\n"</span>, pd));
00532 <span class="preprocessor">#ifdef LINK_STATS</span>
00533 <span class="preprocessor"></span>                lwip_stats.link.memerr++;
00534                 lwip_stats.link.drop++;
00535 <span class="preprocessor">#endif </span><span class="comment">/* LINK_STATS */</span>
00536         <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a1">ERR_MEM</a>;
00537     }
00538         
00539 <span class="preprocessor">#if VJ_SUPPORT &gt; 0</span>
00540 <span class="preprocessor"></span>    <span class="comment">/* </span>
00541 <span class="comment">     * Attempt Van Jacobson header compression if VJ is configured and</span>
00542 <span class="comment">     * this is an IP packet. </span>
00543 <span class="comment">     */</span>
00544     <span class="keywordflow">if</span> (protocol == PPP_IP &amp;&amp; pc-&gt;vjEnabled) {
00545         <span class="keywordflow">switch</span> (<a class="code" href="vj_8h.html#a20">vj_compress_tcp</a>(&amp;pc-&gt;vjComp, pb)) {
00546         <span class="keywordflow">case</span> <a class="code" href="vj_8h.html#a2">TYPE_IP</a>:
00547             <span class="comment">/* No change...</span>
00548 <span class="comment">            protocol = PPP_IP_PROTOCOL;</span>
00549 <span class="comment">             */</span>
00550             <span class="keywordflow">break</span>;
00551         <span class="keywordflow">case</span> <a class="code" href="vj_8h.html#a4">TYPE_COMPRESSED_TCP</a>:
00552             protocol = PPP_VJC_COMP;
00553             <span class="keywordflow">break</span>;
00554         <span class="keywordflow">case</span> <a class="code" href="vj_8h.html#a3">TYPE_UNCOMPRESSED_TCP</a>:
00555             protocol = PPP_VJC_UNCOMP;
00556             <span class="keywordflow">break</span>;
00557         <span class="keywordflow">default</span>:
00558             <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"pppifOutput[%d]: bad IP packet\n"</span>, pd));
00559 <span class="preprocessor">#ifdef LINK_STATS</span>
00560 <span class="preprocessor"></span>                        lwip_stats.link.proterr++;
00561                         lwip_stats.link.drop++;
00562 <span class="preprocessor">#endif</span>
00563 <span class="preprocessor"></span>                <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(headMB);
00564             <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a7">ERR_VAL</a>;
00565         }
00566     }
00567 <span class="preprocessor">#endif</span>
00568 <span class="preprocessor"></span>        
00569     tailMB = headMB;
00570         
00571     <span class="comment">/* Build the PPP header. */</span>
00572     <span class="keywordflow">if</span> ((<a class="code" href="sys_8h.html#a16">sys_jiffies</a>() - pc-&gt;lastXMit) &gt;= PPP_MAXIDLEFLAG)
00573         tailMB = pppAppend(PPP_FLAG, tailMB, NULL);
00574     pc-&gt;lastXMit = <a class="code" href="sys_8h.html#a16">sys_jiffies</a>();
00575     <span class="keywordflow">if</span> (!pc-&gt;accomp) {
00576         fcsOut = PPP_FCS(fcsOut, PPP_ALLSTATIONS);
00577         tailMB = pppAppend(PPP_ALLSTATIONS, tailMB, &amp;pc-&gt;outACCM);
00578         fcsOut = PPP_FCS(fcsOut, PPP_UI);
00579         tailMB = pppAppend(PPP_UI, tailMB, &amp;pc-&gt;outACCM);
00580     }
00581     <span class="keywordflow">if</span> (!pc-&gt;pcomp || protocol &gt; 0xFF) {
00582         c = (protocol &gt;&gt; 8) &amp; 0xFF;
00583         fcsOut = PPP_FCS(fcsOut, c);
00584         tailMB = pppAppend(c, tailMB, &amp;pc-&gt;outACCM);
00585     }
00586     c = protocol &amp; 0xFF;
00587     fcsOut = PPP_FCS(fcsOut, c);
00588     tailMB = pppAppend(c, tailMB, &amp;pc-&gt;outACCM);
00589     
00590     <span class="comment">/* Load packet. */</span>
00591         <span class="keywordflow">for</span>(p = pb; p; p = p-&gt;<a class="code" href="structpbuf.html#o0">next</a>) {
00592         <span class="keywordtype">int</span> n;
00593         u_char *sPtr;
00594 
00595         sPtr = (u_char*)p-&gt;payload;
00596         n = p-&gt;len;
00597         <span class="keywordflow">while</span> (n-- &gt; 0) {
00598             c = *sPtr++;
00599             
00600             <span class="comment">/* Update FCS before checking for special characters. */</span>
00601             fcsOut = PPP_FCS(fcsOut, c);
00602             
00603             <span class="comment">/* Copy to output buffer escaping special characters. */</span>
00604             tailMB = pppAppend(c, tailMB, &amp;pc-&gt;outACCM);
00605         }
00606     }
00607 
00608     <span class="comment">/* Add FCS and trailing flag. */</span>
00609     c = ~fcsOut &amp; 0xFF;
00610     tailMB = pppAppend(c, tailMB, &amp;pc-&gt;outACCM);
00611     c = (~fcsOut &gt;&gt; 8) &amp; 0xFF;
00612     tailMB = pppAppend(c, tailMB, &amp;pc-&gt;outACCM);
00613     tailMB = pppAppend(PPP_FLAG, tailMB, NULL);
00614         
00615     <span class="comment">/* If we failed to complete the packet, throw it away. */</span>
00616     <span class="keywordflow">if</span> (!tailMB) {
00617         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING,
00618                     <span class="stringliteral">"pppifOutput[%d]: Alloc err - dropping proto=%d\n"</span>, 
00619                     pd, protocol));
00620         <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(headMB);
00621 <span class="preprocessor">#ifdef LINK_STATS</span>
00622 <span class="preprocessor"></span>                lwip_stats.link.memerr++;
00623                 lwip_stats.link.drop++;
00624 <span class="preprocessor">#endif</span>
00625 <span class="preprocessor"></span>        <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a1">ERR_MEM</a>;
00626     }
00627 
00628         <span class="comment">/* Send it. */</span>
00629     <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"pppifOutput[%d]: proto=0x%04X\n"</span>, pd, protocol));
00630 
00631     nPut(pc, headMB);
00632 
00633     <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00634 }
00635 
00636 <span class="comment">/* Get and set parameters for the given connection.</span>
00637 <span class="comment"> * Return 0 on success, an error code on failure. */</span>
00638 <span class="keywordtype">int</span>  pppIOCtl(<span class="keywordtype">int</span> pd, <span class="keywordtype">int</span> cmd, <span class="keywordtype">void</span> *arg)
00639 {
00640     PPPControl *pc = &amp;pppControl[pd];
00641     <span class="keywordtype">int</span> st = 0;
00642 
00643     <span class="keywordflow">if</span> (pd &lt; 0 || pd &gt;= NUM_PPP)
00644         st = PPPERR_PARAM;
00645     <span class="keywordflow">else</span> {
00646         <span class="keywordflow">switch</span>(cmd) {
00647         <span class="keywordflow">case</span> PPPCTLG_UPSTATUS:      <span class="comment">/* Get the PPP up status. */</span>
00648             <span class="keywordflow">if</span> (arg) 
00649                 *(<span class="keywordtype">int</span> *)arg = (<span class="keywordtype">int</span>)(pc-&gt;if_up);
00650             <span class="keywordflow">else</span>
00651                 st = PPPERR_PARAM;
00652             <span class="keywordflow">break</span>;
00653         <span class="keywordflow">case</span> PPPCTLS_ERRCODE:       <span class="comment">/* Set the PPP error code. */</span>
00654             <span class="keywordflow">if</span> (arg) 
00655                 pc-&gt;errCode = *(<span class="keywordtype">int</span> *)arg;
00656             <span class="keywordflow">else</span>
00657                 st = PPPERR_PARAM;
00658             <span class="keywordflow">break</span>;
00659         <span class="keywordflow">case</span> PPPCTLG_ERRCODE:       <span class="comment">/* Get the PPP error code. */</span>
00660             <span class="keywordflow">if</span> (arg) 
00661                 *(<span class="keywordtype">int</span> *)arg = (<span class="keywordtype">int</span>)(pc-&gt;errCode);
00662             <span class="keywordflow">else</span>
00663                 st = PPPERR_PARAM;
00664             <span class="keywordflow">break</span>;
00665         <span class="keywordflow">case</span> PPPCTLG_FD:
00666             <span class="keywordflow">if</span> (arg) 
00667                 *(<a class="code" href="sio_8h.html#a0">sio_fd_t</a> *)arg = pc-&gt;fd;
00668             <span class="keywordflow">else</span>
00669                 st = PPPERR_PARAM;
00670             <span class="keywordflow">break</span>;
00671         <span class="keywordflow">default</span>:
00672             st = PPPERR_PARAM;
00673             <span class="keywordflow">break</span>;
00674         }
00675     }
00676     
00677     <span class="keywordflow">return</span> st;
00678 }
00679 
00680 <span class="comment">/*</span>
00681 <span class="comment"> * Return the Maximum Transmission Unit for the given PPP connection.</span>
00682 <span class="comment"> */</span>
00683 u_int pppMTU(<span class="keywordtype">int</span> pd)
00684 {
00685     PPPControl *pc = &amp;pppControl[pd];
00686     u_int st;
00687     
00688     <span class="comment">/* Validate parameters. */</span>
00689     <span class="keywordflow">if</span> (pd &lt; 0 || pd &gt;= NUM_PPP || !pc-&gt;openFlag)
00690         st = 0;
00691     <span class="keywordflow">else</span>
00692         st = pc-&gt;mtu;
00693         
00694     <span class="keywordflow">return</span> st;
00695 }
00696 
00697 <span class="comment">/*</span>
00698 <span class="comment"> * Write n characters to a ppp link.</span>
00699 <span class="comment"> *  RETURN: &gt;= 0 Number of characters written</span>
00700 <span class="comment"> *           -1 Failed to write to device</span>
00701 <span class="comment"> */</span>
00702 <span class="keywordtype">int</span> pppWrite(<span class="keywordtype">int</span> pd, <span class="keyword">const</span> u_char *s, <span class="keywordtype">int</span> n)
00703 {
00704     PPPControl *pc = &amp;pppControl[pd];
00705     u_char c;
00706     u_int fcsOut = PPP_INITFCS;
00707     <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *headMB = <a class="code" href="def_8h.html#a2">NULL</a>, *tailMB;
00708         headMB = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(PBUF_RAW, 0, PBUF_POOL);
00709     <span class="keywordflow">if</span> (headMB == <a class="code" href="def_8h.html#a2">NULL</a>) {
00710 <span class="preprocessor">#ifdef LINK_STATS</span>
00711 <span class="preprocessor"></span>                lwip_stats.link.memerr++;
00712                 lwip_stats.link.proterr++;
00713 <span class="preprocessor">#endif </span><span class="comment">/* LINK_STATS */</span>
00714                 <span class="keywordflow">return</span> PPPERR_ALLOC;
00715     }
00716 
00717     tailMB = headMB;
00718         
00719     <span class="comment">/* If the link has been idle, we'll send a fresh flag character to</span>
00720 <span class="comment">     * flush any noise. */</span>
00721     <span class="keywordflow">if</span> ((<a class="code" href="sys_8h.html#a16">sys_jiffies</a>() - pc-&gt;lastXMit) &gt;= PPP_MAXIDLEFLAG)
00722         tailMB = pppAppend(PPP_FLAG, tailMB, NULL);
00723     pc-&gt;lastXMit = <a class="code" href="sys_8h.html#a16">sys_jiffies</a>();
00724      
00725     <span class="comment">/* Load output buffer. */</span>
00726     <span class="keywordflow">while</span> (n-- &gt; 0) {
00727         c = *s++;
00728         
00729         <span class="comment">/* Update FCS before checking for special characters. */</span>
00730         fcsOut = PPP_FCS(fcsOut, c);
00731         
00732         <span class="comment">/* Copy to output buffer escaping special characters. */</span>
00733         tailMB = pppAppend(c, tailMB, &amp;pc-&gt;outACCM);
00734     }
00735     
00736     <span class="comment">/* Add FCS and trailing flag. */</span>
00737     c = ~fcsOut &amp; 0xFF;
00738     tailMB = pppAppend(c, tailMB, &amp;pc-&gt;outACCM);
00739     c = (~fcsOut &gt;&gt; 8) &amp; 0xFF;
00740     tailMB = pppAppend(c, tailMB, &amp;pc-&gt;outACCM);
00741     tailMB = pppAppend(PPP_FLAG, tailMB, NULL);
00742         
00743     <span class="comment">/* If we failed to complete the packet, throw it away.</span>
00744 <span class="comment">     * Otherwise send it. */</span>
00745     <span class="keywordflow">if</span> (!tailMB) {
00746                 <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING,
00747                 <span class="stringliteral">"pppWrite[%d]: Alloc err - dropping pbuf len=%d\n"</span>, pd, headMB-&gt;len));
00748 <span class="comment">/*                "pppWrite[%d]: Alloc err - dropping %d:%.*H", pd, headMB-&gt;len, LWIP_MIN(headMB-&gt;len * 2, 40), headMB-&gt;payload)); */</span>
00749                 <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(headMB);
00750 <span class="preprocessor">#ifdef LINK_STATS</span>
00751 <span class="preprocessor"></span>                lwip_stats.link.memerr++;
00752                 lwip_stats.link.proterr++;
00753 <span class="preprocessor">#endif </span><span class="comment">/* LINK_STATS */</span>
00754                 <span class="keywordflow">return</span> PPPERR_ALLOC;
00755         }
00756 
00757     <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"pppWrite[%d]: len=%d\n"</span>, pd, headMB-&gt;len));
00758 <span class="comment">/*     "pppWrite[%d]: %d:%.*H", pd, headMB-&gt;len, LWIP_MIN(headMB-&gt;len * 2, 40), headMB-&gt;payload)); */</span>
00759     nPut(pc, headMB);
00760 
00761     <span class="keywordflow">return</span> PPPERR_NONE;
00762 }
00763 
00764 <span class="comment">/*</span>
00765 <span class="comment"> * ppp_send_config - configure the transmit characteristics of</span>
00766 <span class="comment"> * the ppp interface.</span>
00767 <span class="comment"> */</span>
00768 <span class="keywordtype">void</span> ppp_send_config(
00769     <span class="keywordtype">int</span> unit, 
00770     <span class="keywordtype">int</span> mtu,
00771     u32_t asyncmap,
00772     <span class="keywordtype">int</span> pcomp, 
00773     <span class="keywordtype">int</span> accomp
00774 )
00775 {
00776     PPPControl *pc = &amp;pppControl[unit];
00777     <span class="keywordtype">int</span> i;
00778     
00779     pc-&gt;mtu = mtu;
00780     pc-&gt;pcomp = pcomp;
00781     pc-&gt;accomp = accomp;
00782     
00783     <span class="comment">/* Load the ACCM bits for the 32 control codes. */</span>
00784     <span class="keywordflow">for</span> (i = 0; i &lt; 32/8; i++)
00785         pc-&gt;outACCM[i] = (u_char)((asyncmap &gt;&gt; (8 * i)) &amp; 0xFF);
00786     <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ppp_send_config[%d]: outACCM=%X %X %X %X\n"</span>,
00787                 unit,
00788                 pc-&gt;outACCM[0], pc-&gt;outACCM[1], pc-&gt;outACCM[2], pc-&gt;outACCM[3]));
00789 }
00790 
00791 
00792 <span class="comment">/*</span>
00793 <span class="comment"> * ppp_set_xaccm - set the extended transmit ACCM for the interface.</span>
00794 <span class="comment"> */</span>
00795 <span class="keywordtype">void</span> ppp_set_xaccm(<span class="keywordtype">int</span> unit, ext_accm *accm)
00796 {
00797     memcpy(pppControl[unit].outACCM, accm, <span class="keyword">sizeof</span>(ext_accm));
00798     <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ppp_set_xaccm[%d]: outACCM=%X %X %X %X\n"</span>,
00799                 unit,
00800                 pppControl[unit].outACCM[0],
00801                 pppControl[unit].outACCM[1],
00802                 pppControl[unit].outACCM[2],
00803                 pppControl[unit].outACCM[3]));
00804 }
00805 
00806 
00807 <span class="comment">/*</span>
00808 <span class="comment"> * ppp_recv_config - configure the receive-side characteristics of</span>
00809 <span class="comment"> * the ppp interface.</span>
00810 <span class="comment"> */</span>
00811 <span class="keywordtype">void</span> ppp_recv_config(
00812     <span class="keywordtype">int</span> unit, 
00813     <span class="keywordtype">int</span> mru,
00814     u32_t asyncmap,
00815     <span class="keywordtype">int</span> pcomp, 
00816     <span class="keywordtype">int</span> accomp
00817 )
00818 {
00819     PPPControl *pc = &amp;pppControl[unit];
00820     <span class="keywordtype">int</span> i;
00821     
00822         (<span class="keywordtype">void</span>)accomp;
00823         (<span class="keywordtype">void</span>)pcomp;
00824         (<span class="keywordtype">void</span>)mru;
00825 
00826     <span class="comment">/* Load the ACCM bits for the 32 control codes. */</span>
00827     <span class="keywordflow">for</span> (i = 0; i &lt; 32 / 8; i++)
00828         pc-&gt;inACCM[i] = (u_char)(asyncmap &gt;&gt; (i * 8));
00829     <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"ppp_recv_config[%d]: inACCM=%X %X %X %X\n"</span>,
00830                 unit,
00831                 pc-&gt;inACCM[0], pc-&gt;inACCM[1], pc-&gt;inACCM[2], pc-&gt;inACCM[3]));
00832 }
00833 
00834 <span class="preprocessor">#if 0</span>
00835 <span class="preprocessor"></span><span class="comment">/*</span>
00836 <span class="comment"> * ccp_test - ask kernel whether a given compression method</span>
00837 <span class="comment"> * is acceptable for use.  Returns 1 if the method and parameters</span>
00838 <span class="comment"> * are OK, 0 if the method is known but the parameters are not OK</span>
00839 <span class="comment"> * (e.g. code size should be reduced), or -1 if the method is unknown.</span>
00840 <span class="comment"> */</span>
00841 <span class="keywordtype">int</span> ccp_test(
00842     <span class="keywordtype">int</span> unit, 
00843     <span class="keywordtype">int</span> opt_len, 
00844     <span class="keywordtype">int</span> for_transmit,
00845     u_char *opt_ptr
00846 )
00847 {
00848     <span class="keywordflow">return</span> 0;   <span class="comment">/* XXX Currently no compression. */</span>
00849 }
00850 
00851 <span class="comment">/*</span>
00852 <span class="comment"> * ccp_flags_set - inform kernel about the current state of CCP.</span>
00853 <span class="comment"> */</span>
00854 <span class="keywordtype">void</span> ccp_flags_set(<span class="keywordtype">int</span> unit, <span class="keywordtype">int</span> isopen, <span class="keywordtype">int</span> isup)
00855 {
00856     <span class="comment">/* XXX */</span>
00857 }
00858 
00859 <span class="comment">/*</span>
00860 <span class="comment"> * ccp_fatal_error - returns 1 if decompression was disabled as a</span>
00861 <span class="comment"> * result of an error detected after decompression of a packet,</span>
00862 <span class="comment"> * 0 otherwise.  This is necessary because of patent nonsense.</span>
00863 <span class="comment"> */</span>
00864 <span class="keywordtype">int</span> ccp_fatal_error(<span class="keywordtype">int</span> unit)
00865 {
00866     <span class="comment">/* XXX */</span>
00867     <span class="keywordflow">return</span> 0;
00868 }
00869 <span class="preprocessor">#endif</span>
00870 <span class="preprocessor"></span>
00871 <span class="comment">/*</span>
00872 <span class="comment"> * get_idle_time - return how long the link has been idle.</span>
00873 <span class="comment"> */</span>
00874 <span class="keywordtype">int</span> get_idle_time(<span class="keywordtype">int</span> u, <span class="keyword">struct</span> ppp_idle *<a class="code" href="structip.html">ip</a>)
00875 {   
00876     <span class="comment">/* XXX */</span>
00877         (<span class="keywordtype">void</span>)u;
00878         (<span class="keywordtype">void</span>)ip;
00879 
00880     <span class="keywordflow">return</span> 0;
00881 }
00882 
00883 
00884 <span class="comment">/*</span>
00885 <span class="comment"> * Return user specified netmask, modified by any mask we might determine</span>
00886 <span class="comment"> * for address `addr' (in network byte order).</span>
00887 <span class="comment"> * Here we scan through the system's list of interfaces, looking for</span>
00888 <span class="comment"> * any non-point-to-point interfaces which might appear to be on the same</span>
00889 <span class="comment"> * network as `addr'.  If we find any, we OR in their netmask to the</span>
00890 <span class="comment"> * user-specified netmask.</span>
00891 <span class="comment"> */</span>
00892 u32_t GetMask(u32_t addr)
00893 {
00894     u32_t mask, nmask;
00895     
00896     <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(addr);
00897     <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a4">IN_CLASSA</a>(addr))    <span class="comment">/* determine network mask for address class */</span>
00898         nmask = <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a5">IN_CLASSA_NET</a>;
00899     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a9">IN_CLASSB</a>(addr))
00900         nmask = <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a10">IN_CLASSB_NET</a>;
00901     <span class="keywordflow">else</span>
00902         nmask = <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a15">IN_CLASSC_NET</a>;
00903     <span class="comment">/* class D nets are disallowed by bad_ip_adrs */</span>
00904     mask = subnetMask | <a class="code" href="ipv4_2lwip_2inet_8h.html#a2">htonl</a>(nmask);
00905     
00906     <span class="comment">/* XXX</span>
00907 <span class="comment">     * Scan through the system's network interfaces.</span>
00908 <span class="comment">     * Get each netmask and OR them into our mask.</span>
00909 <span class="comment">     */</span>
00910     
00911     <span class="keywordflow">return</span> mask;
00912 }
00913 
00914 <span class="comment">/*</span>
00915 <span class="comment"> * sifvjcomp - config tcp header compression</span>
00916 <span class="comment"> */</span>
00917 <span class="keywordtype">int</span> sifvjcomp(
00918     <span class="keywordtype">int</span> pd, 
00919     <span class="keywordtype">int</span> vjcomp, 
00920     <span class="keywordtype">int</span> cidcomp, 
00921     <span class="keywordtype">int</span> maxcid
00922 )
00923 {
00924 <span class="preprocessor">#if VJ_SUPPORT &gt; 0</span>
00925 <span class="preprocessor"></span>    PPPControl *pc = &amp;pppControl[pd];
00926     
00927     pc-&gt;vjEnabled = vjcomp;
00928     pc-&gt;vjComp.compressSlot = cidcomp;
00929     pc-&gt;vjComp.maxSlotIndex = maxcid;
00930     <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"sifvjcomp: VJ compress enable=%d slot=%d max slot=%d\n"</span>,
00931                 vjcomp, cidcomp, maxcid));
00932 <span class="preprocessor">#endif</span>
00933 <span class="preprocessor"></span>
00934     <span class="keywordflow">return</span> 0;
00935 }
00936 
00937 <span class="comment">/*</span>
00938 <span class="comment"> * pppifNetifInit - netif init callback</span>
00939 <span class="comment"> */</span>
00940 <span class="keyword">static</span> <a class="code" href="err_8h.html#a13">err_t</a> pppifNetifInit(<span class="keyword">struct</span> netif *netif)
00941 {
00942         netif-&gt;<a class="code" href="structnetif.html#o11">name</a>[0] = <span class="charliteral">'p'</span>;
00943         netif-&gt;<a class="code" href="structnetif.html#o11">name</a>[1] = <span class="charliteral">'p'</span>;
00944         netif-&gt;<a class="code" href="structnetif.html#o5">output</a> = pppifOutput;
00945         netif-&gt;<a class="code" href="structnetif.html#o10">mtu</a> = pppMTU((<span class="keywordtype">int</span>)netif-&gt;<a class="code" href="structnetif.html#o7">state</a>);
00946         <span class="keywordflow">return</span> <a class="code" href="err_8h.html#a0">ERR_OK</a>;
00947 }
00948 
00949 
00950 <span class="comment">/*</span>
00951 <span class="comment"> * sifup - Config the interface up and enable IP packets to pass.</span>
00952 <span class="comment"> */</span>
00953 <span class="keywordtype">int</span> sifup(<span class="keywordtype">int</span> pd)
00954 {
00955     PPPControl *pc = &amp;pppControl[pd];
00956     <span class="keywordtype">int</span> st = 1;
00957     
00958     <span class="keywordflow">if</span> (pd &lt; 0 || pd &gt;= NUM_PPP || !pc-&gt;openFlag) {
00959         st = 0;
00960         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"sifup[%d]: bad parms\n"</span>, pd));
00961     } <span class="keywordflow">else</span> {
00962                 <span class="keywordflow">if</span>(pc-&gt;netif)
00963                         <a class="code" href="netif_8c.html#a4">netif_remove</a>(pc-&gt;netif);
00964                 pc-&gt;netif = <a class="code" href="netif_8c.html#a2">netif_add</a>(&amp;pc-&gt;addrs.our_ipaddr, &amp;pc-&gt;addrs.netmask, &amp;pc-&gt;addrs.his_ipaddr, (<span class="keywordtype">void</span> *)pd, pppifNetifInit, ip_input);
00965                 <span class="keywordflow">if</span>(pc-&gt;netif) {
00966                 pc-&gt;if_up = 1;
00967                 pc-&gt;errCode = PPPERR_NONE;
00968 
00969                         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_DEBUG, <span class="stringliteral">"sifup: unit %d: linkStatusCB=%lx errCode=%d\n"</span>, pd, pc-&gt;linkStatusCB, pc-&gt;errCode));
00970                         <span class="keywordflow">if</span>(pc-&gt;linkStatusCB)
00971                                 pc-&gt;linkStatusCB(pc-&gt;linkStatusCtx, pc-&gt;errCode, &amp;pc-&gt;addrs);
00972                 } <span class="keywordflow">else</span> {
00973                 st = 0;
00974                 <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_ERR, <span class="stringliteral">"sifup[%d]: netif_add failed\n"</span>, pd));
00975                 }
00976     }
00977 
00978     <span class="keywordflow">return</span> st;
00979 }
00980 
00981 <span class="comment">/*</span>
00982 <span class="comment"> * sifnpmode - Set the mode for handling packets for a given NP.</span>
00983 <span class="comment"> */</span>
00984 <span class="keywordtype">int</span> sifnpmode(<span class="keywordtype">int</span> u, <span class="keywordtype">int</span> proto, <span class="keyword">enum</span> NPmode mode)
00985 {
00986         (<span class="keywordtype">void</span>)u;
00987         (<span class="keywordtype">void</span>)proto;
00988         (<span class="keywordtype">void</span>)mode;
00989     <span class="keywordflow">return</span> 0;
00990 }
00991 
00992 <span class="comment">/*</span>
00993 <span class="comment"> * sifdown - Config the interface down and disable IP.</span>
00994 <span class="comment"> */</span>
00995 <span class="keywordtype">int</span> sifdown(<span class="keywordtype">int</span> pd)
00996 {
00997     PPPControl *pc = &amp;pppControl[pd];
00998     <span class="keywordtype">int</span> st = 1;
00999     
01000     <span class="keywordflow">if</span> (pd &lt; 0 || pd &gt;= NUM_PPP || !pc-&gt;openFlag) {
01001         st = 0;
01002         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"sifdown[%d]: bad parms\n"</span>, pd));
01003     } <span class="keywordflow">else</span> {
01004         pc-&gt;if_up = 0;
01005                 <span class="keywordflow">if</span>(pc-&gt;netif)
01006                         <a class="code" href="netif_8c.html#a4">netif_remove</a>(pc-&gt;netif);
01007                 pc-&gt;netif = <a class="code" href="def_8h.html#a2">NULL</a>;
01008                 <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_DEBUG, <span class="stringliteral">"sifdown: unit %d: linkStatusCB=%lx errCode=%d\n"</span>, pd, pc-&gt;linkStatusCB, pc-&gt;errCode));
01009                 <span class="keywordflow">if</span>(pc-&gt;linkStatusCB)
01010                         pc-&gt;linkStatusCB(pc-&gt;linkStatusCtx, PPPERR_CONNECT, NULL);
01011         }
01012     <span class="keywordflow">return</span> st;
01013 }
01014 
01015 <span class="comment">/*</span>
01016 <span class="comment"> * sifaddr - Config the interface IP addresses and netmask.</span>
01017 <span class="comment"> */</span>
01018 <span class="keywordtype">int</span> sifaddr(
01019     <span class="keywordtype">int</span> pd,             <span class="comment">/* Interface unit ??? */</span>
01020     u32_t o,        <span class="comment">/* Our IP address ??? */</span>
01021     u32_t h,        <span class="comment">/* His IP address ??? */</span>
01022     u32_t m,        <span class="comment">/* IP subnet mask ??? */</span>
01023     u32_t ns1,      <span class="comment">/* Primary DNS */</span>
01024     u32_t ns2       <span class="comment">/* Secondary DNS */</span>
01025 )
01026 {
01027     PPPControl *pc = &amp;pppControl[pd];
01028     <span class="keywordtype">int</span> st = 1;
01029     
01030     <span class="keywordflow">if</span> (pd &lt; 0 || pd &gt;= NUM_PPP || !pc-&gt;openFlag) {
01031         st = 0;
01032         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"sifup[%d]: bad parms\n"</span>, pd));
01033     } <span class="keywordflow">else</span> {
01034                 memcpy(&amp;pc-&gt;addrs.our_ipaddr, &amp;o, <span class="keyword">sizeof</span>(o));
01035                 memcpy(&amp;pc-&gt;addrs.his_ipaddr, &amp;h, <span class="keyword">sizeof</span>(h));
01036                 memcpy(&amp;pc-&gt;addrs.netmask, &amp;m, <span class="keyword">sizeof</span>(m));
01037                 memcpy(&amp;pc-&gt;addrs.dns1, &amp;ns1, <span class="keyword">sizeof</span>(ns1));
01038                 memcpy(&amp;pc-&gt;addrs.dns2, &amp;ns2, <span class="keyword">sizeof</span>(ns2));
01039     }
01040     <span class="keywordflow">return</span> st;
01041 }
01042 
01043 <span class="comment">/*</span>
01044 <span class="comment"> * cifaddr - Clear the interface IP addresses, and delete routes</span>
01045 <span class="comment"> * through the interface if possible.</span>
01046 <span class="comment"> */</span>
01047 <span class="keywordtype">int</span> cifaddr(
01048     <span class="keywordtype">int</span> pd,         <span class="comment">/* Interface unit ??? */</span>
01049     u32_t o,    <span class="comment">/* Our IP address ??? */</span>
01050     u32_t h     <span class="comment">/* IP broadcast address ??? */</span>
01051 )
01052 {
01053     PPPControl *pc = &amp;pppControl[pd];
01054     <span class="keywordtype">int</span> st = 1;
01055     
01056         (<span class="keywordtype">void</span>)o;
01057         (<span class="keywordtype">void</span>)h;
01058     <span class="keywordflow">if</span> (pd &lt; 0 || pd &gt;= NUM_PPP || !pc-&gt;openFlag) {
01059         st = 0;
01060         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"sifup[%d]: bad parms\n"</span>, pd));
01061     } <span class="keywordflow">else</span> {
01062                 <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a26">IP4_ADDR</a>(&amp;pc-&gt;addrs.our_ipaddr, 0,0,0,0);
01063                 <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a26">IP4_ADDR</a>(&amp;pc-&gt;addrs.his_ipaddr, 0,0,0,0);
01064                 <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a26">IP4_ADDR</a>(&amp;pc-&gt;addrs.netmask, 255,255,255,0);
01065                 <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a26">IP4_ADDR</a>(&amp;pc-&gt;addrs.dns1, 0,0,0,0);
01066                 <a class="code" href="ipv4_2lwip_2ip__addr_8h.html#a26">IP4_ADDR</a>(&amp;pc-&gt;addrs.dns2, 0,0,0,0);
01067     }
01068     <span class="keywordflow">return</span> st;
01069 }
01070 
01071 <span class="comment">/*</span>
01072 <span class="comment"> * sifdefaultroute - assign a default route through the address given.</span>
01073 <span class="comment"> */</span>
01074 <span class="keywordtype">int</span> sifdefaultroute(<span class="keywordtype">int</span> pd, u32_t l, u32_t g)
01075 {
01076     PPPControl *pc = &amp;pppControl[pd];
01077     <span class="keywordtype">int</span> st = 1;
01078     
01079         (<span class="keywordtype">void</span>)l;
01080         (<span class="keywordtype">void</span>)g;
01081     <span class="keywordflow">if</span> (pd &lt; 0 || pd &gt;= NUM_PPP || !pc-&gt;openFlag) {
01082         st = 0;
01083         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"sifup[%d]: bad parms\n"</span>, pd));
01084     } <span class="keywordflow">else</span> {
01085                 <a class="code" href="netif_8c.html#a9">netif_set_default</a>(pc-&gt;netif);
01086     }
01087 
01088     <span class="comment">/* TODO: check how PPP handled the netMask, previously not set by ipSetDefault */</span>
01089 
01090     <span class="keywordflow">return</span> st;
01091 }
01092 
01093 <span class="comment">/*</span>
01094 <span class="comment"> * cifdefaultroute - delete a default route through the address given.</span>
01095 <span class="comment"> */</span>
01096 <span class="keywordtype">int</span> cifdefaultroute(<span class="keywordtype">int</span> pd, u32_t l, u32_t g)
01097 {
01098     PPPControl *pc = &amp;pppControl[pd];
01099     <span class="keywordtype">int</span> st = 1;
01100     
01101         (<span class="keywordtype">void</span>)l;
01102         (<span class="keywordtype">void</span>)g;
01103     <span class="keywordflow">if</span> (pd &lt; 0 || pd &gt;= NUM_PPP || !pc-&gt;openFlag) {
01104         st = 0;
01105         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"sifup[%d]: bad parms\n"</span>, pd));
01106     } <span class="keywordflow">else</span> {
01107                 <a class="code" href="netif_8c.html#a9">netif_set_default</a>(NULL);
01108     }
01109 
01110     <span class="keywordflow">return</span> st;
01111 }
01112 
01113 <span class="keywordtype">void</span>
01114 pppMainWakeup(<span class="keywordtype">int</span> pd)
01115 {
01116         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_DEBUG, <span class="stringliteral">"pppMainWakeup: unit %d\n"</span>, pd));
01117         <a class="code" href="sio_8h.html#a6">sio_read_abort</a>(pppControl[pd].fd);
01118 }
01119 
01120 <span class="comment">/* these callbacks are necessary because lcp_* functions</span>
01121 <span class="comment">   must be called in the same context as pppInput(),</span>
01122 <span class="comment">   namely the tcpip_thread(), essentially because</span>
01123 <span class="comment">   they manipulate timeouts which are thread-private</span>
01124 <span class="comment">*/</span>
01125 
01126 <span class="keyword">static</span> <span class="keywordtype">void</span>
01127 pppStartCB(<span class="keywordtype">void</span> *arg)
01128 {
01129     <span class="keywordtype">int</span> pd = (<span class="keywordtype">int</span>)arg;
01130 
01131         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_DEBUG, <span class="stringliteral">"pppStartCB: unit %d\n"</span>, pd));
01132     <a class="code" href="lcp_8h.html#a35">lcp_lowerup</a>(pd);
01133     <a class="code" href="lcp_8h.html#a33">lcp_open</a>(pd);      <span class="comment">/* Start protocol */</span>
01134 }
01135 
01136 <span class="keyword">static</span> <span class="keywordtype">void</span>
01137 pppStopCB(<span class="keywordtype">void</span> *arg)
01138 {
01139     <span class="keywordtype">int</span> pd = (<span class="keywordtype">int</span>)arg;
01140 
01141         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_DEBUG, <span class="stringliteral">"pppStopCB: unit %d\n"</span>, pd));
01142     <a class="code" href="lcp_8h.html#a34">lcp_close</a>(pd, <span class="stringliteral">"User request"</span>);
01143 }
01144 
01145 <span class="keyword">static</span> <span class="keywordtype">void</span>
01146 pppHupCB(<span class="keywordtype">void</span> *arg)
01147 {
01148     <span class="keywordtype">int</span> pd = (<span class="keywordtype">int</span>)arg;
01149 
01150         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_DEBUG, <span class="stringliteral">"pppHupCB: unit %d\n"</span>, pd));
01151     <a class="code" href="lcp_8h.html#a36">lcp_lowerdown</a>(pd);
01152     <a class="code" href="auth_8h.html#a1">link_terminated</a>(pd);
01153 }
01154 <span class="comment">/**********************************/</span>
01155 <span class="comment">/*** LOCAL FUNCTION DEFINITIONS ***/</span>
01156 <span class="comment">/**********************************/</span>
01157 <span class="comment">/* The main PPP process function.  This implements the state machine according</span>
01158 <span class="comment"> * to section 4 of RFC 1661: The Point-To-Point Protocol. */</span>
01159 <span class="keyword">static</span> <span class="keywordtype">void</span> pppMain(<span class="keywordtype">void</span> *arg)
01160 {
01161     <span class="keywordtype">int</span> pd = (<span class="keywordtype">int</span>)arg;
01162     <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p;
01163     PPPControl* pc;
01164 
01165     pc = &amp;pppControl[pd];
01166 
01167     p = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(PBUF_RAW, PPP_MRU+PPP_HDRLEN, PBUF_RAM);
01168     <span class="keywordflow">if</span>(!p) {
01169                 <a class="code" href="debug_8h.html#a11">LWIP_ASSERT</a>(<span class="stringliteral">"p != NULL"</span>, p);
01170                 pc-&gt;errCode = PPPERR_ALLOC;
01171                 <span class="keywordflow">goto</span> out;
01172     }
01173 
01174     <span class="comment">/*</span>
01175 <span class="comment">     * Start the connection and handle incoming events (packet or timeout).</span>
01176 <span class="comment">     */</span>
01177         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"pppMain: unit %d: Connecting\n"</span>, pd));
01178     <a class="code" href="tcpip_8c.html#a5">tcpip_callback</a>(pppStartCB, arg);
01179     <span class="keywordflow">while</span> (<a class="code" href="lcp_8h.html#a18">lcp_phase</a>[pd] != <a class="code" href="lcp_8h.html#a38a25">PHASE_DEAD</a>) {
01180         <span class="keywordflow">if</span> (pc-&gt;kill_link) {
01181                 <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_DEBUG, <span class="stringliteral">"pppMainWakeup: unit %d kill_link -&gt; pppStopCB\n"</span>, pd));
01182                 pc-&gt;errCode = PPPERR_USER;
01183                 <span class="comment">/* This will leave us at PHASE_DEAD. */</span>
01184                 <a class="code" href="tcpip_8c.html#a5">tcpip_callback</a>(pppStopCB, arg);
01185                 pc-&gt;kill_link = 0;
01186         }
01187         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pc-&gt;sig_hup) {
01188                 <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_DEBUG, <span class="stringliteral">"pppMainWakeup: unit %d sig_hup -&gt; pppHupCB\n"</span>, pd));
01189                 pc-&gt;sig_hup = 0;
01190                 <a class="code" href="tcpip_8c.html#a5">tcpip_callback</a>(pppHupCB, arg);
01191         } <span class="keywordflow">else</span> {
01192                 <span class="keywordtype">int</span> c = <a class="code" href="sio_8h.html#a4">sio_read</a>(pc-&gt;fd, p-&gt;payload, p-&gt;len);
01193                 <span class="keywordflow">if</span>(c &gt; 0) {
01194                         pppInProc(pd, p-&gt;payload, c);
01195                 } <span class="keywordflow">else</span> {
01196                     <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_DEBUG, <span class="stringliteral">"pppMainWakeup: unit %d sio_read len=%d returned %d\n"</span>, pd, p-&gt;len, c));
01197                     <a class="code" href="sys_8c.html#a6">sys_msleep</a>(250); <span class="comment">/* give other tasks a chance to run */</span>
01198                 }
01199         }
01200     }
01201         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"pppMain: unit %d: PHASE_DEAD\n"</span>, pd));
01202     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
01203 
01204 out:
01205         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_DEBUG, <span class="stringliteral">"pppMain: unit %d: linkStatusCB=%lx errCode=%d\n"</span>, pd, pc-&gt;linkStatusCB, pc-&gt;errCode));
01206     <span class="keywordflow">if</span>(pc-&gt;linkStatusCB)
01207             pc-&gt;linkStatusCB(pc-&gt;linkStatusCtx, pc-&gt;errCode ? pc-&gt;errCode : PPPERR_PROTOCOL, NULL);
01208 
01209     pc-&gt;openFlag = 0;
01210 }
01211 
01212 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *pppSingleBuf(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p)
01213 {
01214         <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *q, *b;
01215         u_char *pl;
01216 
01217         <span class="keywordflow">if</span>(p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a> == p-&gt;<a class="code" href="structpbuf.html#o3">len</a>)
01218                 <span class="keywordflow">return</span> p;
01219 
01220         q = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(PBUF_RAW, p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a>, PBUF_RAM);
01221         <span class="keywordflow">if</span>(!q) {
01222                 <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_ERR,
01223                         <span class="stringliteral">"pppSingleBuf: unable to alloc new buf (%d)\n"</span>, p-&gt;<a class="code" href="structpbuf.html#o2">tot_len</a>));
01224                 <span class="keywordflow">return</span> p; <span class="comment">/* live dangerously */</span>
01225         }
01226 
01227         <span class="keywordflow">for</span>(b = p, pl = q-&gt;<a class="code" href="structpbuf.html#o1">payload</a>; b != <a class="code" href="def_8h.html#a2">NULL</a>; b = b-&gt;next) {
01228                 memcpy(pl, b-&gt;payload, b-&gt;len);
01229                 pl += b-&gt;len;
01230         }
01231 
01232         <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(p);
01233 
01234         <span class="keywordflow">return</span> q;
01235 }
01236 
01237 <span class="keyword">struct </span>pppInputHeader {
01238         <span class="keywordtype">int</span> unit;
01239         u16_t proto;
01240 };
01241 
01242 <span class="comment">/*</span>
01243 <span class="comment"> * Pass the processed input packet to the appropriate handler.</span>
01244 <span class="comment"> * This function and all handlers run in the context of the tcpip_thread</span>
01245 <span class="comment"> */</span>
01246 <span class="keyword">static</span> <span class="keywordtype">void</span> pppInput(<span class="keywordtype">void</span> *arg)
01247 {
01248         <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *nb = (<span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *)arg;
01249     u16_t protocol;
01250     <span class="keywordtype">int</span> pd;
01251 
01252         pd = ((<span class="keyword">struct </span><a class="code" href="classpppInputHeader.html">pppInputHeader</a> *)nb-&gt;payload)-&gt;unit;
01253         protocol = ((<span class="keyword">struct </span><a class="code" href="classpppInputHeader.html">pppInputHeader</a> *)nb-&gt;payload)-&gt;proto;
01254 
01255     <a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(nb, -(<span class="keywordtype">int</span>)<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="classpppInputHeader.html">pppInputHeader</a>));
01256 
01257 <span class="preprocessor">#ifdef LINK_STATS</span>
01258 <span class="preprocessor"></span>    lwip_stats.link.recv++;
01259 <span class="preprocessor">#endif </span><span class="comment">/* LINK_STATS */</span>
01260 
01261     <span class="comment">/*</span>
01262 <span class="comment">     * Toss all non-LCP packets unless LCP is OPEN.</span>
01263 <span class="comment">     * Until we get past the authentication phase, toss all packets</span>
01264 <span class="comment">     * except LCP, LQR and authentication packets.</span>
01265 <span class="comment">     */</span>
01266     <span class="keywordflow">if</span>((<a class="code" href="lcp_8h.html#a18">lcp_phase</a>[pd] &lt;= <a class="code" href="lcp_8h.html#a38a28">PHASE_AUTHENTICATE</a>) &amp;&amp; (protocol != PPP_LCP)) {
01267             <span class="keywordflow">if</span>(!((protocol == PPP_LQR) || (protocol == PPP_PAP) || (protocol == PPP_CHAP)) ||
01268                         (<a class="code" href="lcp_8h.html#a18">lcp_phase</a>[pd] != <a class="code" href="lcp_8h.html#a38a28">PHASE_AUTHENTICATE</a>)) {
01269                 <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"pppInput: discarding proto 0x%04X in phase %d\n"</span>, protocol, lcp_phase[pd]));
01270                 <span class="keywordflow">goto</span> drop;
01271             }
01272     }
01273 
01274     <span class="keywordflow">switch</span>(protocol) {
01275     <span class="keywordflow">case</span> PPP_VJC_COMP:      <span class="comment">/* VJ compressed TCP */</span>
01276 <span class="preprocessor">#if VJ_SUPPORT &gt; 0</span>
01277 <span class="preprocessor"></span>        <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"pppInput[%d]: vj_comp in pbuf len=%d\n"</span>, pd, nb-&gt;len));
01278         <span class="comment">/*</span>
01279 <span class="comment">         * Clip off the VJ header and prepend the rebuilt TCP/IP header and</span>
01280 <span class="comment">         * pass the result to IP.</span>
01281 <span class="comment">         */</span>
01282         <span class="keywordflow">if</span> (<a class="code" href="vj_8h.html#a23">vj_uncompress_tcp</a>(&amp;nb, &amp;pppControl[pd].vjComp) &gt;= 0) {
01283             pppControl[pd].netif-&gt;input(nb, pppControl[pd].netif);
01284                         <span class="keywordflow">return</span>;
01285         }
01286         <span class="comment">/* Something's wrong so drop it. */</span>
01287         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"pppInput[%d]: Dropping VJ compressed\n"</span>, pd));
01288 <span class="preprocessor">#else</span>
01289 <span class="preprocessor"></span>        <span class="comment">/* No handler for this protocol so drop the packet. */</span>
01290         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"pppInput[%d]: drop VJ Comp in %d:%s\n"</span>, pd, nb-&gt;len, nb-&gt;payload));
01291 <span class="preprocessor">#endif </span><span class="comment">/* VJ_SUPPORT &gt; 0 */</span>
01292         <span class="keywordflow">break</span>;
01293     <span class="keywordflow">case</span> PPP_VJC_UNCOMP:    <span class="comment">/* VJ uncompressed TCP */</span>
01294 <span class="preprocessor">#if VJ_SUPPORT &gt; 0</span>
01295 <span class="preprocessor"></span>        <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"pppInput[%d]: vj_un in pbuf len=%d\n"</span>, pd, nb-&gt;len));
01296         <span class="comment">/*</span>
01297 <span class="comment">         * Process the TCP/IP header for VJ header compression and then pass</span>
01298 <span class="comment">         * the packet to IP.</span>
01299 <span class="comment">         */</span>
01300         <span class="keywordflow">if</span> (<a class="code" href="vj_8h.html#a22">vj_uncompress_uncomp</a>(nb, &amp;pppControl[pd].vjComp) &gt;= 0) {
01301             pppControl[pd].netif-&gt;input(nb, pppControl[pd].netif);
01302                         <span class="keywordflow">return</span>;
01303         }
01304         <span class="comment">/* Something's wrong so drop it. */</span>
01305         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING, <span class="stringliteral">"pppInput[%d]: Dropping VJ uncompressed\n"</span>, pd));
01306 <span class="preprocessor">#else</span>
01307 <span class="preprocessor"></span>        <span class="comment">/* No handler for this protocol so drop the packet. */</span>
01308         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO,
01309                     <span class="stringliteral">"pppInput[%d]: drop VJ UnComp in %d:.*H\n"</span>, 
01310                     pd, nb-&gt;len, <a class="code" href="def_8h.html#a1">LWIP_MIN</a>(nb-&gt;len * 2, 40), nb-&gt;payload));
01311 <span class="preprocessor">#endif </span><span class="comment">/* VJ_SUPPORT &gt; 0 */</span>
01312         <span class="keywordflow">break</span>;
01313     <span class="keywordflow">case</span> PPP_IP:            <span class="comment">/* Internet Protocol */</span>
01314         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"pppInput[%d]: ip in pbuf len=%d\n"</span>, pd, nb-&gt;len));
01315         pppControl[pd].netif-&gt;input(nb, pppControl[pd].netif);
01316                 <span class="keywordflow">return</span>;
01317     <span class="keywordflow">default</span>:
01318         {
01319                 <span class="keyword">struct </span>protent *protp;
01320                 <span class="keywordtype">int</span> i;
01321 
01322                 <span class="comment">/*</span>
01323 <span class="comment">                 * Upcall the proper protocol input routine.</span>
01324 <span class="comment">                 */</span>
01325                 <span class="keywordflow">for</span> (i = 0; (protp = ppp_protocols[i]) != <a class="code" href="def_8h.html#a2">NULL</a>; ++i) {
01326                         <span class="keywordflow">if</span> (protp-&gt;protocol == protocol &amp;&amp; protp-&gt;enabled_flag) {
01327                                 <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"pppInput[%d]: %s len=%d\n"</span>, pd, protp-&gt;name, nb-&gt;len));
01328                                 nb = pppSingleBuf(nb);
01329                                 (*protp-&gt;input)(pd, nb-&gt;payload, nb-&gt;len);
01330                                 <span class="keywordflow">goto</span> out;
01331                         }
01332                 }
01333 
01334                 <span class="comment">/* No handler for this protocol so reject the packet. */</span>
01335                 <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"pppInput[%d]: rejecting unsupported proto 0x%04X len=%d\n"</span>, pd, protocol, nb-&gt;len));
01336                 <a class="code" href="pbuf_8c.html#a13">pbuf_header</a>(nb, <span class="keyword">sizeof</span>(protocol));
01337 <span class="preprocessor">#if BYTE_ORDER == LITTLE_ENDIAN</span>
01338 <span class="preprocessor"></span>                protocol = <a class="code" href="ipv4_2lwip_2inet_8h.html#a0">htons</a>(protocol);
01339                 memcpy(nb-&gt;payload, &amp;protocol, <span class="keyword">sizeof</span>(protocol));
01340 <span class="preprocessor">#endif</span>
01341 <span class="preprocessor"></span>                <a class="code" href="lcp_8h.html#a37">lcp_sprotrej</a>(pd, nb-&gt;payload, nb-&gt;len);
01342         }
01343         <span class="keywordflow">break</span>;
01344     }
01345 
01346 drop:
01347 <span class="preprocessor">#ifdef LINK_STATS</span>
01348 <span class="preprocessor"></span>    lwip_stats.link.drop++;
01349 <span class="preprocessor">#endif</span>
01350 <span class="preprocessor"></span>
01351 out:
01352     <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(nb);
01353     <span class="keywordflow">return</span>;
01354 }
01355 
01356 
01357 <span class="comment">/*</span>
01358 <span class="comment"> * Drop the input packet.</span>
01359 <span class="comment"> */</span>
01360 <span class="keyword">static</span> <span class="keywordtype">void</span> pppDrop(PPPControl *pc)
01361 {
01362     <span class="keywordflow">if</span> (pc-&gt;inHead != <a class="code" href="def_8h.html#a2">NULL</a>) {
01363 <span class="preprocessor">#if 0       </span>
01364 <span class="preprocessor"></span>        <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"pppDrop: %d:%.*H\n"</span>, pc-&gt;inHead-&gt;len, min(60, pc-&gt;inHead-&gt;len * 2), pc-&gt;inHead-&gt;payload));
01365 <span class="preprocessor">#endif  </span>
01366 <span class="preprocessor"></span>        <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO, <span class="stringliteral">"pppDrop: pbuf len=%d\n"</span>, pc-&gt;inHead-&gt;len));
01367         <span class="keywordflow">if</span> (pc-&gt;inTail &amp;&amp; (pc-&gt;inTail != pc-&gt;inHead))
01368             <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(pc-&gt;inTail);
01369         <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(pc-&gt;inHead);
01370         pc-&gt;inHead = <a class="code" href="def_8h.html#a2">NULL</a>;
01371         pc-&gt;inTail = <a class="code" href="def_8h.html#a2">NULL</a>;
01372     }
01373 <span class="preprocessor">#if VJ_SUPPORT &gt; 0</span>
01374 <span class="preprocessor"></span>    <a class="code" href="vj_8h.html#a21">vj_uncompress_err</a>(&amp;pc-&gt;vjComp);
01375 <span class="preprocessor">#endif</span>
01376 <span class="preprocessor"></span>
01377 <span class="preprocessor">#ifdef LINK_STATS</span>
01378 <span class="preprocessor"></span>    lwip_stats.link.drop++;
01379 <span class="preprocessor">#endif </span><span class="comment">/* LINK_STATS */</span>
01380 }
01381 
01382 
01383 <span class="comment">/*</span>
01384 <span class="comment"> * Process a received octet string.</span>
01385 <span class="comment"> */</span>
01386 <span class="keyword">static</span> <span class="keywordtype">void</span> pppInProc(<span class="keywordtype">int</span> pd, u_char *s, <span class="keywordtype">int</span> l)
01387 {
01388     PPPControl *pc = &amp;pppControl[pd];
01389     <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *nextNBuf;
01390     u_char curChar;
01391 
01392     <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_DEBUG, <span class="stringliteral">"pppInProc[%d]: got %d bytes\n"</span>, pd, l));
01393     <span class="keywordflow">while</span> (l-- &gt; 0) {
01394         curChar = *s++;
01395         
01396         <span class="comment">/* Handle special characters. */</span>
01397         <span class="keywordflow">if</span> (ESCAPE_P(pc-&gt;inACCM, curChar)) {
01398             <span class="comment">/* Check for escape sequences. */</span>
01399             <span class="comment">/* XXX Note that this does not handle an escaped 0x5d character which</span>
01400 <span class="comment">             * would appear as an escape character.  Since this is an ASCII ']'</span>
01401 <span class="comment">             * and there is no reason that I know of to escape it, I won't complicate</span>
01402 <span class="comment">             * the code to handle this case. GLL */</span>
01403             <span class="keywordflow">if</span> (curChar == PPP_ESCAPE)
01404                 pc-&gt;inEscaped = 1;
01405             <span class="comment">/* Check for the flag character. */</span>
01406             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (curChar == PPP_FLAG) {
01407                 <span class="comment">/* If this is just an extra flag character, ignore it. */</span>
01408                 <span class="keywordflow">if</span> (pc-&gt;inState &lt;= PDADDRESS)
01409                     ;
01410                 <span class="comment">/* If we haven't received the packet header, drop what has come in. */</span>
01411                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pc-&gt;inState &lt; PDDATA) {
01412                     <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING,
01413                                 <span class="stringliteral">"pppInProc[%d]: Dropping incomplete packet %d\n"</span>, 
01414                                 pd, pc-&gt;inState));
01415 <span class="preprocessor">#ifdef LINK_STATS</span>
01416 <span class="preprocessor"></span>                                        lwip_stats.link.lenerr++;
01417 <span class="preprocessor">#endif</span>
01418 <span class="preprocessor"></span>                    pppDrop(pc);
01419                 }
01420                 <span class="comment">/* If the fcs is invalid, drop the packet. */</span>
01421                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pc-&gt;inFCS != PPP_GOODFCS) {
01422                     <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_INFO,
01423                                 <span class="stringliteral">"pppInProc[%d]: Dropping bad fcs 0x%04X proto=0x%04X\n"</span>, 
01424                                 pd, pc-&gt;inFCS, pc-&gt;inProtocol));
01425 <span class="preprocessor">#ifdef LINK_STATS</span>
01426 <span class="preprocessor"></span>                                        lwip_stats.link.chkerr++;
01427 <span class="preprocessor">#endif</span>
01428 <span class="preprocessor"></span>                    pppDrop(pc);
01429                 }
01430                 <span class="comment">/* Otherwise it's a good packet so pass it on. */</span>
01431                 <span class="keywordflow">else</span> {
01432                     
01433                     <span class="comment">/* Trim off the checksum. */</span>
01434                     <span class="keywordflow">if</span>(pc-&gt;inTail-&gt;len &gt;= 2) {
01435                         pc-&gt;inTail-&gt;len -= 2;
01436 
01437                         pc-&gt;inTail-&gt;tot_len = pc-&gt;inTail-&gt;len;
01438                         <span class="keywordflow">if</span> (pc-&gt;inTail != pc-&gt;inHead) {
01439                             <a class="code" href="pbuf_8c.html#a17">pbuf_chain</a>(pc-&gt;inHead, pc-&gt;inTail);
01440                             <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(pc-&gt;inTail);
01441                         }
01442                     } <span class="keywordflow">else</span> {
01443                         pc-&gt;inTail-&gt;tot_len = pc-&gt;inTail-&gt;len;
01444                         <span class="keywordflow">if</span> (pc-&gt;inTail != pc-&gt;inHead) {
01445                             <a class="code" href="pbuf_8c.html#a17">pbuf_chain</a>(pc-&gt;inHead, pc-&gt;inTail);
01446                             <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(pc-&gt;inTail);
01447                         }
01448 
01449                         <a class="code" href="pbuf_8c.html#a12">pbuf_realloc</a>(pc-&gt;inHead, pc-&gt;inHead-&gt;tot_len - 2);
01450                     }
01451 
01452                     <span class="comment">/* Dispatch the packet thereby consuming it. */</span>
01453                     <span class="keywordflow">if</span>(<a class="code" href="tcpip_8c.html#a5">tcpip_callback</a>(pppInput, pc-&gt;inHead) != <a class="code" href="err_8h.html#a0">ERR_OK</a>) {
01454                         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_ERR,
01455                                     <span class="stringliteral">"pppInProc[%d]: tcpip_callback() failed, dropping packet\n"</span>, pd));
01456                         <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(pc-&gt;inHead);
01457 <span class="preprocessor">#ifdef LINK_STATS</span>
01458 <span class="preprocessor"></span>                        lwip_stats.link.drop++;
01459 <span class="preprocessor">#endif</span>
01460 <span class="preprocessor"></span>                    }
01461                     pc-&gt;inHead = <a class="code" href="def_8h.html#a2">NULL</a>;
01462                     pc-&gt;inTail = <a class="code" href="def_8h.html#a2">NULL</a>;
01463                 }
01464                     
01465                 <span class="comment">/* Prepare for a new packet. */</span>
01466                 pc-&gt;inFCS = PPP_INITFCS;
01467                 pc-&gt;inState = PDADDRESS;
01468                 pc-&gt;inEscaped = 0;
01469             }
01470             <span class="comment">/* Other characters are usually control characters that may have</span>
01471 <span class="comment">             * been inserted by the physical layer so here we just drop them. */</span>
01472             <span class="keywordflow">else</span> {
01473                 <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING,
01474                             <span class="stringliteral">"pppInProc[%d]: Dropping ACCM char &lt;%d&gt;\n"</span>, pd, curChar));
01475             }
01476         }
01477         <span class="comment">/* Process other characters. */</span>
01478         <span class="keywordflow">else</span> {
01479             <span class="comment">/* Unencode escaped characters. */</span>
01480             <span class="keywordflow">if</span> (pc-&gt;inEscaped) {
01481                 pc-&gt;inEscaped = 0;
01482                 curChar ^= PPP_TRANS;
01483             }
01484             
01485             <span class="comment">/* Process character relative to current state. */</span>
01486             <span class="keywordflow">switch</span>(pc-&gt;inState) {
01487             <span class="keywordflow">case</span> PDIDLE:                    <span class="comment">/* Idle state - waiting. */</span>
01488                 <span class="comment">/* Drop the character if it's not 0xff</span>
01489 <span class="comment">                 * we would have processed a flag character above. */</span>
01490                 <span class="keywordflow">if</span> (curChar != PPP_ALLSTATIONS) {
01491                         <span class="keywordflow">break</span>;
01492                                 }
01493 
01494                                 <span class="comment">/* Fall through */</span>
01495             <span class="keywordflow">case</span> PDSTART:                   <span class="comment">/* Process start flag. */</span>
01496                 <span class="comment">/* Prepare for a new packet. */</span>
01497                 pc-&gt;inFCS = PPP_INITFCS;
01498 
01499                                 <span class="comment">/* Fall through */</span>
01500             <span class="keywordflow">case</span> PDADDRESS:                 <span class="comment">/* Process address field. */</span>
01501                 <span class="keywordflow">if</span> (curChar == PPP_ALLSTATIONS) {
01502                     pc-&gt;inState = PDCONTROL;
01503                     <span class="keywordflow">break</span>;
01504                 }
01505                 <span class="comment">/* Else assume compressed address and control fields so</span>
01506 <span class="comment">                 * fall through to get the protocol... */</span>
01507             <span class="keywordflow">case</span> PDCONTROL:                 <span class="comment">/* Process control field. */</span>
01508                 <span class="comment">/* If we don't get a valid control code, restart. */</span>
01509                 <span class="keywordflow">if</span> (curChar == PPP_UI) {
01510                     pc-&gt;inState = PDPROTOCOL1;
01511                         <span class="keywordflow">break</span>;
01512                 }
01513 <span class="preprocessor">#if 0</span>
01514 <span class="preprocessor"></span>                <span class="keywordflow">else</span> {
01515                     <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_WARNING,
01516                                 <span class="stringliteral">"pppInProc[%d]: Invalid control &lt;%d&gt;\n"</span>, pd, curChar));
01517                     pc-&gt;inState = PDSTART;
01518                 }
01519 <span class="preprocessor">#endif</span>
01520 <span class="preprocessor"></span>            <span class="keywordflow">case</span> PDPROTOCOL1:               <span class="comment">/* Process protocol field 1. */</span>
01521                 <span class="comment">/* If the lower bit is set, this is the end of the protocol</span>
01522 <span class="comment">                 * field. */</span>
01523                 <span class="keywordflow">if</span> (curChar &amp; 1) {
01524                     pc-&gt;inProtocol = curChar;
01525                     pc-&gt;inState = PDDATA;
01526                 }
01527                 <span class="keywordflow">else</span> {
01528                     pc-&gt;inProtocol = (u_int)curChar &lt;&lt; 8;
01529                     pc-&gt;inState = PDPROTOCOL2;
01530                 }
01531                 <span class="keywordflow">break</span>;
01532             <span class="keywordflow">case</span> PDPROTOCOL2:               <span class="comment">/* Process protocol field 2. */</span>
01533                 pc-&gt;inProtocol |= curChar;
01534                 pc-&gt;inState = PDDATA;
01535                 <span class="keywordflow">break</span>;
01536             <span class="keywordflow">case</span> PDDATA:                    <span class="comment">/* Process data byte. */</span>
01537                 <span class="comment">/* Make space to receive processed data. */</span>
01538                 <span class="keywordflow">if</span> (pc-&gt;inTail == <a class="code" href="def_8h.html#a2">NULL</a> || pc-&gt;inTail-&gt;len == <a class="code" href="opt_8h.html#a15">PBUF_POOL_BUFSIZE</a>) {
01539                     <span class="keywordflow">if</span>(pc-&gt;inTail) {
01540                         pc-&gt;inTail-&gt;tot_len = pc-&gt;inTail-&gt;len;
01541                         <span class="keywordflow">if</span> (pc-&gt;inTail != pc-&gt;inHead) {
01542                             <a class="code" href="pbuf_8c.html#a17">pbuf_chain</a>(pc-&gt;inHead, pc-&gt;inTail);
01543                             <a class="code" href="pbuf_8c.html#a14">pbuf_free</a>(pc-&gt;inTail);
01544                         }
01545                     }
01546                     <span class="comment">/* If we haven't started a packet, we need a packet header. */</span>
01547                     nextNBuf = <a class="code" href="pbuf_8c.html#a11">pbuf_alloc</a>(PBUF_RAW, 0, PBUF_POOL);
01548                     <span class="keywordflow">if</span> (nextNBuf == <a class="code" href="def_8h.html#a2">NULL</a>) {
01549                         <span class="comment">/* No free buffers.  Drop the input packet and let the</span>
01550 <span class="comment">                         * higher layers deal with it.  Continue processing</span>
01551 <span class="comment">                         * the received pbuf chain in case a new packet starts. */</span>
01552                         <a class="code" href="pppdebug_8h.html#a6">PPPDEBUG</a>((LOG_ERR, <span class="stringliteral">"pppInProc[%d]: NO FREE MBUFS!\n"</span>, pd));
01553 <span class="preprocessor">#ifdef LINK_STATS</span>
01554 <span class="preprocessor"></span>                                                lwip_stats.link.memerr++;
01555 <span class="preprocessor">#endif </span><span class="comment">/* LINK_STATS */</span>
01556                         pppDrop(pc);
01557                         pc-&gt;inState = PDSTART;  <span class="comment">/* Wait for flag sequence. */</span>
01558                         <span class="keywordflow">break</span>;
01559                     }
01560                     <span class="keywordflow">if</span> (pc-&gt;inHead == <a class="code" href="def_8h.html#a2">NULL</a>) {
01561                         <span class="keyword">struct </span><a class="code" href="classpppInputHeader.html">pppInputHeader</a> *pih = nextNBuf-&gt;payload;
01562 
01563                         pih-&gt;unit = pd;
01564                         pih-&gt;proto = pc-&gt;inProtocol;
01565 
01566                         nextNBuf-&gt;len += <span class="keyword">sizeof</span>(*pih);
01567 
01568                         pc-&gt;inHead = nextNBuf;
01569                     }
01570                     pc-&gt;inTail = nextNBuf;
01571                 }
01572                 <span class="comment">/* Load character into buffer. */</span>
01573                 ((u_char*)pc-&gt;inTail-&gt;payload)[pc-&gt;inTail-&gt;len++] = curChar;
01574                 <span class="keywordflow">break</span>;
01575             }
01576 
01577             <span class="comment">/* update the frame check sequence number. */</span>
01578             pc-&gt;inFCS = PPP_FCS(pc-&gt;inFCS, curChar);
01579         }
01580     }
01581         <a class="code" href="randm_8c.html#a3">avRandomize</a>();
01582 }
01583 
01584 <span class="preprocessor">#endif </span><span class="comment">/* PPP_SUPPORT */</span>
</pre></div>	</td>
  </tr>
</table>
<hr>
<div align="center">Copyright (c) 2001-2003 Swedish Institute of Computer Science</div>
</html>
